{"ast":null,"code":"import { isDataSource } from './_data-source-chunk.mjs';\nconst _c0 = [[[\"caption\"]], [[\"colgroup\"], [\"col\"]], \"*\"];\nconst _c1 = [\"caption\", \"colgroup, col\", \"*\"];\nfunction CdkTable_Conditional_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2);\n  }\n}\nfunction CdkTable_Conditional_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"thead\", 0);\n    i0.ɵɵelementContainer(1, 1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"tbody\", 0);\n    i0.ɵɵelementContainer(3, 2)(4, 3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"tfoot\", 0);\n    i0.ɵɵelementContainer(6, 4);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction CdkTable_Conditional_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 1)(1, 2)(2, 3)(3, 4);\n  }\n}\nfunction CdkTextColumn_th_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"text-align\", ctx_r0.justify);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.headerText, \" \");\n  }\n}\nfunction CdkTextColumn_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const data_r2 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"text-align\", ctx_r0.justify);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.dataAccessor(data_r2, ctx_r0.name), \" \");\n  }\n}\nexport { DataSource } from './_data-source-chunk.mjs';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, TemplateRef, Directive, booleanAttribute, Input, ContentChild, ElementRef, IterableDiffers, ViewContainerRef, Component, ChangeDetectionStrategy, ViewEncapsulation, afterNextRender, ChangeDetectorRef, DOCUMENT, EventEmitter, Injector, HostAttributeToken, Output, ContentChildren, ViewChild, NgModule } from '@angular/core';\nimport { Subject, BehaviorSubject, isObservable, of } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy, _ViewRepeaterOperation } from './_recycle-view-repeater-strategy-chunk.mjs';\nimport { _DisposeViewRepeaterStrategy } from './_dispose-view-repeater-strategy-chunk.mjs';\nimport { Directionality } from './_directionality-chunk.mjs';\nimport { Platform } from './_platform-chunk.mjs';\nimport { ViewportRuler, ScrollingModule } from './scrolling.mjs';\nimport '@angular/common';\nimport './_element-chunk.mjs';\nimport './_scrolling-chunk.mjs';\nimport './bidi.mjs';\nconst CDK_TABLE = /*#__PURE__*/new InjectionToken('CDK_TABLE');\nconst TEXT_COLUMN_OPTIONS = /*#__PURE__*/new InjectionToken('text-column-options');\nlet CdkCellDef = /*#__PURE__*/(() => {\n  class CdkCellDef {\n    template = inject(TemplateRef);\n    constructor() {}\n    static ɵfac = function CdkCellDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkCellDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkCellDef,\n      selectors: [[\"\", \"cdkCellDef\", \"\"]]\n    });\n  }\n  return CdkCellDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkHeaderCellDef = /*#__PURE__*/(() => {\n  class CdkHeaderCellDef {\n    template = inject(TemplateRef);\n    constructor() {}\n    static ɵfac = function CdkHeaderCellDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkHeaderCellDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkHeaderCellDef,\n      selectors: [[\"\", \"cdkHeaderCellDef\", \"\"]]\n    });\n  }\n  return CdkHeaderCellDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkFooterCellDef = /*#__PURE__*/(() => {\n  class CdkFooterCellDef {\n    template = inject(TemplateRef);\n    constructor() {}\n    static ɵfac = function CdkFooterCellDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkFooterCellDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkFooterCellDef,\n      selectors: [[\"\", \"cdkFooterCellDef\", \"\"]]\n    });\n  }\n  return CdkFooterCellDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkColumnDef = /*#__PURE__*/(() => {\n  class CdkColumnDef {\n    _table = inject(CDK_TABLE, {\n      optional: true\n    });\n    _hasStickyChanged = false;\n    get name() {\n      return this._name;\n    }\n    set name(name) {\n      this._setNameInput(name);\n    }\n    _name;\n    get sticky() {\n      return this._sticky;\n    }\n    set sticky(value) {\n      if (value !== this._sticky) {\n        this._sticky = value;\n        this._hasStickyChanged = true;\n      }\n    }\n    _sticky = false;\n    get stickyEnd() {\n      return this._stickyEnd;\n    }\n    set stickyEnd(value) {\n      if (value !== this._stickyEnd) {\n        this._stickyEnd = value;\n        this._hasStickyChanged = true;\n      }\n    }\n    _stickyEnd = false;\n    cell;\n    headerCell;\n    footerCell;\n    cssClassFriendlyName;\n    _columnCssClassName;\n    constructor() {}\n    hasStickyChanged() {\n      const hasStickyChanged = this._hasStickyChanged;\n      this.resetStickyChanged();\n      return hasStickyChanged;\n    }\n    resetStickyChanged() {\n      this._hasStickyChanged = false;\n    }\n    _updateColumnCssClassName() {\n      this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];\n    }\n    _setNameInput(value) {\n      if (value) {\n        this._name = value;\n        this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/gi, '-');\n        this._updateColumnCssClassName();\n      }\n    }\n    static ɵfac = function CdkColumnDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkColumnDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkColumnDef,\n      selectors: [[\"\", \"cdkColumnDef\", \"\"]],\n      contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkCellDef, 5)(dirIndex, CdkHeaderCellDef, 5)(dirIndex, CdkFooterCellDef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cell = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerCell = _t.first);\n        }\n      },\n      inputs: {\n        name: [0, \"cdkColumnDef\", \"name\"],\n        sticky: [2, \"sticky\", \"sticky\", booleanAttribute],\n        stickyEnd: [2, \"stickyEnd\", \"stickyEnd\", booleanAttribute]\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: 'MAT_SORT_HEADER_COLUMN_DEF',\n        useExisting: CdkColumnDef\n      }])]\n    });\n  }\n  return CdkColumnDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass BaseCdkCell {\n  constructor(columnDef, elementRef) {\n    elementRef.nativeElement.classList.add(...columnDef._columnCssClassName);\n  }\n}\nlet CdkHeaderCell = /*#__PURE__*/(() => {\n  class CdkHeaderCell extends BaseCdkCell {\n    constructor() {\n      super(inject(CdkColumnDef), inject(ElementRef));\n    }\n    static ɵfac = function CdkHeaderCell_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkHeaderCell)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkHeaderCell,\n      selectors: [[\"cdk-header-cell\"], [\"th\", \"cdk-header-cell\", \"\"]],\n      hostAttrs: [\"role\", \"columnheader\", 1, \"cdk-header-cell\"],\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return CdkHeaderCell;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkFooterCell = /*#__PURE__*/(() => {\n  class CdkFooterCell extends BaseCdkCell {\n    constructor() {\n      const columnDef = inject(CdkColumnDef);\n      const elementRef = inject(ElementRef);\n      super(columnDef, elementRef);\n      const role = columnDef._table?._getCellRole();\n      if (role) {\n        elementRef.nativeElement.setAttribute('role', role);\n      }\n    }\n    static ɵfac = function CdkFooterCell_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkFooterCell)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkFooterCell,\n      selectors: [[\"cdk-footer-cell\"], [\"td\", \"cdk-footer-cell\", \"\"]],\n      hostAttrs: [1, \"cdk-footer-cell\"],\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return CdkFooterCell;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkCell = /*#__PURE__*/(() => {\n  class CdkCell extends BaseCdkCell {\n    constructor() {\n      const columnDef = inject(CdkColumnDef);\n      const elementRef = inject(ElementRef);\n      super(columnDef, elementRef);\n      const role = columnDef._table?._getCellRole();\n      if (role) {\n        elementRef.nativeElement.setAttribute('role', role);\n      }\n    }\n    static ɵfac = function CdkCell_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkCell)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkCell,\n      selectors: [[\"cdk-cell\"], [\"td\", \"cdk-cell\", \"\"]],\n      hostAttrs: [1, \"cdk-cell\"],\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return CdkCell;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;\nlet BaseRowDef = /*#__PURE__*/(() => {\n  class BaseRowDef {\n    template = inject(TemplateRef);\n    _differs = inject(IterableDiffers);\n    columns;\n    _columnsDiffer;\n    constructor() {}\n    ngOnChanges(changes) {\n      if (!this._columnsDiffer) {\n        const columns = changes['columns'] && changes['columns'].currentValue || [];\n        this._columnsDiffer = this._differs.find(columns).create();\n        this._columnsDiffer.diff(columns);\n      }\n    }\n    getColumnsDiff() {\n      return this._columnsDiffer.diff(this.columns);\n    }\n    extractCellTemplate(column) {\n      if (this instanceof CdkHeaderRowDef) {\n        return column.headerCell.template;\n      }\n      if (this instanceof CdkFooterRowDef) {\n        return column.footerCell.template;\n      } else {\n        return column.cell.template;\n      }\n    }\n    static ɵfac = function BaseRowDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BaseRowDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: BaseRowDef,\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return BaseRowDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkHeaderRowDef = /*#__PURE__*/(() => {\n  class CdkHeaderRowDef extends BaseRowDef {\n    _table = inject(CDK_TABLE, {\n      optional: true\n    });\n    _hasStickyChanged = false;\n    get sticky() {\n      return this._sticky;\n    }\n    set sticky(value) {\n      if (value !== this._sticky) {\n        this._sticky = value;\n        this._hasStickyChanged = true;\n      }\n    }\n    _sticky = false;\n    constructor() {\n      super(inject(TemplateRef), inject(IterableDiffers));\n    }\n    ngOnChanges(changes) {\n      super.ngOnChanges(changes);\n    }\n    hasStickyChanged() {\n      const hasStickyChanged = this._hasStickyChanged;\n      this.resetStickyChanged();\n      return hasStickyChanged;\n    }\n    resetStickyChanged() {\n      this._hasStickyChanged = false;\n    }\n    static ɵfac = function CdkHeaderRowDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkHeaderRowDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkHeaderRowDef,\n      selectors: [[\"\", \"cdkHeaderRowDef\", \"\"]],\n      inputs: {\n        columns: [0, \"cdkHeaderRowDef\", \"columns\"],\n        sticky: [2, \"cdkHeaderRowDefSticky\", \"sticky\", booleanAttribute]\n      },\n      features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return CdkHeaderRowDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkFooterRowDef = /*#__PURE__*/(() => {\n  class CdkFooterRowDef extends BaseRowDef {\n    _table = inject(CDK_TABLE, {\n      optional: true\n    });\n    _hasStickyChanged = false;\n    get sticky() {\n      return this._sticky;\n    }\n    set sticky(value) {\n      if (value !== this._sticky) {\n        this._sticky = value;\n        this._hasStickyChanged = true;\n      }\n    }\n    _sticky = false;\n    constructor() {\n      super(inject(TemplateRef), inject(IterableDiffers));\n    }\n    ngOnChanges(changes) {\n      super.ngOnChanges(changes);\n    }\n    hasStickyChanged() {\n      const hasStickyChanged = this._hasStickyChanged;\n      this.resetStickyChanged();\n      return hasStickyChanged;\n    }\n    resetStickyChanged() {\n      this._hasStickyChanged = false;\n    }\n    static ɵfac = function CdkFooterRowDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkFooterRowDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkFooterRowDef,\n      selectors: [[\"\", \"cdkFooterRowDef\", \"\"]],\n      inputs: {\n        columns: [0, \"cdkFooterRowDef\", \"columns\"],\n        sticky: [2, \"cdkFooterRowDefSticky\", \"sticky\", booleanAttribute]\n      },\n      features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return CdkFooterRowDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkRowDef = /*#__PURE__*/(() => {\n  class CdkRowDef extends BaseRowDef {\n    _table = inject(CDK_TABLE, {\n      optional: true\n    });\n    when;\n    constructor() {\n      super(inject(TemplateRef), inject(IterableDiffers));\n    }\n    static ɵfac = function CdkRowDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkRowDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkRowDef,\n      selectors: [[\"\", \"cdkRowDef\", \"\"]],\n      inputs: {\n        columns: [0, \"cdkRowDefColumns\", \"columns\"],\n        when: [0, \"cdkRowDefWhen\", \"when\"]\n      },\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return CdkRowDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkCellOutlet = /*#__PURE__*/(() => {\n  class CdkCellOutlet {\n    _viewContainer = inject(ViewContainerRef);\n    cells;\n    context;\n    static mostRecentCellOutlet = null;\n    constructor() {\n      CdkCellOutlet.mostRecentCellOutlet = this;\n    }\n    ngOnDestroy() {\n      if (CdkCellOutlet.mostRecentCellOutlet === this) {\n        CdkCellOutlet.mostRecentCellOutlet = null;\n      }\n    }\n    static ɵfac = function CdkCellOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkCellOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkCellOutlet,\n      selectors: [[\"\", \"cdkCellOutlet\", \"\"]]\n    });\n  }\n  return CdkCellOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkHeaderRow = /*#__PURE__*/(() => {\n  class CdkHeaderRow {\n    static ɵfac = function CdkHeaderRow_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkHeaderRow)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkHeaderRow,\n      selectors: [[\"cdk-header-row\"], [\"tr\", \"cdk-header-row\", \"\"]],\n      hostAttrs: [\"role\", \"row\", 1, \"cdk-header-row\"],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkCellOutlet\", \"\"]],\n      template: function CdkHeaderRow_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainer(0, 0);\n        }\n      },\n      dependencies: [CdkCellOutlet],\n      encapsulation: 2\n    });\n  }\n  return CdkHeaderRow;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkFooterRow = /*#__PURE__*/(() => {\n  class CdkFooterRow {\n    static ɵfac = function CdkFooterRow_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkFooterRow)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkFooterRow,\n      selectors: [[\"cdk-footer-row\"], [\"tr\", \"cdk-footer-row\", \"\"]],\n      hostAttrs: [\"role\", \"row\", 1, \"cdk-footer-row\"],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkCellOutlet\", \"\"]],\n      template: function CdkFooterRow_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainer(0, 0);\n        }\n      },\n      dependencies: [CdkCellOutlet],\n      encapsulation: 2\n    });\n  }\n  return CdkFooterRow;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkRow = /*#__PURE__*/(() => {\n  class CdkRow {\n    static ɵfac = function CdkRow_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkRow)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkRow,\n      selectors: [[\"cdk-row\"], [\"tr\", \"cdk-row\", \"\"]],\n      hostAttrs: [\"role\", \"row\", 1, \"cdk-row\"],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkCellOutlet\", \"\"]],\n      template: function CdkRow_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainer(0, 0);\n        }\n      },\n      dependencies: [CdkCellOutlet],\n      encapsulation: 2\n    });\n  }\n  return CdkRow;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkNoDataRow = /*#__PURE__*/(() => {\n  class CdkNoDataRow {\n    templateRef = inject(TemplateRef);\n    _contentClassNames = ['cdk-no-data-row', 'cdk-row'];\n    _cellClassNames = ['cdk-cell', 'cdk-no-data-cell'];\n    _cellSelector = 'td, cdk-cell, [cdk-cell], .cdk-cell';\n    constructor() {}\n    static ɵfac = function CdkNoDataRow_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkNoDataRow)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkNoDataRow,\n      selectors: [[\"ng-template\", \"cdkNoDataRow\", \"\"]]\n    });\n  }\n  return CdkNoDataRow;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];\nclass StickyStyler {\n  _isNativeHtmlTable;\n  _stickCellCss;\n  _isBrowser;\n  _needsPositionStickyOnElement;\n  direction;\n  _positionListener;\n  _tableInjector;\n  _elemSizeCache = /*#__PURE__*/new WeakMap();\n  _resizeObserver = globalThis?.ResizeObserver ? /*#__PURE__*/new globalThis.ResizeObserver(entries => this._updateCachedSizes(entries)) : null;\n  _updatedStickyColumnsParamsToReplay = [];\n  _stickyColumnsReplayTimeout = null;\n  _cachedCellWidths = [];\n  _borderCellCss;\n  _destroyed = false;\n  constructor(_isNativeHtmlTable, _stickCellCss, _isBrowser = true, _needsPositionStickyOnElement = true, direction, _positionListener, _tableInjector) {\n    this._isNativeHtmlTable = _isNativeHtmlTable;\n    this._stickCellCss = _stickCellCss;\n    this._isBrowser = _isBrowser;\n    this._needsPositionStickyOnElement = _needsPositionStickyOnElement;\n    this.direction = direction;\n    this._positionListener = _positionListener;\n    this._tableInjector = _tableInjector;\n    this._borderCellCss = {\n      'top': `${_stickCellCss}-border-elem-top`,\n      'bottom': `${_stickCellCss}-border-elem-bottom`,\n      'left': `${_stickCellCss}-border-elem-left`,\n      'right': `${_stickCellCss}-border-elem-right`\n    };\n  }\n  clearStickyPositioning(rows, stickyDirections) {\n    if (stickyDirections.includes('left') || stickyDirections.includes('right')) {\n      this._removeFromStickyColumnReplayQueue(rows);\n    }\n    const elementsToClear = [];\n    for (const row of rows) {\n      if (row.nodeType !== row.ELEMENT_NODE) {\n        continue;\n      }\n      elementsToClear.push(row, ...Array.from(row.children));\n    }\n    afterNextRender({\n      write: () => {\n        for (const element of elementsToClear) {\n          this._removeStickyStyle(element, stickyDirections);\n        }\n      }\n    }, {\n      injector: this._tableInjector\n    });\n  }\n  updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true, replay = true) {\n    if (!rows.length || !this._isBrowser || !(stickyStartStates.some(state => state) || stickyEndStates.some(state => state))) {\n      this._positionListener?.stickyColumnsUpdated({\n        sizes: []\n      });\n      this._positionListener?.stickyEndColumnsUpdated({\n        sizes: []\n      });\n      return;\n    }\n    const firstRow = rows[0];\n    const numCells = firstRow.children.length;\n    const isRtl = this.direction === 'rtl';\n    const start = isRtl ? 'right' : 'left';\n    const end = isRtl ? 'left' : 'right';\n    const lastStickyStart = stickyStartStates.lastIndexOf(true);\n    const firstStickyEnd = stickyEndStates.indexOf(true);\n    let cellWidths;\n    let startPositions;\n    let endPositions;\n    if (replay) {\n      this._updateStickyColumnReplayQueue({\n        rows: [...rows],\n        stickyStartStates: [...stickyStartStates],\n        stickyEndStates: [...stickyEndStates]\n      });\n    }\n    afterNextRender({\n      earlyRead: () => {\n        cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);\n        startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);\n        endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);\n      },\n      write: () => {\n        for (const row of rows) {\n          for (let i = 0; i < numCells; i++) {\n            const cell = row.children[i];\n            if (stickyStartStates[i]) {\n              this._addStickyStyle(cell, start, startPositions[i], i === lastStickyStart);\n            }\n            if (stickyEndStates[i]) {\n              this._addStickyStyle(cell, end, endPositions[i], i === firstStickyEnd);\n            }\n          }\n        }\n        if (this._positionListener && cellWidths.some(w => !!w)) {\n          this._positionListener.stickyColumnsUpdated({\n            sizes: lastStickyStart === -1 ? [] : cellWidths.slice(0, lastStickyStart + 1).map((width, index) => stickyStartStates[index] ? width : null)\n          });\n          this._positionListener.stickyEndColumnsUpdated({\n            sizes: firstStickyEnd === -1 ? [] : cellWidths.slice(firstStickyEnd).map((width, index) => stickyEndStates[index + firstStickyEnd] ? width : null).reverse()\n          });\n        }\n      }\n    }, {\n      injector: this._tableInjector\n    });\n  }\n  stickRows(rowsToStick, stickyStates, position) {\n    if (!this._isBrowser) {\n      return;\n    }\n    const rows = position === 'bottom' ? rowsToStick.slice().reverse() : rowsToStick;\n    const states = position === 'bottom' ? stickyStates.slice().reverse() : stickyStates;\n    const stickyOffsets = [];\n    const stickyCellHeights = [];\n    const elementsToStick = [];\n    afterNextRender({\n      earlyRead: () => {\n        for (let rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {\n          if (!states[rowIndex]) {\n            continue;\n          }\n          stickyOffsets[rowIndex] = stickyOffset;\n          const row = rows[rowIndex];\n          elementsToStick[rowIndex] = this._isNativeHtmlTable ? Array.from(row.children) : [row];\n          const height = this._retrieveElementSize(row).height;\n          stickyOffset += height;\n          stickyCellHeights[rowIndex] = height;\n        }\n      },\n      write: () => {\n        const borderedRowIndex = states.lastIndexOf(true);\n        for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n          if (!states[rowIndex]) {\n            continue;\n          }\n          const offset = stickyOffsets[rowIndex];\n          const isBorderedRowIndex = rowIndex === borderedRowIndex;\n          for (const element of elementsToStick[rowIndex]) {\n            this._addStickyStyle(element, position, offset, isBorderedRowIndex);\n          }\n        }\n        if (position === 'top') {\n          this._positionListener?.stickyHeaderRowsUpdated({\n            sizes: stickyCellHeights,\n            offsets: stickyOffsets,\n            elements: elementsToStick\n          });\n        } else {\n          this._positionListener?.stickyFooterRowsUpdated({\n            sizes: stickyCellHeights,\n            offsets: stickyOffsets,\n            elements: elementsToStick\n          });\n        }\n      }\n    }, {\n      injector: this._tableInjector\n    });\n  }\n  updateStickyFooterContainer(tableElement, stickyStates) {\n    if (!this._isNativeHtmlTable) {\n      return;\n    }\n    afterNextRender({\n      write: () => {\n        const tfoot = tableElement.querySelector('tfoot');\n        if (tfoot) {\n          if (stickyStates.some(state => !state)) {\n            this._removeStickyStyle(tfoot, ['bottom']);\n          } else {\n            this._addStickyStyle(tfoot, 'bottom', 0, false);\n          }\n        }\n      }\n    }, {\n      injector: this._tableInjector\n    });\n  }\n  destroy() {\n    if (this._stickyColumnsReplayTimeout) {\n      clearTimeout(this._stickyColumnsReplayTimeout);\n    }\n    this._resizeObserver?.disconnect();\n    this._destroyed = true;\n  }\n  _removeStickyStyle(element, stickyDirections) {\n    if (!element.classList.contains(this._stickCellCss)) {\n      return;\n    }\n    for (const dir of stickyDirections) {\n      element.style[dir] = '';\n      element.classList.remove(this._borderCellCss[dir]);\n    }\n    const hasDirection = STICKY_DIRECTIONS.some(dir => stickyDirections.indexOf(dir) === -1 && element.style[dir]);\n    if (hasDirection) {\n      element.style.zIndex = this._getCalculatedZIndex(element);\n    } else {\n      element.style.zIndex = '';\n      if (this._needsPositionStickyOnElement) {\n        element.style.position = '';\n      }\n      element.classList.remove(this._stickCellCss);\n    }\n  }\n  _addStickyStyle(element, dir, dirValue, isBorderElement) {\n    element.classList.add(this._stickCellCss);\n    if (isBorderElement) {\n      element.classList.add(this._borderCellCss[dir]);\n    }\n    element.style[dir] = `${dirValue}px`;\n    element.style.zIndex = this._getCalculatedZIndex(element);\n    if (this._needsPositionStickyOnElement) {\n      element.style.cssText += 'position: -webkit-sticky; position: sticky; ';\n    }\n  }\n  _getCalculatedZIndex(element) {\n    const zIndexIncrements = {\n      top: 100,\n      bottom: 10,\n      left: 1,\n      right: 1\n    };\n    let zIndex = 0;\n    for (const dir of STICKY_DIRECTIONS) {\n      if (element.style[dir]) {\n        zIndex += zIndexIncrements[dir];\n      }\n    }\n    return zIndex ? `${zIndex}` : '';\n  }\n  _getCellWidths(row, recalculateCellWidths = true) {\n    if (!recalculateCellWidths && this._cachedCellWidths.length) {\n      return this._cachedCellWidths;\n    }\n    const cellWidths = [];\n    const firstRowCells = row.children;\n    for (let i = 0; i < firstRowCells.length; i++) {\n      const cell = firstRowCells[i];\n      cellWidths.push(this._retrieveElementSize(cell).width);\n    }\n    this._cachedCellWidths = cellWidths;\n    return cellWidths;\n  }\n  _getStickyStartColumnPositions(widths, stickyStates) {\n    const positions = [];\n    let nextPosition = 0;\n    for (let i = 0; i < widths.length; i++) {\n      if (stickyStates[i]) {\n        positions[i] = nextPosition;\n        nextPosition += widths[i];\n      }\n    }\n    return positions;\n  }\n  _getStickyEndColumnPositions(widths, stickyStates) {\n    const positions = [];\n    let nextPosition = 0;\n    for (let i = widths.length; i > 0; i--) {\n      if (stickyStates[i]) {\n        positions[i] = nextPosition;\n        nextPosition += widths[i];\n      }\n    }\n    return positions;\n  }\n  _retrieveElementSize(element) {\n    const cachedSize = this._elemSizeCache.get(element);\n    if (cachedSize) {\n      return cachedSize;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const size = {\n      width: clientRect.width,\n      height: clientRect.height\n    };\n    if (!this._resizeObserver) {\n      return size;\n    }\n    this._elemSizeCache.set(element, size);\n    this._resizeObserver.observe(element, {\n      box: 'border-box'\n    });\n    return size;\n  }\n  _updateStickyColumnReplayQueue(params) {\n    this._removeFromStickyColumnReplayQueue(params.rows);\n    if (!this._stickyColumnsReplayTimeout) {\n      this._updatedStickyColumnsParamsToReplay.push(params);\n    }\n  }\n  _removeFromStickyColumnReplayQueue(rows) {\n    const rowsSet = new Set(rows);\n    for (const update of this._updatedStickyColumnsParamsToReplay) {\n      update.rows = update.rows.filter(row => !rowsSet.has(row));\n    }\n    this._updatedStickyColumnsParamsToReplay = this._updatedStickyColumnsParamsToReplay.filter(update => !!update.rows.length);\n  }\n  _updateCachedSizes(entries) {\n    let needsColumnUpdate = false;\n    for (const entry of entries) {\n      const newEntry = entry.borderBoxSize?.length ? {\n        width: entry.borderBoxSize[0].inlineSize,\n        height: entry.borderBoxSize[0].blockSize\n      } : {\n        width: entry.contentRect.width,\n        height: entry.contentRect.height\n      };\n      if (newEntry.width !== this._elemSizeCache.get(entry.target)?.width && isCell(entry.target)) {\n        needsColumnUpdate = true;\n      }\n      this._elemSizeCache.set(entry.target, newEntry);\n    }\n    if (needsColumnUpdate && this._updatedStickyColumnsParamsToReplay.length) {\n      if (this._stickyColumnsReplayTimeout) {\n        clearTimeout(this._stickyColumnsReplayTimeout);\n      }\n      this._stickyColumnsReplayTimeout = setTimeout(() => {\n        if (this._destroyed) {\n          return;\n        }\n        for (const update of this._updatedStickyColumnsParamsToReplay) {\n          this.updateStickyColumns(update.rows, update.stickyStartStates, update.stickyEndStates, true, false);\n        }\n        this._updatedStickyColumnsParamsToReplay = [];\n        this._stickyColumnsReplayTimeout = null;\n      }, 0);\n    }\n  }\n}\nfunction isCell(element) {\n  return ['cdk-cell', 'cdk-header-cell', 'cdk-footer-cell'].some(klass => element.classList.contains(klass));\n}\nfunction getTableUnknownColumnError(id) {\n  return Error(`Could not find column with id \"${id}\".`);\n}\nfunction getTableDuplicateColumnNameError(name) {\n  return Error(`Duplicate column definition name provided: \"${name}\".`);\n}\nfunction getTableMultipleDefaultRowDefsError() {\n  return Error(`There can only be one default row without a when predicate function. ` + 'Or set `multiTemplateDataRows`.');\n}\nfunction getTableMissingMatchingRowDefError(data) {\n  return Error(`Could not find a matching row definition for the ` + `provided row data: ${JSON.stringify(data)}`);\n}\nfunction getTableMissingRowDefsError() {\n  return Error('Missing definitions for header, footer, and row; ' + 'cannot determine which columns should be rendered.');\n}\nfunction getTableUnknownDataSourceError() {\n  return Error(`Provided data source did not match an array, Observable, or DataSource`);\n}\nfunction getTableTextColumnMissingParentTableError() {\n  return Error(`Text column could not find a parent table for registration.`);\n}\nfunction getTableTextColumnMissingNameError() {\n  return Error(`Table text column must have a name.`);\n}\nconst STICKY_POSITIONING_LISTENER = /*#__PURE__*/new InjectionToken('CDK_SPL');\nlet CdkRecycleRows = /*#__PURE__*/(() => {\n  class CdkRecycleRows {\n    static ɵfac = function CdkRecycleRows_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkRecycleRows)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkRecycleRows,\n      selectors: [[\"cdk-table\", \"recycleRows\", \"\"], [\"table\", \"cdk-table\", \"\", \"recycleRows\", \"\"]],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: _VIEW_REPEATER_STRATEGY,\n        useClass: _RecycleViewRepeaterStrategy\n      }])]\n    });\n  }\n  return CdkRecycleRows;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DataRowOutlet = /*#__PURE__*/(() => {\n  class DataRowOutlet {\n    viewContainer = inject(ViewContainerRef);\n    elementRef = inject(ElementRef);\n    constructor() {\n      const table = inject(CDK_TABLE);\n      table._rowOutlet = this;\n      table._outletAssigned();\n    }\n    static ɵfac = function DataRowOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DataRowOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: DataRowOutlet,\n      selectors: [[\"\", \"rowOutlet\", \"\"]]\n    });\n  }\n  return DataRowOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HeaderRowOutlet = /*#__PURE__*/(() => {\n  class HeaderRowOutlet {\n    viewContainer = inject(ViewContainerRef);\n    elementRef = inject(ElementRef);\n    constructor() {\n      const table = inject(CDK_TABLE);\n      table._headerRowOutlet = this;\n      table._outletAssigned();\n    }\n    static ɵfac = function HeaderRowOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HeaderRowOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: HeaderRowOutlet,\n      selectors: [[\"\", \"headerRowOutlet\", \"\"]]\n    });\n  }\n  return HeaderRowOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FooterRowOutlet = /*#__PURE__*/(() => {\n  class FooterRowOutlet {\n    viewContainer = inject(ViewContainerRef);\n    elementRef = inject(ElementRef);\n    constructor() {\n      const table = inject(CDK_TABLE);\n      table._footerRowOutlet = this;\n      table._outletAssigned();\n    }\n    static ɵfac = function FooterRowOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FooterRowOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: FooterRowOutlet,\n      selectors: [[\"\", \"footerRowOutlet\", \"\"]]\n    });\n  }\n  return FooterRowOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NoDataRowOutlet = /*#__PURE__*/(() => {\n  class NoDataRowOutlet {\n    viewContainer = inject(ViewContainerRef);\n    elementRef = inject(ElementRef);\n    constructor() {\n      const table = inject(CDK_TABLE);\n      table._noDataRowOutlet = this;\n      table._outletAssigned();\n    }\n    static ɵfac = function NoDataRowOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NoDataRowOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NoDataRowOutlet,\n      selectors: [[\"\", \"noDataRowOutlet\", \"\"]]\n    });\n  }\n  return NoDataRowOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkTable = /*#__PURE__*/(() => {\n  class CdkTable {\n    _differs = inject(IterableDiffers);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _platform = inject(Platform);\n    _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);\n    _viewportRuler = inject(ViewportRuler);\n    _stickyPositioningListener = inject(STICKY_POSITIONING_LISTENER, {\n      optional: true,\n      skipSelf: true\n    });\n    _document = inject(DOCUMENT);\n    _data;\n    _onDestroy = new Subject();\n    _renderRows;\n    _renderChangeSubscription;\n    _columnDefsByName = new Map();\n    _rowDefs;\n    _headerRowDefs;\n    _footerRowDefs;\n    _dataDiffer;\n    _defaultRowDef;\n    _customColumnDefs = new Set();\n    _customRowDefs = new Set();\n    _customHeaderRowDefs = new Set();\n    _customFooterRowDefs = new Set();\n    _customNoDataRow;\n    _headerRowDefChanged = true;\n    _footerRowDefChanged = true;\n    _stickyColumnStylesNeedReset = true;\n    _forceRecalculateCellWidths = true;\n    _cachedRenderRowsMap = new Map();\n    _isNativeHtmlTable;\n    _stickyStyler;\n    stickyCssClass = 'cdk-table-sticky';\n    needsPositionStickyOnElement = true;\n    _isServer;\n    _isShowingNoDataRow = false;\n    _hasAllOutlets = false;\n    _hasInitialized = false;\n    _getCellRole() {\n      if (this._cellRoleInternal === undefined) {\n        const tableRole = this._elementRef.nativeElement.getAttribute('role');\n        return tableRole === 'grid' || tableRole === 'treegrid' ? 'gridcell' : 'cell';\n      }\n      return this._cellRoleInternal;\n    }\n    _cellRoleInternal = undefined;\n    get trackBy() {\n      return this._trackByFn;\n    }\n    set trackBy(fn) {\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null && typeof fn !== 'function') {\n        console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this._trackByFn = fn;\n    }\n    _trackByFn;\n    get dataSource() {\n      return this._dataSource;\n    }\n    set dataSource(dataSource) {\n      if (this._dataSource !== dataSource) {\n        this._switchDataSource(dataSource);\n      }\n    }\n    _dataSource;\n    get multiTemplateDataRows() {\n      return this._multiTemplateDataRows;\n    }\n    set multiTemplateDataRows(value) {\n      this._multiTemplateDataRows = value;\n      if (this._rowOutlet && this._rowOutlet.viewContainer.length) {\n        this._forceRenderDataRows();\n        this.updateStickyColumnStyles();\n      }\n    }\n    _multiTemplateDataRows = false;\n    get fixedLayout() {\n      return this._fixedLayout;\n    }\n    set fixedLayout(value) {\n      this._fixedLayout = value;\n      this._forceRecalculateCellWidths = true;\n      this._stickyColumnStylesNeedReset = true;\n    }\n    _fixedLayout = false;\n    contentChanged = new EventEmitter();\n    viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n    _rowOutlet;\n    _headerRowOutlet;\n    _footerRowOutlet;\n    _noDataRowOutlet;\n    _contentColumnDefs;\n    _contentRowDefs;\n    _contentHeaderRowDefs;\n    _contentFooterRowDefs;\n    _noDataRow;\n    _injector = inject(Injector);\n    constructor() {\n      const role = inject(new HostAttributeToken('role'), {\n        optional: true\n      });\n      if (!role) {\n        this._elementRef.nativeElement.setAttribute('role', 'table');\n      }\n      this._isServer = !this._platform.isBrowser;\n      this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';\n      this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {\n        return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;\n      });\n    }\n    ngOnInit() {\n      this._setupStickyStyler();\n      this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {\n        this._forceRecalculateCellWidths = true;\n      });\n    }\n    ngAfterContentInit() {\n      this._hasInitialized = true;\n    }\n    ngAfterContentChecked() {\n      if (this._canRender()) {\n        this._render();\n      }\n    }\n    ngOnDestroy() {\n      this._stickyStyler?.destroy();\n      [this._rowOutlet?.viewContainer, this._headerRowOutlet?.viewContainer, this._footerRowOutlet?.viewContainer, this._cachedRenderRowsMap, this._customColumnDefs, this._customRowDefs, this._customHeaderRowDefs, this._customFooterRowDefs, this._columnDefsByName].forEach(def => {\n        def?.clear();\n      });\n      this._headerRowDefs = [];\n      this._footerRowDefs = [];\n      this._defaultRowDef = null;\n      this._onDestroy.next();\n      this._onDestroy.complete();\n      if (isDataSource(this.dataSource)) {\n        this.dataSource.disconnect(this);\n      }\n    }\n    renderRows() {\n      this._renderRows = this._getAllRenderRows();\n      const changes = this._dataDiffer.diff(this._renderRows);\n      if (!changes) {\n        this._updateNoDataRow();\n        this.contentChanged.next();\n        return;\n      }\n      const viewContainer = this._rowOutlet.viewContainer;\n      this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), record => record.item.data, change => {\n        if (change.operation === _ViewRepeaterOperation.INSERTED && change.context) {\n          this._renderCellTemplateForItem(change.record.item.rowDef, change.context);\n        }\n      });\n      this._updateRowIndexContext();\n      changes.forEachIdentityChange(record => {\n        const rowView = viewContainer.get(record.currentIndex);\n        rowView.context.$implicit = record.item.data;\n      });\n      this._updateNoDataRow();\n      this.contentChanged.next();\n      this.updateStickyColumnStyles();\n    }\n    addColumnDef(columnDef) {\n      this._customColumnDefs.add(columnDef);\n    }\n    removeColumnDef(columnDef) {\n      this._customColumnDefs.delete(columnDef);\n    }\n    addRowDef(rowDef) {\n      this._customRowDefs.add(rowDef);\n    }\n    removeRowDef(rowDef) {\n      this._customRowDefs.delete(rowDef);\n    }\n    addHeaderRowDef(headerRowDef) {\n      this._customHeaderRowDefs.add(headerRowDef);\n      this._headerRowDefChanged = true;\n    }\n    removeHeaderRowDef(headerRowDef) {\n      this._customHeaderRowDefs.delete(headerRowDef);\n      this._headerRowDefChanged = true;\n    }\n    addFooterRowDef(footerRowDef) {\n      this._customFooterRowDefs.add(footerRowDef);\n      this._footerRowDefChanged = true;\n    }\n    removeFooterRowDef(footerRowDef) {\n      this._customFooterRowDefs.delete(footerRowDef);\n      this._footerRowDefChanged = true;\n    }\n    setNoDataRow(noDataRow) {\n      this._customNoDataRow = noDataRow;\n    }\n    updateStickyHeaderRowStyles() {\n      const headerRows = this._getRenderedRows(this._headerRowOutlet);\n      if (this._isNativeHtmlTable) {\n        const thead = closestTableSection(this._headerRowOutlet, 'thead');\n        if (thead) {\n          thead.style.display = headerRows.length ? '' : 'none';\n        }\n      }\n      const stickyStates = this._headerRowDefs.map(def => def.sticky);\n      this._stickyStyler.clearStickyPositioning(headerRows, ['top']);\n      this._stickyStyler.stickRows(headerRows, stickyStates, 'top');\n      this._headerRowDefs.forEach(def => def.resetStickyChanged());\n    }\n    updateStickyFooterRowStyles() {\n      const footerRows = this._getRenderedRows(this._footerRowOutlet);\n      if (this._isNativeHtmlTable) {\n        const tfoot = closestTableSection(this._footerRowOutlet, 'tfoot');\n        if (tfoot) {\n          tfoot.style.display = footerRows.length ? '' : 'none';\n        }\n      }\n      const stickyStates = this._footerRowDefs.map(def => def.sticky);\n      this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);\n      this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');\n      this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);\n      this._footerRowDefs.forEach(def => def.resetStickyChanged());\n    }\n    updateStickyColumnStyles() {\n      const headerRows = this._getRenderedRows(this._headerRowOutlet);\n      const dataRows = this._getRenderedRows(this._rowOutlet);\n      const footerRows = this._getRenderedRows(this._footerRowOutlet);\n      if (this._isNativeHtmlTable && !this._fixedLayout || this._stickyColumnStylesNeedReset) {\n        this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ['left', 'right']);\n        this._stickyColumnStylesNeedReset = false;\n      }\n      headerRows.forEach((headerRow, i) => {\n        this._addStickyColumnStyles([headerRow], this._headerRowDefs[i]);\n      });\n      this._rowDefs.forEach(rowDef => {\n        const rows = [];\n        for (let i = 0; i < dataRows.length; i++) {\n          if (this._renderRows[i].rowDef === rowDef) {\n            rows.push(dataRows[i]);\n          }\n        }\n        this._addStickyColumnStyles(rows, rowDef);\n      });\n      footerRows.forEach((footerRow, i) => {\n        this._addStickyColumnStyles([footerRow], this._footerRowDefs[i]);\n      });\n      Array.from(this._columnDefsByName.values()).forEach(def => def.resetStickyChanged());\n    }\n    _outletAssigned() {\n      if (!this._hasAllOutlets && this._rowOutlet && this._headerRowOutlet && this._footerRowOutlet && this._noDataRowOutlet) {\n        this._hasAllOutlets = true;\n        if (this._canRender()) {\n          this._render();\n        }\n      }\n    }\n    _canRender() {\n      return this._hasAllOutlets && this._hasInitialized;\n    }\n    _render() {\n      this._cacheRowDefs();\n      this._cacheColumnDefs();\n      if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTableMissingRowDefsError();\n      }\n      const columnsChanged = this._renderUpdatedColumns();\n      const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;\n      this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;\n      this._forceRecalculateCellWidths = rowDefsChanged;\n      if (this._headerRowDefChanged) {\n        this._forceRenderHeaderRows();\n        this._headerRowDefChanged = false;\n      }\n      if (this._footerRowDefChanged) {\n        this._forceRenderFooterRows();\n        this._footerRowDefChanged = false;\n      }\n      if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {\n        this._observeRenderChanges();\n      } else if (this._stickyColumnStylesNeedReset) {\n        this.updateStickyColumnStyles();\n      }\n      this._checkStickyStates();\n    }\n    _getAllRenderRows() {\n      const renderRows = [];\n      const prevCachedRenderRows = this._cachedRenderRowsMap;\n      this._cachedRenderRowsMap = new Map();\n      if (!this._data) {\n        return renderRows;\n      }\n      for (let i = 0; i < this._data.length; i++) {\n        let data = this._data[i];\n        const renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));\n        if (!this._cachedRenderRowsMap.has(data)) {\n          this._cachedRenderRowsMap.set(data, new WeakMap());\n        }\n        for (let j = 0; j < renderRowsForData.length; j++) {\n          let renderRow = renderRowsForData[j];\n          const cache = this._cachedRenderRowsMap.get(renderRow.data);\n          if (cache.has(renderRow.rowDef)) {\n            cache.get(renderRow.rowDef).push(renderRow);\n          } else {\n            cache.set(renderRow.rowDef, [renderRow]);\n          }\n          renderRows.push(renderRow);\n        }\n      }\n      return renderRows;\n    }\n    _getRenderRowsForData(data, dataIndex, cache) {\n      const rowDefs = this._getRowDefs(data, dataIndex);\n      return rowDefs.map(rowDef => {\n        const cachedRenderRows = cache && cache.has(rowDef) ? cache.get(rowDef) : [];\n        if (cachedRenderRows.length) {\n          const dataRow = cachedRenderRows.shift();\n          dataRow.dataIndex = dataIndex;\n          return dataRow;\n        } else {\n          return {\n            data,\n            rowDef,\n            dataIndex\n          };\n        }\n      });\n    }\n    _cacheColumnDefs() {\n      this._columnDefsByName.clear();\n      const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);\n      columnDefs.forEach(columnDef => {\n        if (this._columnDefsByName.has(columnDef.name) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw getTableDuplicateColumnNameError(columnDef.name);\n        }\n        this._columnDefsByName.set(columnDef.name, columnDef);\n      });\n    }\n    _cacheRowDefs() {\n      this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);\n      this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);\n      this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);\n      const defaultRowDefs = this._rowDefs.filter(def => !def.when);\n      if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTableMultipleDefaultRowDefsError();\n      }\n      this._defaultRowDef = defaultRowDefs[0];\n    }\n    _renderUpdatedColumns() {\n      const columnsDiffReducer = (acc, def) => {\n        const diff = !!def.getColumnsDiff();\n        return acc || diff;\n      };\n      const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);\n      if (dataColumnsChanged) {\n        this._forceRenderDataRows();\n      }\n      const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);\n      if (headerColumnsChanged) {\n        this._forceRenderHeaderRows();\n      }\n      const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);\n      if (footerColumnsChanged) {\n        this._forceRenderFooterRows();\n      }\n      return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;\n    }\n    _switchDataSource(dataSource) {\n      this._data = [];\n      if (isDataSource(this.dataSource)) {\n        this.dataSource.disconnect(this);\n      }\n      if (this._renderChangeSubscription) {\n        this._renderChangeSubscription.unsubscribe();\n        this._renderChangeSubscription = null;\n      }\n      if (!dataSource) {\n        if (this._dataDiffer) {\n          this._dataDiffer.diff([]);\n        }\n        if (this._rowOutlet) {\n          this._rowOutlet.viewContainer.clear();\n        }\n      }\n      this._dataSource = dataSource;\n    }\n    _observeRenderChanges() {\n      if (!this.dataSource) {\n        return;\n      }\n      let dataStream;\n      if (isDataSource(this.dataSource)) {\n        dataStream = this.dataSource.connect(this);\n      } else if (isObservable(this.dataSource)) {\n        dataStream = this.dataSource;\n      } else if (Array.isArray(this.dataSource)) {\n        dataStream = of(this.dataSource);\n      }\n      if (dataStream === undefined && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTableUnknownDataSourceError();\n      }\n      this._renderChangeSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe(data => {\n        this._data = data || [];\n        this.renderRows();\n      });\n    }\n    _forceRenderHeaderRows() {\n      if (this._headerRowOutlet.viewContainer.length > 0) {\n        this._headerRowOutlet.viewContainer.clear();\n      }\n      this._headerRowDefs.forEach((def, i) => this._renderRow(this._headerRowOutlet, def, i));\n      this.updateStickyHeaderRowStyles();\n    }\n    _forceRenderFooterRows() {\n      if (this._footerRowOutlet.viewContainer.length > 0) {\n        this._footerRowOutlet.viewContainer.clear();\n      }\n      this._footerRowDefs.forEach((def, i) => this._renderRow(this._footerRowOutlet, def, i));\n      this.updateStickyFooterRowStyles();\n    }\n    _addStickyColumnStyles(rows, rowDef) {\n      const columnDefs = Array.from(rowDef?.columns || []).map(columnName => {\n        const columnDef = this._columnDefsByName.get(columnName);\n        if (!columnDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw getTableUnknownColumnError(columnName);\n        }\n        return columnDef;\n      });\n      const stickyStartStates = columnDefs.map(columnDef => columnDef.sticky);\n      const stickyEndStates = columnDefs.map(columnDef => columnDef.stickyEnd);\n      this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);\n    }\n    _getRenderedRows(rowOutlet) {\n      const renderedRows = [];\n      for (let i = 0; i < rowOutlet.viewContainer.length; i++) {\n        const viewRef = rowOutlet.viewContainer.get(i);\n        renderedRows.push(viewRef.rootNodes[0]);\n      }\n      return renderedRows;\n    }\n    _getRowDefs(data, dataIndex) {\n      if (this._rowDefs.length == 1) {\n        return [this._rowDefs[0]];\n      }\n      let rowDefs = [];\n      if (this.multiTemplateDataRows) {\n        rowDefs = this._rowDefs.filter(def => !def.when || def.when(dataIndex, data));\n      } else {\n        let rowDef = this._rowDefs.find(def => def.when && def.when(dataIndex, data)) || this._defaultRowDef;\n        if (rowDef) {\n          rowDefs.push(rowDef);\n        }\n      }\n      if (!rowDefs.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTableMissingMatchingRowDefError(data);\n      }\n      return rowDefs;\n    }\n    _getEmbeddedViewArgs(renderRow, index) {\n      const rowDef = renderRow.rowDef;\n      const context = {\n        $implicit: renderRow.data\n      };\n      return {\n        templateRef: rowDef.template,\n        context,\n        index\n      };\n    }\n    _renderRow(outlet, rowDef, index, context = {}) {\n      const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);\n      this._renderCellTemplateForItem(rowDef, context);\n      return view;\n    }\n    _renderCellTemplateForItem(rowDef, context) {\n      for (let cellTemplate of this._getCellTemplates(rowDef)) {\n        if (CdkCellOutlet.mostRecentCellOutlet) {\n          CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);\n        }\n      }\n      this._changeDetectorRef.markForCheck();\n    }\n    _updateRowIndexContext() {\n      const viewContainer = this._rowOutlet.viewContainer;\n      for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\n        const viewRef = viewContainer.get(renderIndex);\n        const context = viewRef.context;\n        context.count = count;\n        context.first = renderIndex === 0;\n        context.last = renderIndex === count - 1;\n        context.even = renderIndex % 2 === 0;\n        context.odd = !context.even;\n        if (this.multiTemplateDataRows) {\n          context.dataIndex = this._renderRows[renderIndex].dataIndex;\n          context.renderIndex = renderIndex;\n        } else {\n          context.index = this._renderRows[renderIndex].dataIndex;\n        }\n      }\n    }\n    _getCellTemplates(rowDef) {\n      if (!rowDef || !rowDef.columns) {\n        return [];\n      }\n      return Array.from(rowDef.columns, columnId => {\n        const column = this._columnDefsByName.get(columnId);\n        if (!column && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw getTableUnknownColumnError(columnId);\n        }\n        return rowDef.extractCellTemplate(column);\n      });\n    }\n    _forceRenderDataRows() {\n      this._dataDiffer.diff([]);\n      this._rowOutlet.viewContainer.clear();\n      this.renderRows();\n    }\n    _checkStickyStates() {\n      const stickyCheckReducer = (acc, d) => {\n        return acc || d.hasStickyChanged();\n      };\n      if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {\n        this.updateStickyHeaderRowStyles();\n      }\n      if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {\n        this.updateStickyFooterRowStyles();\n      }\n      if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {\n        this._stickyColumnStylesNeedReset = true;\n        this.updateStickyColumnStyles();\n      }\n    }\n    _setupStickyStyler() {\n      const direction = this._dir ? this._dir.value : 'ltr';\n      this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, this._platform.isBrowser, this.needsPositionStickyOnElement, direction, this._stickyPositioningListener, this._injector);\n      (this._dir ? this._dir.change : of()).pipe(takeUntil(this._onDestroy)).subscribe(value => {\n        this._stickyStyler.direction = value;\n        this.updateStickyColumnStyles();\n      });\n    }\n    _getOwnDefs(items) {\n      return items.filter(item => !item._table || item._table === this);\n    }\n    _updateNoDataRow() {\n      const noDataRow = this._customNoDataRow || this._noDataRow;\n      if (!noDataRow) {\n        return;\n      }\n      const shouldShow = this._rowOutlet.viewContainer.length === 0;\n      if (shouldShow === this._isShowingNoDataRow) {\n        return;\n      }\n      const container = this._noDataRowOutlet.viewContainer;\n      if (shouldShow) {\n        const view = container.createEmbeddedView(noDataRow.templateRef);\n        const rootNode = view.rootNodes[0];\n        if (view.rootNodes.length === 1 && rootNode?.nodeType === this._document.ELEMENT_NODE) {\n          rootNode.setAttribute('role', 'row');\n          rootNode.classList.add(...noDataRow._contentClassNames);\n          const cells = rootNode.querySelectorAll(noDataRow._cellSelector);\n          for (let i = 0; i < cells.length; i++) {\n            cells[i].classList.add(...noDataRow._cellClassNames);\n          }\n        }\n      } else {\n        container.clear();\n      }\n      this._isShowingNoDataRow = shouldShow;\n      this._changeDetectorRef.markForCheck();\n    }\n    static ɵfac = function CdkTable_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTable)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkTable,\n      selectors: [[\"cdk-table\"], [\"table\", \"cdk-table\", \"\"]],\n      contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkNoDataRow, 5)(dirIndex, CdkColumnDef, 5)(dirIndex, CdkRowDef, 5)(dirIndex, CdkHeaderRowDef, 5)(dirIndex, CdkFooterRowDef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._noDataRow = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._contentColumnDefs = _t);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._contentRowDefs = _t);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._contentHeaderRowDefs = _t);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._contentFooterRowDefs = _t);\n        }\n      },\n      hostAttrs: [1, \"cdk-table\"],\n      hostVars: 2,\n      hostBindings: function CdkTable_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"cdk-table-fixed-layout\", ctx.fixedLayout);\n        }\n      },\n      inputs: {\n        trackBy: \"trackBy\",\n        dataSource: \"dataSource\",\n        multiTemplateDataRows: [2, \"multiTemplateDataRows\", \"multiTemplateDataRows\", booleanAttribute],\n        fixedLayout: [2, \"fixedLayout\", \"fixedLayout\", booleanAttribute]\n      },\n      outputs: {\n        contentChanged: \"contentChanged\"\n      },\n      exportAs: [\"cdkTable\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CDK_TABLE,\n        useExisting: CdkTable\n      }, {\n        provide: _VIEW_REPEATER_STRATEGY,\n        useClass: _DisposeViewRepeaterStrategy\n      }, {\n        provide: STICKY_POSITIONING_LISTENER,\n        useValue: null\n      }])],\n      ngContentSelectors: _c1,\n      decls: 5,\n      vars: 2,\n      consts: [[\"role\", \"rowgroup\"], [\"headerRowOutlet\", \"\"], [\"rowOutlet\", \"\"], [\"noDataRowOutlet\", \"\"], [\"footerRowOutlet\", \"\"]],\n      template: function CdkTable_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c0);\n          i0.ɵɵprojection(0);\n          i0.ɵɵprojection(1, 1);\n          i0.ɵɵconditionalCreate(2, CdkTable_Conditional_2_Template, 1, 0);\n          i0.ɵɵconditionalCreate(3, CdkTable_Conditional_3_Template, 7, 0)(4, CdkTable_Conditional_4_Template, 4, 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(2);\n          i0.ɵɵconditional(ctx._isServer ? 2 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(ctx._isNativeHtmlTable ? 3 : 4);\n        }\n      },\n      dependencies: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],\n      styles: [\".cdk-table-fixed-layout{table-layout:fixed}\\n\"],\n      encapsulation: 2\n    });\n  }\n  return CdkTable;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction mergeArrayAndSet(array, set) {\n  return array.concat(Array.from(set));\n}\nfunction closestTableSection(outlet, section) {\n  const uppercaseSection = section.toUpperCase();\n  let current = outlet.viewContainer.element.nativeElement;\n  while (current) {\n    const nodeName = current.nodeType === 1 ? current.nodeName : null;\n    if (nodeName === uppercaseSection) {\n      return current;\n    } else if (nodeName === 'TABLE') {\n      break;\n    }\n    current = current.parentNode;\n  }\n  return null;\n}\nlet CdkTextColumn = /*#__PURE__*/(() => {\n  class CdkTextColumn {\n    _table = inject(CdkTable, {\n      optional: true\n    });\n    _options = inject(TEXT_COLUMN_OPTIONS, {\n      optional: true\n    });\n    get name() {\n      return this._name;\n    }\n    set name(name) {\n      this._name = name;\n      this._syncColumnDefName();\n    }\n    _name;\n    headerText;\n    dataAccessor;\n    justify = 'start';\n    columnDef;\n    cell;\n    headerCell;\n    constructor() {\n      this._options = this._options || {};\n    }\n    ngOnInit() {\n      this._syncColumnDefName();\n      if (this.headerText === undefined) {\n        this.headerText = this._createDefaultHeaderText();\n      }\n      if (!this.dataAccessor) {\n        this.dataAccessor = this._options.defaultDataAccessor || ((data, name) => data[name]);\n      }\n      if (this._table) {\n        this.columnDef.cell = this.cell;\n        this.columnDef.headerCell = this.headerCell;\n        this._table.addColumnDef(this.columnDef);\n      } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        throw getTableTextColumnMissingParentTableError();\n      }\n    }\n    ngOnDestroy() {\n      if (this._table) {\n        this._table.removeColumnDef(this.columnDef);\n      }\n    }\n    _createDefaultHeaderText() {\n      const name = this.name;\n      if (!name && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTableTextColumnMissingNameError();\n      }\n      if (this._options && this._options.defaultHeaderTextTransform) {\n        return this._options.defaultHeaderTextTransform(name);\n      }\n      return name[0].toUpperCase() + name.slice(1);\n    }\n    _syncColumnDefName() {\n      if (this.columnDef) {\n        this.columnDef.name = this.name;\n      }\n    }\n    static ɵfac = function CdkTextColumn_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTextColumn)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkTextColumn,\n      selectors: [[\"cdk-text-column\"]],\n      viewQuery: function CdkTextColumn_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(CdkColumnDef, 7)(CdkCellDef, 7)(CdkHeaderCellDef, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnDef = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cell = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);\n        }\n      },\n      inputs: {\n        name: \"name\",\n        headerText: \"headerText\",\n        dataAccessor: \"dataAccessor\",\n        justify: \"justify\"\n      },\n      decls: 3,\n      vars: 0,\n      consts: [[\"cdkColumnDef\", \"\"], [\"cdk-header-cell\", \"\", 3, \"text-align\", 4, \"cdkHeaderCellDef\"], [\"cdk-cell\", \"\", 3, \"text-align\", 4, \"cdkCellDef\"], [\"cdk-header-cell\", \"\"], [\"cdk-cell\", \"\"]],\n      template: function CdkTextColumn_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainerStart(0, 0);\n          i0.ɵɵtemplate(1, CdkTextColumn_th_1_Template, 2, 3, \"th\", 1)(2, CdkTextColumn_td_2_Template, 2, 3, \"td\", 2);\n          i0.ɵɵelementContainerEnd();\n        }\n      },\n      dependencies: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell],\n      encapsulation: 2\n    });\n  }\n  return CdkTextColumn;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EXPORTED_DECLARATIONS = [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet];\nlet CdkTableModule = /*#__PURE__*/(() => {\n  class CdkTableModule {\n    static ɵfac = function CdkTableModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTableModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CdkTableModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [ScrollingModule]\n    });\n  }\n  return CdkTableModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { BaseCdkCell, BaseRowDef, CDK_ROW_TEMPLATE, CDK_TABLE, CdkCell, CdkCellDef, CdkCellOutlet, CdkColumnDef, CdkFooterCell, CdkFooterCellDef, CdkFooterRow, CdkFooterRowDef, CdkHeaderCell, CdkHeaderCellDef, CdkHeaderRow, CdkHeaderRowDef, CdkNoDataRow, CdkRecycleRows, CdkRow, CdkRowDef, CdkTable, CdkTableModule, CdkTextColumn, DataRowOutlet, FooterRowOutlet, HeaderRowOutlet, NoDataRowOutlet, STICKY_POSITIONING_LISTENER, TEXT_COLUMN_OPTIONS };\n//# sourceMappingURL=table.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}