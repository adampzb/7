{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, DOCUMENT, ChangeDetectorRef, booleanAttribute, Component, ChangeDetectionStrategy, ViewEncapsulation, Input, TemplateRef, ApplicationRef, Injector, ViewContainerRef, Directive, QueryList, signal, EventEmitter, afterNextRender, ContentChildren, ViewChild, ContentChild, Output, NgZone, Renderer2, NgModule } from '@angular/core';\nimport { FocusMonitor, _IdGenerator, FocusKeyManager, isFakeTouchstartFromScreenReader, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, ESCAPE, hasModifierKey, ENTER, SPACE } from '@angular/cdk/keycodes';\nimport { Subject, merge, Subscription, of } from 'rxjs';\nimport { startWith, switchMap, takeUntil, take, filter, skipWhile } from 'rxjs/operators';\nimport { _CdkPrivateStyleLoader } from '@angular/cdk/private';\nimport { _StructuralStylesLoader } from './_structural-styles-chunk.mjs';\nimport { MatRipple } from './_ripple-chunk.mjs';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { _animationsDisabled } from './_animation-chunk.mjs';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { createRepositionScrollStrategy, createOverlayRef, OverlayConfig, createFlexibleConnectedPositionStrategy, ViewportRuler, ScrollDispatcher, OverlayModule } from '@angular/cdk/overlay';\nimport { _getEventTarget, _getShadowRoot } from '@angular/cdk/platform';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport { MatRippleModule } from './_ripple-module-chunk.mjs';\nimport '@angular/cdk/coercion';\nimport '@angular/cdk/layout';\nconst _c0 = [\"mat-menu-item\", \"\"];\nconst _c1 = [[[\"mat-icon\"], [\"\", \"matMenuItemIcon\", \"\"]], \"*\"];\nconst _c2 = [\"mat-icon, [matMenuItemIcon]\", \"*\"];\nfunction MatMenuItem_Conditional_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"svg\", 2);\n    i0.ɵɵelement(1, \"polygon\", 3);\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c3 = [\"*\"];\nfunction MatMenu_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵdomElementStart(0, \"div\", 0);\n    i0.ɵɵdomListener(\"click\", function MatMenu_ng_template_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.closed.emit(\"click\"));\n    })(\"animationstart\", function MatMenu_ng_template_0_Template_div_animationstart_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._onAnimationStart($event.animationName));\n    })(\"animationend\", function MatMenu_ng_template_0_Template_div_animationend_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._onAnimationDone($event.animationName));\n    })(\"animationcancel\", function MatMenu_ng_template_0_Template_div_animationcancel_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._onAnimationDone($event.animationName));\n    });\n    i0.ɵɵdomElementStart(1, \"div\", 1);\n    i0.ɵɵprojection(2);\n    i0.ɵɵdomElementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r1._classList);\n    i0.ɵɵclassProp(\"mat-menu-panel-animations-disabled\", ctx_r1._animationsDisabled)(\"mat-menu-panel-exit-animation\", ctx_r1._panelAnimationState === \"void\")(\"mat-menu-panel-animating\", ctx_r1._isAnimating());\n    i0.ɵɵdomProperty(\"id\", ctx_r1.panelId);\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.ariaLabel || null)(\"aria-labelledby\", ctx_r1.ariaLabelledby || null)(\"aria-describedby\", ctx_r1.ariaDescribedby || null);\n  }\n}\nconst MAT_MENU_PANEL = /*#__PURE__*/new InjectionToken('MAT_MENU_PANEL');\nlet MatMenuItem = /*#__PURE__*/(() => {\n  class MatMenuItem {\n    _elementRef = inject(ElementRef);\n    _document = inject(DOCUMENT);\n    _focusMonitor = inject(FocusMonitor);\n    _parentMenu = inject(MAT_MENU_PANEL, {\n      optional: true\n    });\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    role = 'menuitem';\n    disabled = false;\n    disableRipple = false;\n    _hovered = new Subject();\n    _focused = new Subject();\n    _highlighted = false;\n    _triggersSubmenu = false;\n    constructor() {\n      inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n      this._parentMenu?.addItem?.(this);\n    }\n    focus(origin, options) {\n      if (this._focusMonitor && origin) {\n        this._focusMonitor.focusVia(this._getHostElement(), origin, options);\n      } else {\n        this._getHostElement().focus(options);\n      }\n      this._focused.next(this);\n    }\n    ngAfterViewInit() {\n      if (this._focusMonitor) {\n        this._focusMonitor.monitor(this._elementRef, false);\n      }\n    }\n    ngOnDestroy() {\n      if (this._focusMonitor) {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n      }\n      if (this._parentMenu && this._parentMenu.removeItem) {\n        this._parentMenu.removeItem(this);\n      }\n      this._hovered.complete();\n      this._focused.complete();\n    }\n    _getTabIndex() {\n      return this.disabled ? '-1' : '0';\n    }\n    _getHostElement() {\n      return this._elementRef.nativeElement;\n    }\n    _checkDisabled(event) {\n      if (this.disabled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n    _handleMouseEnter() {\n      this._hovered.next(this);\n    }\n    getLabel() {\n      const clone = this._elementRef.nativeElement.cloneNode(true);\n      const icons = clone.querySelectorAll('mat-icon, .material-icons');\n      for (let i = 0; i < icons.length; i++) {\n        icons[i].remove();\n      }\n      return clone.textContent?.trim() || '';\n    }\n    _setHighlighted(isHighlighted) {\n      this._highlighted = isHighlighted;\n      this._changeDetectorRef.markForCheck();\n    }\n    _setTriggersSubmenu(triggersSubmenu) {\n      this._triggersSubmenu = triggersSubmenu;\n      this._changeDetectorRef.markForCheck();\n    }\n    _hasFocus() {\n      return this._document && this._document.activeElement === this._getHostElement();\n    }\n    static ɵfac = function MatMenuItem_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenuItem)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatMenuItem,\n      selectors: [[\"\", \"mat-menu-item\", \"\"]],\n      hostAttrs: [1, \"mat-mdc-menu-item\", \"mat-focus-indicator\"],\n      hostVars: 8,\n      hostBindings: function MatMenuItem_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MatMenuItem_click_HostBindingHandler($event) {\n            return ctx._checkDisabled($event);\n          })(\"mouseenter\", function MatMenuItem_mouseenter_HostBindingHandler() {\n            return ctx._handleMouseEnter();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled)(\"disabled\", ctx.disabled || null);\n          i0.ɵɵclassProp(\"mat-mdc-menu-item-highlighted\", ctx._highlighted)(\"mat-mdc-menu-item-submenu-trigger\", ctx._triggersSubmenu);\n        }\n      },\n      inputs: {\n        role: \"role\",\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        disableRipple: [2, \"disableRipple\", \"disableRipple\", booleanAttribute]\n      },\n      exportAs: [\"matMenuItem\"],\n      attrs: _c0,\n      ngContentSelectors: _c2,\n      decls: 5,\n      vars: 3,\n      consts: [[1, \"mat-mdc-menu-item-text\"], [\"matRipple\", \"\", 1, \"mat-mdc-menu-ripple\", 3, \"matRippleDisabled\", \"matRippleTrigger\"], [\"viewBox\", \"0 0 5 10\", \"focusable\", \"false\", \"aria-hidden\", \"true\", 1, \"mat-mdc-menu-submenu-icon\"], [\"points\", \"0,0 5,5 0,10\"]],\n      template: function MatMenuItem_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c1);\n          i0.ɵɵprojection(0);\n          i0.ɵɵelementStart(1, \"span\", 0);\n          i0.ɵɵprojection(2, 1);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(3, \"div\", 1);\n          i0.ɵɵconditionalCreate(4, MatMenuItem_Conditional_4_Template, 2, 0, \":svg:svg\", 2);\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleTrigger\", ctx._getHostElement());\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(ctx._triggersSubmenu ? 4 : -1);\n        }\n      },\n      dependencies: [MatRipple],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatMenuItem;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction throwMatMenuInvalidPositionX() {\n  throw Error(`xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\nfunction throwMatMenuInvalidPositionY() {\n  throw Error(`yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\nfunction throwMatMenuRecursiveError() {\n  throw Error(`matMenuTriggerFor: menu cannot contain its own trigger. Assign a menu that is ` + `not a parent of the trigger or move the trigger outside of the menu.`);\n}\nconst MAT_MENU_CONTENT = /*#__PURE__*/new InjectionToken('MatMenuContent');\nlet MatMenuContent = /*#__PURE__*/(() => {\n  class MatMenuContent {\n    _template = inject(TemplateRef);\n    _appRef = inject(ApplicationRef);\n    _injector = inject(Injector);\n    _viewContainerRef = inject(ViewContainerRef);\n    _document = inject(DOCUMENT);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _portal;\n    _outlet;\n    _attached = new Subject();\n    constructor() {}\n    attach(context = {}) {\n      if (!this._portal) {\n        this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n      }\n      this.detach();\n      if (!this._outlet) {\n        this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._appRef, this._injector);\n      }\n      const element = this._template.elementRef.nativeElement;\n      element.parentNode.insertBefore(this._outlet.outletElement, element);\n      this._changeDetectorRef.markForCheck();\n      this._portal.attach(this._outlet, context);\n      this._attached.next();\n    }\n    detach() {\n      if (this._portal?.isAttached) {\n        this._portal.detach();\n      }\n    }\n    ngOnDestroy() {\n      this.detach();\n      this._outlet?.dispose();\n    }\n    static ɵfac = function MatMenuContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenuContent)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatMenuContent,\n      selectors: [[\"ng-template\", \"matMenuContent\", \"\"]],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MAT_MENU_CONTENT,\n        useExisting: MatMenuContent\n      }])]\n    });\n  }\n  return MatMenuContent;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MAT_MENU_DEFAULT_OPTIONS = /*#__PURE__*/new InjectionToken('mat-menu-default-options', {\n  providedIn: 'root',\n  factory: () => ({\n    overlapTrigger: false,\n    xPosition: 'after',\n    yPosition: 'below',\n    backdropClass: 'cdk-overlay-transparent-backdrop'\n  })\n});\nconst ENTER_ANIMATION = '_mat-menu-enter';\nconst EXIT_ANIMATION = '_mat-menu-exit';\nlet MatMenu = /*#__PURE__*/(() => {\n  class MatMenu {\n    _elementRef = inject(ElementRef);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _injector = inject(Injector);\n    _keyManager;\n    _xPosition;\n    _yPosition;\n    _firstItemFocusRef;\n    _exitFallbackTimeout;\n    _animationsDisabled = _animationsDisabled();\n    _allItems;\n    _directDescendantItems = new QueryList();\n    _classList = {};\n    _panelAnimationState = 'void';\n    _animationDone = new Subject();\n    _isAnimating = signal(false, ...(ngDevMode ? [{\n      debugName: \"_isAnimating\"\n    }] : []));\n    parentMenu;\n    direction;\n    overlayPanelClass;\n    backdropClass;\n    ariaLabel;\n    ariaLabelledby;\n    ariaDescribedby;\n    get xPosition() {\n      return this._xPosition;\n    }\n    set xPosition(value) {\n      if (value !== 'before' && value !== 'after' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throwMatMenuInvalidPositionX();\n      }\n      this._xPosition = value;\n      this.setPositionClasses();\n    }\n    get yPosition() {\n      return this._yPosition;\n    }\n    set yPosition(value) {\n      if (value !== 'above' && value !== 'below' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throwMatMenuInvalidPositionY();\n      }\n      this._yPosition = value;\n      this.setPositionClasses();\n    }\n    templateRef;\n    items;\n    lazyContent;\n    overlapTrigger;\n    hasBackdrop;\n    set panelClass(classes) {\n      const previousPanelClass = this._previousPanelClass;\n      const newClassList = {\n        ...this._classList\n      };\n      if (previousPanelClass && previousPanelClass.length) {\n        previousPanelClass.split(' ').forEach(className => {\n          newClassList[className] = false;\n        });\n      }\n      this._previousPanelClass = classes;\n      if (classes && classes.length) {\n        classes.split(' ').forEach(className => {\n          newClassList[className] = true;\n        });\n        this._elementRef.nativeElement.className = '';\n      }\n      this._classList = newClassList;\n    }\n    _previousPanelClass;\n    get classList() {\n      return this.panelClass;\n    }\n    set classList(classes) {\n      this.panelClass = classes;\n    }\n    closed = new EventEmitter();\n    close = this.closed;\n    panelId = inject(_IdGenerator).getId('mat-menu-panel-');\n    constructor() {\n      const defaultOptions = inject(MAT_MENU_DEFAULT_OPTIONS);\n      this.overlayPanelClass = defaultOptions.overlayPanelClass || '';\n      this._xPosition = defaultOptions.xPosition;\n      this._yPosition = defaultOptions.yPosition;\n      this.backdropClass = defaultOptions.backdropClass;\n      this.overlapTrigger = defaultOptions.overlapTrigger;\n      this.hasBackdrop = defaultOptions.hasBackdrop;\n    }\n    ngOnInit() {\n      this.setPositionClasses();\n    }\n    ngAfterContentInit() {\n      this._updateDirectDescendants();\n      this._keyManager = new FocusKeyManager(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd();\n      this._keyManager.tabOut.subscribe(() => this.closed.emit('tab'));\n      this._directDescendantItems.changes.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map(item => item._focused)))).subscribe(focusedItem => this._keyManager.updateActiveItem(focusedItem));\n      this._directDescendantItems.changes.subscribe(itemsList => {\n        const manager = this._keyManager;\n        if (this._panelAnimationState === 'enter' && manager.activeItem?._hasFocus()) {\n          const items = itemsList.toArray();\n          const index = Math.max(0, Math.min(items.length - 1, manager.activeItemIndex || 0));\n          if (items[index] && !items[index].disabled) {\n            manager.setActiveItem(index);\n          } else {\n            manager.setNextItemActive();\n          }\n        }\n      });\n    }\n    ngOnDestroy() {\n      this._keyManager?.destroy();\n      this._directDescendantItems.destroy();\n      this.closed.complete();\n      this._firstItemFocusRef?.destroy();\n      clearTimeout(this._exitFallbackTimeout);\n    }\n    _hovered() {\n      const itemChanges = this._directDescendantItems.changes;\n      return itemChanges.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map(item => item._hovered))));\n    }\n    addItem(_item) {}\n    removeItem(_item) {}\n    _handleKeydown(event) {\n      const keyCode = event.keyCode;\n      const manager = this._keyManager;\n      switch (keyCode) {\n        case ESCAPE:\n          if (!hasModifierKey(event)) {\n            event.preventDefault();\n            this.closed.emit('keydown');\n          }\n          break;\n        case LEFT_ARROW:\n          if (this.parentMenu && this.direction === 'ltr') {\n            this.closed.emit('keydown');\n          }\n          break;\n        case RIGHT_ARROW:\n          if (this.parentMenu && this.direction === 'rtl') {\n            this.closed.emit('keydown');\n          }\n          break;\n        default:\n          if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n            manager.setFocusOrigin('keyboard');\n          }\n          manager.onKeydown(event);\n          return;\n      }\n    }\n    focusFirstItem(origin = 'program') {\n      this._firstItemFocusRef?.destroy();\n      this._firstItemFocusRef = afterNextRender(() => {\n        const menuPanel = this._resolvePanel();\n        if (!menuPanel || !menuPanel.contains(document.activeElement)) {\n          const manager = this._keyManager;\n          manager.setFocusOrigin(origin).setFirstItemActive();\n          if (!manager.activeItem && menuPanel) {\n            menuPanel.focus();\n          }\n        }\n      }, {\n        injector: this._injector\n      });\n    }\n    resetActiveItem() {\n      this._keyManager.setActiveItem(-1);\n    }\n    setElevation(_depth) {}\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\n      this._classList = {\n        ...this._classList,\n        ['mat-menu-before']: posX === 'before',\n        ['mat-menu-after']: posX === 'after',\n        ['mat-menu-above']: posY === 'above',\n        ['mat-menu-below']: posY === 'below'\n      };\n      this._changeDetectorRef.markForCheck();\n    }\n    _onAnimationDone(state) {\n      const isExit = state === EXIT_ANIMATION;\n      if (isExit || state === ENTER_ANIMATION) {\n        if (isExit) {\n          clearTimeout(this._exitFallbackTimeout);\n          this._exitFallbackTimeout = undefined;\n        }\n        this._animationDone.next(isExit ? 'void' : 'enter');\n        this._isAnimating.set(false);\n      }\n    }\n    _onAnimationStart(state) {\n      if (state === ENTER_ANIMATION || state === EXIT_ANIMATION) {\n        this._isAnimating.set(true);\n      }\n    }\n    _setIsOpen(isOpen) {\n      this._panelAnimationState = isOpen ? 'enter' : 'void';\n      if (isOpen) {\n        if (this._keyManager.activeItemIndex === 0) {\n          const menuPanel = this._resolvePanel();\n          if (menuPanel) {\n            menuPanel.scrollTop = 0;\n          }\n        }\n      } else if (!this._animationsDisabled) {\n        this._exitFallbackTimeout = setTimeout(() => this._onAnimationDone(EXIT_ANIMATION), 200);\n      }\n      if (this._animationsDisabled) {\n        setTimeout(() => {\n          this._onAnimationDone(isOpen ? ENTER_ANIMATION : EXIT_ANIMATION);\n        });\n      }\n      this._changeDetectorRef.markForCheck();\n    }\n    _updateDirectDescendants() {\n      this._allItems.changes.pipe(startWith(this._allItems)).subscribe(items => {\n        this._directDescendantItems.reset(items.filter(item => item._parentMenu === this));\n        this._directDescendantItems.notifyOnChanges();\n      });\n    }\n    _resolvePanel() {\n      let menuPanel = null;\n      if (this._directDescendantItems.length) {\n        menuPanel = this._directDescendantItems.first._getHostElement().closest('[role=\"menu\"]');\n      }\n      return menuPanel;\n    }\n    static ɵfac = function MatMenu_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenu)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatMenu,\n      selectors: [[\"mat-menu\"]],\n      contentQueries: function MatMenu_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, MAT_MENU_CONTENT, 5)(dirIndex, MatMenuItem, 5)(dirIndex, MatMenuItem, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lazyContent = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._allItems = _t);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n        }\n      },\n      viewQuery: function MatMenu_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(TemplateRef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n        }\n      },\n      hostVars: 3,\n      hostBindings: function MatMenu_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-label\", null)(\"aria-labelledby\", null)(\"aria-describedby\", null);\n        }\n      },\n      inputs: {\n        backdropClass: \"backdropClass\",\n        ariaLabel: [0, \"aria-label\", \"ariaLabel\"],\n        ariaLabelledby: [0, \"aria-labelledby\", \"ariaLabelledby\"],\n        ariaDescribedby: [0, \"aria-describedby\", \"ariaDescribedby\"],\n        xPosition: \"xPosition\",\n        yPosition: \"yPosition\",\n        overlapTrigger: [2, \"overlapTrigger\", \"overlapTrigger\", booleanAttribute],\n        hasBackdrop: [2, \"hasBackdrop\", \"hasBackdrop\", value => value == null ? null : booleanAttribute(value)],\n        panelClass: [0, \"class\", \"panelClass\"],\n        classList: \"classList\"\n      },\n      outputs: {\n        closed: \"closed\",\n        close: \"close\"\n      },\n      exportAs: [\"matMenu\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MAT_MENU_PANEL,\n        useExisting: MatMenu\n      }])],\n      ngContentSelectors: _c3,\n      decls: 1,\n      vars: 0,\n      consts: [[\"tabindex\", \"-1\", \"role\", \"menu\", 1, \"mat-mdc-menu-panel\", 3, \"click\", \"animationstart\", \"animationend\", \"animationcancel\", \"id\"], [1, \"mat-mdc-menu-content\"]],\n      template: function MatMenu_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵdomTemplate(0, MatMenu_ng_template_0_Template, 3, 12, \"ng-template\");\n        }\n      },\n      styles: [\"mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{border-top-color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:\\\"\\\";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatMenu;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MAT_MENU_SCROLL_STRATEGY = /*#__PURE__*/new InjectionToken('mat-menu-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(Injector);\n    return () => createRepositionScrollStrategy(injector);\n  }\n});\nconst MENU_PANEL_TOP_PADDING = 8;\nconst PANELS_TO_TRIGGERS = /*#__PURE__*/new WeakMap();\nlet MatMenuTriggerBase = /*#__PURE__*/(() => {\n  class MatMenuTriggerBase {\n    _canHaveBackdrop;\n    _element = inject(ElementRef);\n    _viewContainerRef = inject(ViewContainerRef);\n    _menuItemInstance = inject(MatMenuItem, {\n      optional: true,\n      self: true\n    });\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _focusMonitor = inject(FocusMonitor);\n    _ngZone = inject(NgZone);\n    _injector = inject(Injector);\n    _scrollStrategy = inject(MAT_MENU_SCROLL_STRATEGY);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _animationsDisabled = _animationsDisabled();\n    _portal;\n    _overlayRef = null;\n    _menuOpen = false;\n    _closingActionsSubscription = Subscription.EMPTY;\n    _menuCloseSubscription = Subscription.EMPTY;\n    _pendingRemoval;\n    _parentMaterialMenu;\n    _parentInnerPadding;\n    _openedBy = undefined;\n    get _menu() {\n      return this._menuInternal;\n    }\n    set _menu(menu) {\n      if (menu === this._menuInternal) {\n        return;\n      }\n      this._menuInternal = menu;\n      this._menuCloseSubscription.unsubscribe();\n      if (menu) {\n        if (menu === this._parentMaterialMenu && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throwMatMenuRecursiveError();\n        }\n        this._menuCloseSubscription = menu.close.subscribe(reason => {\n          this._destroyMenu(reason);\n          if ((reason === 'click' || reason === 'tab') && this._parentMaterialMenu) {\n            this._parentMaterialMenu.closed.emit(reason);\n          }\n        });\n      }\n      this._menuItemInstance?._setTriggersSubmenu(this._triggersSubmenu());\n    }\n    _menuInternal;\n    constructor(_canHaveBackdrop) {\n      this._canHaveBackdrop = _canHaveBackdrop;\n      const parentMenu = inject(MAT_MENU_PANEL, {\n        optional: true\n      });\n      this._parentMaterialMenu = parentMenu instanceof MatMenu ? parentMenu : undefined;\n    }\n    ngOnDestroy() {\n      if (this._menu && this._ownsMenu(this._menu)) {\n        PANELS_TO_TRIGGERS.delete(this._menu);\n      }\n      this._pendingRemoval?.unsubscribe();\n      this._menuCloseSubscription.unsubscribe();\n      this._closingActionsSubscription.unsubscribe();\n      if (this._overlayRef) {\n        this._overlayRef.dispose();\n        this._overlayRef = null;\n      }\n    }\n    get menuOpen() {\n      return this._menuOpen;\n    }\n    get dir() {\n      return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    _triggersSubmenu() {\n      return !!(this._menuItemInstance && this._parentMaterialMenu && this._menu);\n    }\n    _closeMenu() {\n      this._menu?.close.emit();\n    }\n    _openMenu(autoFocus) {\n      const menu = this._menu;\n      if (this._menuOpen || !menu) {\n        return;\n      }\n      this._pendingRemoval?.unsubscribe();\n      const previousTrigger = PANELS_TO_TRIGGERS.get(menu);\n      PANELS_TO_TRIGGERS.set(menu, this);\n      if (previousTrigger && previousTrigger !== this) {\n        previousTrigger._closeMenu();\n      }\n      const overlayRef = this._createOverlay(menu);\n      const overlayConfig = overlayRef.getConfig();\n      const positionStrategy = overlayConfig.positionStrategy;\n      this._setPosition(menu, positionStrategy);\n      if (this._canHaveBackdrop) {\n        overlayConfig.hasBackdrop = menu.hasBackdrop == null ? !this._triggersSubmenu() : menu.hasBackdrop;\n      } else {\n        overlayConfig.hasBackdrop = false;\n      }\n      if (!overlayRef.hasAttached()) {\n        overlayRef.attach(this._getPortal(menu));\n        menu.lazyContent?.attach(this.menuData);\n      }\n      this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this._closeMenu());\n      menu.parentMenu = this._triggersSubmenu() ? this._parentMaterialMenu : undefined;\n      menu.direction = this.dir;\n      if (autoFocus) {\n        menu.focusFirstItem(this._openedBy || 'program');\n      }\n      this._setIsMenuOpen(true);\n      if (menu instanceof MatMenu) {\n        menu._setIsOpen(true);\n        menu._directDescendantItems.changes.pipe(takeUntil(menu.close)).subscribe(() => {\n          positionStrategy.withLockedPosition(false).reapplyLastPosition();\n          positionStrategy.withLockedPosition(true);\n        });\n      }\n    }\n    focus(origin, options) {\n      if (this._focusMonitor && origin) {\n        this._focusMonitor.focusVia(this._element, origin, options);\n      } else {\n        this._element.nativeElement.focus(options);\n      }\n    }\n    _destroyMenu(reason) {\n      const overlayRef = this._overlayRef;\n      const menu = this._menu;\n      if (!overlayRef || !this.menuOpen) {\n        return;\n      }\n      this._closingActionsSubscription.unsubscribe();\n      this._pendingRemoval?.unsubscribe();\n      if (menu instanceof MatMenu && this._ownsMenu(menu)) {\n        this._pendingRemoval = menu._animationDone.pipe(take(1)).subscribe(() => {\n          overlayRef.detach();\n          if (!PANELS_TO_TRIGGERS.has(menu)) {\n            menu.lazyContent?.detach();\n          }\n        });\n        menu._setIsOpen(false);\n      } else {\n        overlayRef.detach();\n        menu?.lazyContent?.detach();\n      }\n      if (menu && this._ownsMenu(menu)) {\n        PANELS_TO_TRIGGERS.delete(menu);\n      }\n      if (this.restoreFocus && (reason === 'keydown' || !this._openedBy || !this._triggersSubmenu())) {\n        this.focus(this._openedBy);\n      }\n      this._openedBy = undefined;\n      this._setIsMenuOpen(false);\n    }\n    _setIsMenuOpen(isOpen) {\n      if (isOpen !== this._menuOpen) {\n        this._menuOpen = isOpen;\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n        if (this._triggersSubmenu()) {\n          this._menuItemInstance._setHighlighted(isOpen);\n        }\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    _createOverlay(menu) {\n      if (!this._overlayRef) {\n        const config = this._getOverlayConfig(menu);\n        this._subscribeToPositions(menu, config.positionStrategy);\n        this._overlayRef = createOverlayRef(this._injector, config);\n        this._overlayRef.keydownEvents().subscribe(event => {\n          if (this._menu instanceof MatMenu) {\n            this._menu._handleKeydown(event);\n          }\n        });\n      }\n      return this._overlayRef;\n    }\n    _getOverlayConfig(menu) {\n      return new OverlayConfig({\n        positionStrategy: createFlexibleConnectedPositionStrategy(this._injector, this._getOverlayOrigin()).withLockedPosition().withGrowAfterOpen().withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),\n        backdropClass: menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n        panelClass: menu.overlayPanelClass,\n        scrollStrategy: this._scrollStrategy(),\n        direction: this._dir || 'ltr',\n        disableAnimations: this._animationsDisabled\n      });\n    }\n    _subscribeToPositions(menu, position) {\n      if (menu.setPositionClasses) {\n        position.positionChanges.subscribe(change => {\n          this._ngZone.run(() => {\n            const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n            const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n            menu.setPositionClasses(posX, posY);\n          });\n        });\n      }\n    }\n    _setPosition(menu, positionStrategy) {\n      let [originX, originFallbackX] = menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n      let [overlayY, overlayFallbackY] = menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n      let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n      let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n      let offsetY = 0;\n      if (this._triggersSubmenu()) {\n        overlayFallbackX = originX = menu.xPosition === 'before' ? 'start' : 'end';\n        originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n        if (this._parentMaterialMenu) {\n          if (this._parentInnerPadding == null) {\n            const firstItem = this._parentMaterialMenu.items.first;\n            this._parentInnerPadding = firstItem ? firstItem._getHostElement().offsetTop : 0;\n          }\n          offsetY = overlayY === 'bottom' ? this._parentInnerPadding : -this._parentInnerPadding;\n        }\n      } else if (!menu.overlapTrigger) {\n        originY = overlayY === 'top' ? 'bottom' : 'top';\n        originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n      }\n      positionStrategy.withPositions([{\n        originX,\n        originY,\n        overlayX,\n        overlayY,\n        offsetY\n      }, {\n        originX: originFallbackX,\n        originY,\n        overlayX: overlayFallbackX,\n        overlayY,\n        offsetY\n      }, {\n        originX,\n        originY: originFallbackY,\n        overlayX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }, {\n        originX: originFallbackX,\n        originY: originFallbackY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }]);\n    }\n    _menuClosingActions() {\n      const outsideClicks = this._getOutsideClickStream(this._overlayRef);\n      const detachments = this._overlayRef.detachments();\n      const parentClose = this._parentMaterialMenu ? this._parentMaterialMenu.closed : of();\n      const hover = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(filter(active => this._menuOpen && active !== this._menuItemInstance)) : of();\n      return merge(outsideClicks, parentClose, hover, detachments);\n    }\n    _getPortal(menu) {\n      if (!this._portal || this._portal.templateRef !== menu.templateRef) {\n        this._portal = new TemplatePortal(menu.templateRef, this._viewContainerRef);\n      }\n      return this._portal;\n    }\n    _ownsMenu(menu) {\n      return PANELS_TO_TRIGGERS.get(menu) === this;\n    }\n    static ɵfac = function MatMenuTriggerBase_Factory(__ngFactoryType__) {\n      i0.ɵɵinvalidFactory();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatMenuTriggerBase\n    });\n  }\n  return MatMenuTriggerBase;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatMenuTrigger = /*#__PURE__*/(() => {\n  class MatMenuTrigger extends MatMenuTriggerBase {\n    _cleanupTouchstart;\n    _hoverSubscription = Subscription.EMPTY;\n    get _deprecatedMatMenuTriggerFor() {\n      return this.menu;\n    }\n    set _deprecatedMatMenuTriggerFor(v) {\n      this.menu = v;\n    }\n    get menu() {\n      return this._menu;\n    }\n    set menu(menu) {\n      this._menu = menu;\n    }\n    menuData;\n    restoreFocus = true;\n    menuOpened = new EventEmitter();\n    onMenuOpen = this.menuOpened;\n    menuClosed = new EventEmitter();\n    onMenuClose = this.menuClosed;\n    constructor() {\n      super(true);\n      const renderer = inject(Renderer2);\n      this._cleanupTouchstart = renderer.listen(this._element.nativeElement, 'touchstart', event => {\n        if (!isFakeTouchstartFromScreenReader(event)) {\n          this._openedBy = 'touch';\n        }\n      }, {\n        passive: true\n      });\n    }\n    triggersSubmenu() {\n      return super._triggersSubmenu();\n    }\n    toggleMenu() {\n      return this.menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    openMenu() {\n      this._openMenu(true);\n    }\n    closeMenu() {\n      this._closeMenu();\n    }\n    updatePosition() {\n      this._overlayRef?.updatePosition();\n    }\n    ngAfterContentInit() {\n      this._handleHover();\n    }\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this._cleanupTouchstart();\n      this._hoverSubscription.unsubscribe();\n    }\n    _getOverlayOrigin() {\n      return this._element;\n    }\n    _getOutsideClickStream(overlayRef) {\n      return overlayRef.backdropClick();\n    }\n    _handleMousedown(event) {\n      if (!isFakeMousedownFromScreenReader(event)) {\n        this._openedBy = event.button === 0 ? 'mouse' : undefined;\n        if (this.triggersSubmenu()) {\n          event.preventDefault();\n        }\n      }\n    }\n    _handleKeydown(event) {\n      const keyCode = event.keyCode;\n      if (keyCode === ENTER || keyCode === SPACE) {\n        this._openedBy = 'keyboard';\n      }\n      if (this.triggersSubmenu() && (keyCode === RIGHT_ARROW && this.dir === 'ltr' || keyCode === LEFT_ARROW && this.dir === 'rtl')) {\n        this._openedBy = 'keyboard';\n        this.openMenu();\n      }\n    }\n    _handleClick(event) {\n      if (this.triggersSubmenu()) {\n        event.stopPropagation();\n        this.openMenu();\n      } else {\n        this.toggleMenu();\n      }\n    }\n    _handleHover() {\n      if (this.triggersSubmenu() && this._parentMaterialMenu) {\n        this._hoverSubscription = this._parentMaterialMenu._hovered().subscribe(active => {\n          if (active === this._menuItemInstance && !active.disabled && this._parentMaterialMenu?._panelAnimationState !== 'void') {\n            this._openedBy = 'mouse';\n            this._openMenu(false);\n          }\n        });\n      }\n    }\n    static ɵfac = function MatMenuTrigger_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenuTrigger)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatMenuTrigger,\n      selectors: [[\"\", \"mat-menu-trigger-for\", \"\"], [\"\", \"matMenuTriggerFor\", \"\"]],\n      hostAttrs: [1, \"mat-mdc-menu-trigger\"],\n      hostVars: 3,\n      hostBindings: function MatMenuTrigger_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MatMenuTrigger_click_HostBindingHandler($event) {\n            return ctx._handleClick($event);\n          })(\"mousedown\", function MatMenuTrigger_mousedown_HostBindingHandler($event) {\n            return ctx._handleMousedown($event);\n          })(\"keydown\", function MatMenuTrigger_keydown_HostBindingHandler($event) {\n            return ctx._handleKeydown($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-haspopup\", ctx.menu ? \"menu\" : null)(\"aria-expanded\", ctx.menuOpen)(\"aria-controls\", ctx.menuOpen ? ctx.menu == null ? null : ctx.menu.panelId : null);\n        }\n      },\n      inputs: {\n        _deprecatedMatMenuTriggerFor: [0, \"mat-menu-trigger-for\", \"_deprecatedMatMenuTriggerFor\"],\n        menu: [0, \"matMenuTriggerFor\", \"menu\"],\n        menuData: [0, \"matMenuTriggerData\", \"menuData\"],\n        restoreFocus: [0, \"matMenuTriggerRestoreFocus\", \"restoreFocus\"]\n      },\n      outputs: {\n        menuOpened: \"menuOpened\",\n        onMenuOpen: \"onMenuOpen\",\n        menuClosed: \"menuClosed\",\n        onMenuClose: \"onMenuClose\"\n      },\n      exportAs: [\"matMenuTrigger\"],\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatMenuTrigger;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatContextMenuTrigger = /*#__PURE__*/(() => {\n  class MatContextMenuTrigger extends MatMenuTriggerBase {\n    _point = {\n      x: 0,\n      y: 0,\n      initialX: 0,\n      initialY: 0,\n      initialScrollX: 0,\n      initialScrollY: 0\n    };\n    _triggerPressedControl = false;\n    _rootNode;\n    _document = inject(DOCUMENT);\n    _viewportRuler = inject(ViewportRuler);\n    _scrollDispatcher = inject(ScrollDispatcher);\n    _scrollSubscription;\n    get menu() {\n      return this._menu;\n    }\n    set menu(menu) {\n      this._menu = menu;\n    }\n    menuData;\n    restoreFocus = true;\n    disabled = false;\n    menuOpened = new EventEmitter();\n    menuClosed = new EventEmitter();\n    constructor() {\n      super(false);\n    }\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this._scrollSubscription?.unsubscribe();\n    }\n    _handleContextMenuEvent(event) {\n      if (!this.disabled) {\n        event.preventDefault();\n        if (this.menuOpen) {\n          this._initializePoint(event.clientX, event.clientY);\n          this._updatePosition();\n        } else {\n          this._openContextMenu(event);\n        }\n      }\n    }\n    _destroyMenu(reason) {\n      super._destroyMenu(reason);\n      this._scrollSubscription?.unsubscribe();\n    }\n    _getOverlayOrigin() {\n      return this._point;\n    }\n    _getOutsideClickStream(overlayRef) {\n      return overlayRef.outsidePointerEvents().pipe(skipWhile((event, index) => {\n        if (event.type === 'contextmenu') {\n          return this._isWithinMenuOrTrigger(_getEventTarget(event));\n        } else if (event.type === 'auxclick') {\n          if (index === 0) {\n            return true;\n          }\n          this._rootNode ??= _getShadowRoot(this._element.nativeElement) || this._document;\n          return this._isWithinMenuOrTrigger(this._rootNode.elementFromPoint(event.clientX, event.clientY));\n        }\n        return this._triggerPressedControl && index === 0 && event.ctrlKey;\n      }));\n    }\n    _isWithinMenuOrTrigger(target) {\n      if (!target) {\n        return false;\n      }\n      const element = this._element.nativeElement;\n      if (target === element || element.contains(target)) {\n        return true;\n      }\n      const overlay = this._overlayRef?.hostElement;\n      return overlay === target || !!overlay?.contains(target);\n    }\n    _openContextMenu(event) {\n      if (event.button === 2) {\n        this._openedBy = 'mouse';\n      } else {\n        this._openedBy = event.button === 0 ? 'keyboard' : undefined;\n      }\n      this._initializePoint(event.clientX, event.clientY);\n      this._triggerPressedControl = event.ctrlKey;\n      super._openMenu(true);\n      this._scrollSubscription?.unsubscribe();\n      this._scrollSubscription = this._scrollDispatcher.scrolled(0).subscribe(() => {\n        const position = this._viewportRuler.getViewportScrollPosition();\n        const point = this._point;\n        point.y = point.initialY + (point.initialScrollY - position.top);\n        point.x = point.initialX + (point.initialScrollX - position.left);\n        this._updatePosition();\n      });\n    }\n    _initializePoint(x, y) {\n      const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n      const point = this._point;\n      point.x = point.initialX = x;\n      point.y = point.initialY = y;\n      point.initialScrollX = scrollPosition.left;\n      point.initialScrollY = scrollPosition.top;\n    }\n    _updatePosition() {\n      const overlayRef = this._overlayRef;\n      if (overlayRef) {\n        const positionStrategy = overlayRef.getConfig().positionStrategy;\n        positionStrategy.setOrigin(this._point);\n        overlayRef.updatePosition();\n      }\n    }\n    static ɵfac = function MatContextMenuTrigger_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatContextMenuTrigger)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatContextMenuTrigger,\n      selectors: [[\"\", \"matContextMenuTriggerFor\", \"\"]],\n      hostAttrs: [1, \"mat-context-menu-trigger\"],\n      hostVars: 3,\n      hostBindings: function MatContextMenuTrigger_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"contextmenu\", function MatContextMenuTrigger_contextmenu_HostBindingHandler($event) {\n            return ctx._handleContextMenuEvent($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-controls\", ctx.menuOpen ? ctx.menu == null ? null : ctx.menu.panelId : null);\n          i0.ɵɵclassProp(\"mat-context-menu-trigger-disabled\", ctx.disabled);\n        }\n      },\n      inputs: {\n        menu: [0, \"matContextMenuTriggerFor\", \"menu\"],\n        menuData: [0, \"matContextMenuTriggerData\", \"menuData\"],\n        restoreFocus: [0, \"matContextMenuTriggerRestoreFocus\", \"restoreFocus\"],\n        disabled: [2, \"matContextMenuTriggerDisabled\", \"disabled\", booleanAttribute]\n      },\n      outputs: {\n        menuOpened: \"menuOpened\",\n        menuClosed: \"menuClosed\"\n      },\n      exportAs: [\"matContextMenuTrigger\"],\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatContextMenuTrigger;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatMenuModule = /*#__PURE__*/(() => {\n  class MatMenuModule {\n    static ɵfac = function MatMenuModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenuModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatMenuModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [MatRippleModule, OverlayModule, BidiModule, CdkScrollableModule]\n    });\n  }\n  return MatMenuModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { MAT_MENU_CONTENT, MAT_MENU_DEFAULT_OPTIONS, MAT_MENU_PANEL, MAT_MENU_SCROLL_STRATEGY, MENU_PANEL_TOP_PADDING, MatContextMenuTrigger, MatMenu, MatMenuContent, MatMenuItem, MatMenuModule, MatMenuTrigger };\n//# sourceMappingURL=menu.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}