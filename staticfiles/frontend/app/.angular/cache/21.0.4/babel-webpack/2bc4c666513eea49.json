{"ast":null,"code":"class TileCoordinator {\n  tracker;\n  columnIndex = 0;\n  rowIndex = 0;\n  get rowCount() {\n    return this.rowIndex + 1;\n  }\n  get rowspan() {\n    const lastRowMax = Math.max(...this.tracker);\n    return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;\n  }\n  positions;\n  update(numColumns, tiles) {\n    this.columnIndex = 0;\n    this.rowIndex = 0;\n    this.tracker = new Array(numColumns);\n    this.tracker.fill(0, 0, this.tracker.length);\n    this.positions = tiles.map(tile => this._trackTile(tile));\n  }\n  _trackTile(tile) {\n    const gapStartIndex = this._findMatchingGap(tile.colspan);\n    this._markTilePosition(gapStartIndex, tile);\n    this.columnIndex = gapStartIndex + tile.colspan;\n    return new TilePosition(this.rowIndex, gapStartIndex);\n  }\n  _findMatchingGap(tileCols) {\n    if (tileCols > this.tracker.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error(`mat-grid-list: tile with colspan ${tileCols} is wider than ` + `grid with cols=\"${this.tracker.length}\".`);\n    }\n    let gapStartIndex = -1;\n    let gapEndIndex = -1;\n    do {\n      if (this.columnIndex + tileCols > this.tracker.length) {\n        this._nextRow();\n        gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\n        gapEndIndex = this._findGapEndIndex(gapStartIndex);\n        continue;\n      }\n      gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\n      if (gapStartIndex == -1) {\n        this._nextRow();\n        gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\n        gapEndIndex = this._findGapEndIndex(gapStartIndex);\n        continue;\n      }\n      gapEndIndex = this._findGapEndIndex(gapStartIndex);\n      this.columnIndex = gapStartIndex + 1;\n    } while (gapEndIndex - gapStartIndex < tileCols || gapEndIndex == 0);\n    return Math.max(gapStartIndex, 0);\n  }\n  _nextRow() {\n    this.columnIndex = 0;\n    this.rowIndex++;\n    for (let i = 0; i < this.tracker.length; i++) {\n      this.tracker[i] = Math.max(0, this.tracker[i] - 1);\n    }\n  }\n  _findGapEndIndex(gapStartIndex) {\n    for (let i = gapStartIndex + 1; i < this.tracker.length; i++) {\n      if (this.tracker[i] != 0) {\n        return i;\n      }\n    }\n    return this.tracker.length;\n  }\n  _markTilePosition(start, tile) {\n    for (let i = 0; i < tile.colspan; i++) {\n      this.tracker[start + i] = tile.rowspan;\n    }\n  }\n}\nclass TilePosition {\n  row;\n  col;\n  constructor(row, col) {\n    this.row = row;\n    this.col = col;\n  }\n}\nconst ɵTileCoordinator = TileCoordinator;\nexport { TileCoordinator, ɵTileCoordinator };\n//# sourceMappingURL=_public-api-chunk.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}