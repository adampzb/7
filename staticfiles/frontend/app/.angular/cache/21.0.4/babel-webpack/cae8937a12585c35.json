{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { signal, Component, ViewEncapsulation, ChangeDetectionStrategy, inject, NgZone, DOCUMENT, RendererFactory2, Injectable, InjectionToken, ElementRef, booleanAttribute, Directive, Input, ViewContainerRef, ChangeDetectorRef, EventEmitter, Injector, afterNextRender, numberAttribute, Output, TemplateRef, NgModule } from '@angular/core';\nimport { Subject, Subscription, interval, animationFrameScheduler, Observable, merge, BehaviorSubject } from 'rxjs';\nimport { _getEventTarget, _getShadowRoot } from './_shadow-dom-chunk.mjs';\nimport { isFakeTouchstartFromScreenReader, isFakeMousedownFromScreenReader } from './_fake-event-detection-chunk.mjs';\nimport { coerceElement, coerceNumberProperty } from './_element-chunk.mjs';\nimport { takeUntil, map, take, tap, switchMap, startWith } from 'rxjs/operators';\nimport { _CdkPrivateStyleLoader } from './_style-loader-chunk.mjs';\nimport { ViewportRuler, ScrollDispatcher, CdkScrollableModule } from './scrolling.mjs';\nexport { CdkScrollable as ɵɵCdkScrollable } from './scrolling.mjs';\nimport { Directionality } from './_directionality-chunk.mjs';\nimport { _IdGenerator } from './_id-generator-chunk.mjs';\nimport { coerceArray } from './_array-chunk.mjs';\nimport './_platform-chunk.mjs';\nimport '@angular/common';\nimport './_scrolling-chunk.mjs';\nimport './bidi.mjs';\nimport './_recycle-view-repeater-strategy-chunk.mjs';\nimport './_data-source-chunk.mjs';\nfunction deepCloneNode(node) {\n  const clone = node.cloneNode(true);\n  const descendantsWithId = clone.querySelectorAll('[id]');\n  const nodeName = node.nodeName.toLowerCase();\n  clone.removeAttribute('id');\n  for (let i = 0; i < descendantsWithId.length; i++) {\n    descendantsWithId[i].removeAttribute('id');\n  }\n  if (nodeName === 'canvas') {\n    transferCanvasData(node, clone);\n  } else if (nodeName === 'input' || nodeName === 'select' || nodeName === 'textarea') {\n    transferInputData(node, clone);\n  }\n  transferData('canvas', node, clone, transferCanvasData);\n  transferData('input, textarea, select', node, clone, transferInputData);\n  return clone;\n}\nfunction transferData(selector, node, clone, callback) {\n  const descendantElements = node.querySelectorAll(selector);\n  if (descendantElements.length) {\n    const cloneElements = clone.querySelectorAll(selector);\n    for (let i = 0; i < descendantElements.length; i++) {\n      callback(descendantElements[i], cloneElements[i]);\n    }\n  }\n}\nlet cloneUniqueId = 0;\nfunction transferInputData(source, clone) {\n  if (clone.type !== 'file') {\n    clone.value = source.value;\n  }\n  if (clone.type === 'radio' && clone.name) {\n    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;\n  }\n}\nfunction transferCanvasData(source, clone) {\n  const context = clone.getContext('2d');\n  if (context) {\n    try {\n      context.drawImage(source, 0, 0);\n    } catch {}\n  }\n}\nfunction getMutableClientRect(element) {\n  const rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    width: rect.width,\n    height: rect.height,\n    x: rect.x,\n    y: rect.y\n  };\n}\nfunction isInsideClientRect(clientRect, x, y) {\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = clientRect;\n  return y >= top && y <= bottom && x >= left && x <= right;\n}\nfunction isOverflowingParent(parentRect, childRect) {\n  const isLeftOverflowing = childRect.left < parentRect.left;\n  const isRightOverflowing = childRect.left + childRect.width > parentRect.right;\n  const isTopOverflowing = childRect.top < parentRect.top;\n  const isBottomOverflowing = childRect.top + childRect.height > parentRect.bottom;\n  return isLeftOverflowing || isRightOverflowing || isTopOverflowing || isBottomOverflowing;\n}\nfunction adjustDomRect(domRect, top, left) {\n  domRect.top += top;\n  domRect.bottom = domRect.top + domRect.height;\n  domRect.left += left;\n  domRect.right = domRect.left + domRect.width;\n}\nfunction isPointerNearDomRect(rect, threshold, pointerX, pointerY) {\n  const {\n    top,\n    right,\n    bottom,\n    left,\n    width,\n    height\n  } = rect;\n  const xThreshold = width * threshold;\n  const yThreshold = height * threshold;\n  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;\n}\nclass ParentPositionTracker {\n  _document;\n  positions = /*#__PURE__*/new Map();\n  constructor(_document) {\n    this._document = _document;\n  }\n  clear() {\n    this.positions.clear();\n  }\n  cache(elements) {\n    this.clear();\n    this.positions.set(this._document, {\n      scrollPosition: this.getViewportScrollPosition()\n    });\n    elements.forEach(element => {\n      this.positions.set(element, {\n        scrollPosition: {\n          top: element.scrollTop,\n          left: element.scrollLeft\n        },\n        clientRect: getMutableClientRect(element)\n      });\n    });\n  }\n  handleScroll(event) {\n    const target = _getEventTarget(event);\n    const cachedPosition = this.positions.get(target);\n    if (!cachedPosition) {\n      return null;\n    }\n    const scrollPosition = cachedPosition.scrollPosition;\n    let newTop;\n    let newLeft;\n    if (target === this._document) {\n      const viewportScrollPosition = this.getViewportScrollPosition();\n      newTop = viewportScrollPosition.top;\n      newLeft = viewportScrollPosition.left;\n    } else {\n      newTop = target.scrollTop;\n      newLeft = target.scrollLeft;\n    }\n    const topDifference = scrollPosition.top - newTop;\n    const leftDifference = scrollPosition.left - newLeft;\n    this.positions.forEach((position, node) => {\n      if (position.clientRect && target !== node && target.contains(node)) {\n        adjustDomRect(position.clientRect, topDifference, leftDifference);\n      }\n    });\n    scrollPosition.top = newTop;\n    scrollPosition.left = newLeft;\n    return {\n      top: topDifference,\n      left: leftDifference\n    };\n  }\n  getViewportScrollPosition() {\n    return {\n      top: window.scrollY,\n      left: window.scrollX\n    };\n  }\n}\nfunction getRootNode(viewRef, _document) {\n  const rootNodes = viewRef.rootNodes;\n  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {\n    return rootNodes[0];\n  }\n  const wrapper = _document.createElement('div');\n  rootNodes.forEach(node => wrapper.appendChild(node));\n  return wrapper;\n}\nfunction extendStyles(dest, source, importantProperties) {\n  for (let key in source) {\n    if (source.hasOwnProperty(key)) {\n      const value = source[key];\n      if (value) {\n        dest.setProperty(key, value, importantProperties?.has(key) ? 'important' : '');\n      } else {\n        dest.removeProperty(key);\n      }\n    }\n  }\n  return dest;\n}\nfunction toggleNativeDragInteractions(element, enable) {\n  const userSelect = enable ? '' : 'none';\n  extendStyles(element.style, {\n    'touch-action': enable ? '' : 'none',\n    '-webkit-user-drag': enable ? '' : 'none',\n    '-webkit-tap-highlight-color': enable ? '' : 'transparent',\n    'user-select': userSelect,\n    '-ms-user-select': userSelect,\n    '-webkit-user-select': userSelect,\n    '-moz-user-select': userSelect\n  });\n}\nfunction toggleVisibility(element, enable, importantProperties) {\n  extendStyles(element.style, {\n    position: enable ? '' : 'fixed',\n    top: enable ? '' : '0',\n    opacity: enable ? '' : '0',\n    left: enable ? '' : '-999em'\n  }, importantProperties);\n}\nfunction combineTransforms(transform, initialTransform) {\n  return initialTransform && initialTransform != 'none' ? transform + ' ' + initialTransform : transform;\n}\nfunction matchElementSize(target, sourceRect) {\n  target.style.width = `${sourceRect.width}px`;\n  target.style.height = `${sourceRect.height}px`;\n  target.style.transform = getTransform(sourceRect.left, sourceRect.top);\n}\nfunction getTransform(x, y) {\n  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\nfunction parseCssTimeUnitsToMs(value) {\n  const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n  return parseFloat(value) * multiplier;\n}\nfunction getTransformTransitionDurationInMs(element) {\n  const computedStyle = getComputedStyle(element);\n  const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n  const property = transitionedProperties.find(prop => prop === 'transform' || prop === 'all');\n  if (!property) {\n    return 0;\n  }\n  const propertyIndex = transitionedProperties.indexOf(property);\n  const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n  const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);\n}\nfunction parseCssPropertyValue(computedStyle, name) {\n  const value = computedStyle.getPropertyValue(name);\n  return value.split(',').map(part => part.trim());\n}\nconst importantProperties = /*#__PURE__*/new Set(['position']);\nclass PreviewRef {\n  _document;\n  _rootElement;\n  _direction;\n  _initialDomRect;\n  _previewTemplate;\n  _previewClass;\n  _pickupPositionOnPage;\n  _initialTransform;\n  _zIndex;\n  _renderer;\n  _previewEmbeddedView;\n  _preview;\n  get element() {\n    return this._preview;\n  }\n  constructor(_document, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex, _renderer) {\n    this._document = _document;\n    this._rootElement = _rootElement;\n    this._direction = _direction;\n    this._initialDomRect = _initialDomRect;\n    this._previewTemplate = _previewTemplate;\n    this._previewClass = _previewClass;\n    this._pickupPositionOnPage = _pickupPositionOnPage;\n    this._initialTransform = _initialTransform;\n    this._zIndex = _zIndex;\n    this._renderer = _renderer;\n  }\n  attach(parent) {\n    this._preview = this._createPreview();\n    parent.appendChild(this._preview);\n    if (supportsPopover(this._preview)) {\n      this._preview['showPopover']();\n    }\n  }\n  destroy() {\n    this._preview.remove();\n    this._previewEmbeddedView?.destroy();\n    this._preview = this._previewEmbeddedView = null;\n  }\n  setTransform(value) {\n    this._preview.style.transform = value;\n  }\n  getBoundingClientRect() {\n    return this._preview.getBoundingClientRect();\n  }\n  addClass(className) {\n    this._preview.classList.add(className);\n  }\n  getTransitionDuration() {\n    return getTransformTransitionDurationInMs(this._preview);\n  }\n  addEventListener(name, handler) {\n    return this._renderer.listen(this._preview, name, handler);\n  }\n  _createPreview() {\n    const previewConfig = this._previewTemplate;\n    const previewClass = this._previewClass;\n    const previewTemplate = previewConfig ? previewConfig.template : null;\n    let preview;\n    if (previewTemplate && previewConfig) {\n      const rootRect = previewConfig.matchSize ? this._initialDomRect : null;\n      const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);\n      viewRef.detectChanges();\n      preview = getRootNode(viewRef, this._document);\n      this._previewEmbeddedView = viewRef;\n      if (previewConfig.matchSize) {\n        matchElementSize(preview, rootRect);\n      } else {\n        preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n      }\n    } else {\n      preview = deepCloneNode(this._rootElement);\n      matchElementSize(preview, this._initialDomRect);\n      if (this._initialTransform) {\n        preview.style.transform = this._initialTransform;\n      }\n    }\n    extendStyles(preview.style, {\n      'pointer-events': 'none',\n      'margin': supportsPopover(preview) ? '0 auto 0 0' : '0',\n      'position': 'fixed',\n      'top': '0',\n      'left': '0',\n      'z-index': this._zIndex + ''\n    }, importantProperties);\n    toggleNativeDragInteractions(preview, false);\n    preview.classList.add('cdk-drag-preview');\n    preview.setAttribute('popover', 'manual');\n    preview.setAttribute('dir', this._direction);\n    if (previewClass) {\n      if (Array.isArray(previewClass)) {\n        previewClass.forEach(className => preview.classList.add(className));\n      } else {\n        preview.classList.add(previewClass);\n      }\n    }\n    return preview;\n  }\n}\nfunction supportsPopover(element) {\n  return 'showPopover' in element;\n}\nconst passiveEventListenerOptions = {\n  passive: true\n};\nconst activeEventListenerOptions = {\n  passive: false\n};\nconst activeCapturingEventOptions$1 = {\n  passive: false,\n  capture: true\n};\nconst MOUSE_EVENT_IGNORE_TIME = 800;\nconst PLACEHOLDER_CLASS = 'cdk-drag-placeholder';\nconst dragImportantProperties = /*#__PURE__*/new Set(['position']);\nclass DragRef {\n  _config;\n  _document;\n  _ngZone;\n  _viewportRuler;\n  _dragDropRegistry;\n  _renderer;\n  _rootElementCleanups;\n  _cleanupShadowRootSelectStart;\n  _preview;\n  _previewContainer;\n  _placeholderRef;\n  _placeholder;\n  _pickupPositionInElement;\n  _pickupPositionOnPage;\n  _marker;\n  _anchor = null;\n  _passiveTransform = {\n    x: 0,\n    y: 0\n  };\n  _activeTransform = {\n    x: 0,\n    y: 0\n  };\n  _initialTransform;\n  _hasStartedDragging = /*#__PURE__*/signal(false, ...(ngDevMode ? [{\n    debugName: \"_hasStartedDragging\"\n  }] : []));\n  _hasMoved;\n  _initialContainer;\n  _initialIndex;\n  _parentPositions;\n  _moveEvents = /*#__PURE__*/new Subject();\n  _pointerDirectionDelta;\n  _pointerPositionAtLastDirectionChange;\n  _lastKnownPointerPosition;\n  _rootElement;\n  _ownerSVGElement;\n  _rootElementTapHighlight;\n  _pointerMoveSubscription = Subscription.EMPTY;\n  _pointerUpSubscription = Subscription.EMPTY;\n  _scrollSubscription = Subscription.EMPTY;\n  _resizeSubscription = Subscription.EMPTY;\n  _lastTouchEventTime;\n  _dragStartTime;\n  _boundaryElement = null;\n  _nativeInteractionsEnabled = true;\n  _initialDomRect;\n  _previewRect;\n  _boundaryRect;\n  _previewTemplate;\n  _placeholderTemplate;\n  _handles = [];\n  _disabledHandles = /*#__PURE__*/new Set();\n  _dropContainer;\n  _direction = 'ltr';\n  _parentDragRef;\n  _cachedShadowRoot;\n  lockAxis = null;\n  dragStartDelay = 0;\n  previewClass;\n  scale = 1;\n  get disabled() {\n    return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n  }\n  set disabled(value) {\n    if (value !== this._disabled) {\n      this._disabled = value;\n      this._toggleNativeDragInteractions();\n      this._handles.forEach(handle => toggleNativeDragInteractions(handle, value));\n    }\n  }\n  _disabled = false;\n  beforeStarted = /*#__PURE__*/new Subject();\n  started = /*#__PURE__*/new Subject();\n  released = /*#__PURE__*/new Subject();\n  ended = /*#__PURE__*/new Subject();\n  entered = /*#__PURE__*/new Subject();\n  exited = /*#__PURE__*/new Subject();\n  dropped = /*#__PURE__*/new Subject();\n  moved = this._moveEvents;\n  data;\n  constrainPosition;\n  constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry, _renderer) {\n    this._config = _config;\n    this._document = _document;\n    this._ngZone = _ngZone;\n    this._viewportRuler = _viewportRuler;\n    this._dragDropRegistry = _dragDropRegistry;\n    this._renderer = _renderer;\n    this.withRootElement(element).withParent(_config.parentDragRef || null);\n    this._parentPositions = new ParentPositionTracker(_document);\n    _dragDropRegistry.registerDragItem(this);\n  }\n  getPlaceholderElement() {\n    return this._placeholder;\n  }\n  getRootElement() {\n    return this._rootElement;\n  }\n  getVisibleElement() {\n    return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();\n  }\n  withHandles(handles) {\n    this._handles = handles.map(handle => coerceElement(handle));\n    this._handles.forEach(handle => toggleNativeDragInteractions(handle, this.disabled));\n    this._toggleNativeDragInteractions();\n    const disabledHandles = new Set();\n    this._disabledHandles.forEach(handle => {\n      if (this._handles.indexOf(handle) > -1) {\n        disabledHandles.add(handle);\n      }\n    });\n    this._disabledHandles = disabledHandles;\n    return this;\n  }\n  withPreviewTemplate(template) {\n    this._previewTemplate = template;\n    return this;\n  }\n  withPlaceholderTemplate(template) {\n    this._placeholderTemplate = template;\n    return this;\n  }\n  withRootElement(rootElement) {\n    const element = coerceElement(rootElement);\n    if (element !== this._rootElement) {\n      this._removeRootElementListeners();\n      const renderer = this._renderer;\n      this._rootElementCleanups = this._ngZone.runOutsideAngular(() => [renderer.listen(element, 'mousedown', this._pointerDown, activeEventListenerOptions), renderer.listen(element, 'touchstart', this._pointerDown, passiveEventListenerOptions), renderer.listen(element, 'dragstart', this._nativeDragStart, activeEventListenerOptions)]);\n      this._initialTransform = undefined;\n      this._rootElement = element;\n    }\n    if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n      this._ownerSVGElement = this._rootElement.ownerSVGElement;\n    }\n    return this;\n  }\n  withBoundaryElement(boundaryElement) {\n    this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;\n    this._resizeSubscription.unsubscribe();\n    if (boundaryElement) {\n      this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());\n    }\n    return this;\n  }\n  withParent(parent) {\n    this._parentDragRef = parent;\n    return this;\n  }\n  dispose() {\n    this._removeRootElementListeners();\n    if (this.isDragging()) {\n      this._rootElement?.remove();\n    }\n    this._marker?.remove();\n    this._destroyPreview();\n    this._destroyPlaceholder();\n    this._dragDropRegistry.removeDragItem(this);\n    this._removeListeners();\n    this.beforeStarted.complete();\n    this.started.complete();\n    this.released.complete();\n    this.ended.complete();\n    this.entered.complete();\n    this.exited.complete();\n    this.dropped.complete();\n    this._moveEvents.complete();\n    this._handles = [];\n    this._disabledHandles.clear();\n    this._dropContainer = undefined;\n    this._resizeSubscription.unsubscribe();\n    this._parentPositions.clear();\n    this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._marker = this._parentDragRef = null;\n  }\n  isDragging() {\n    return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);\n  }\n  reset() {\n    this._rootElement.style.transform = this._initialTransform || '';\n    this._activeTransform = {\n      x: 0,\n      y: 0\n    };\n    this._passiveTransform = {\n      x: 0,\n      y: 0\n    };\n  }\n  resetToBoundary() {\n    if (this._boundaryElement && this._rootElement && isOverflowingParent(this._boundaryElement.getBoundingClientRect(), this._rootElement.getBoundingClientRect())) {\n      const parentRect = this._boundaryElement.getBoundingClientRect();\n      const childRect = this._rootElement.getBoundingClientRect();\n      let offsetX = 0;\n      let offsetY = 0;\n      if (childRect.left < parentRect.left) {\n        offsetX = parentRect.left - childRect.left;\n      } else if (childRect.right > parentRect.right) {\n        offsetX = parentRect.right - childRect.right;\n      }\n      if (childRect.top < parentRect.top) {\n        offsetY = parentRect.top - childRect.top;\n      } else if (childRect.bottom > parentRect.bottom) {\n        offsetY = parentRect.bottom - childRect.bottom;\n      }\n      const currentLeft = this._activeTransform.x;\n      const currentTop = this._activeTransform.y;\n      let x = currentLeft + offsetX,\n        y = currentTop + offsetY;\n      this._rootElement.style.transform = getTransform(x, y);\n      this._activeTransform = {\n        x,\n        y\n      };\n      this._passiveTransform = {\n        x,\n        y\n      };\n    }\n  }\n  disableHandle(handle) {\n    if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {\n      this._disabledHandles.add(handle);\n      toggleNativeDragInteractions(handle, true);\n    }\n  }\n  enableHandle(handle) {\n    if (this._disabledHandles.has(handle)) {\n      this._disabledHandles.delete(handle);\n      toggleNativeDragInteractions(handle, this.disabled);\n    }\n  }\n  withDirection(direction) {\n    this._direction = direction;\n    return this;\n  }\n  _withDropContainer(container) {\n    this._dropContainer = container;\n  }\n  getFreeDragPosition() {\n    const position = this.isDragging() ? this._activeTransform : this._passiveTransform;\n    return {\n      x: position.x,\n      y: position.y\n    };\n  }\n  setFreeDragPosition(value) {\n    this._activeTransform = {\n      x: 0,\n      y: 0\n    };\n    this._passiveTransform.x = value.x;\n    this._passiveTransform.y = value.y;\n    if (!this._dropContainer) {\n      this._applyRootElementTransform(value.x, value.y);\n    }\n    return this;\n  }\n  withPreviewContainer(value) {\n    this._previewContainer = value;\n    return this;\n  }\n  _sortFromLastPointerPosition() {\n    const position = this._lastKnownPointerPosition;\n    if (position && this._dropContainer) {\n      this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);\n    }\n  }\n  _removeListeners() {\n    this._pointerMoveSubscription.unsubscribe();\n    this._pointerUpSubscription.unsubscribe();\n    this._scrollSubscription.unsubscribe();\n    this._cleanupShadowRootSelectStart?.();\n    this._cleanupShadowRootSelectStart = undefined;\n  }\n  _destroyPreview() {\n    this._preview?.destroy();\n    this._preview = null;\n  }\n  _destroyPlaceholder() {\n    this._anchor?.remove();\n    this._placeholder?.remove();\n    this._placeholderRef?.destroy();\n    this._placeholder = this._anchor = this._placeholderRef = null;\n  }\n  _pointerDown = event => {\n    this.beforeStarted.next();\n    if (this._handles.length) {\n      const targetHandle = this._getTargetHandle(event);\n      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n        this._initializeDragSequence(targetHandle, event);\n      }\n    } else if (!this.disabled) {\n      this._initializeDragSequence(this._rootElement, event);\n    }\n  };\n  _pointerMove = event => {\n    const pointerPosition = this._getPointerPositionOnPage(event);\n    if (!this._hasStartedDragging()) {\n      const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n      const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n      const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n      if (isOverThreshold) {\n        const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);\n        const container = this._dropContainer;\n        if (!isDelayElapsed) {\n          this._endDragSequence(event);\n          return;\n        }\n        if (!container || !container.isDragging() && !container.isReceiving()) {\n          if (event.cancelable) {\n            event.preventDefault();\n          }\n          this._hasStartedDragging.set(true);\n          this._ngZone.run(() => this._startDragSequence(event));\n        }\n      }\n      return;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);\n    this._hasMoved = true;\n    this._lastKnownPointerPosition = pointerPosition;\n    this._updatePointerDirectionDelta(constrainedPointerPosition);\n    if (this._dropContainer) {\n      this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);\n    } else {\n      const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;\n      const activeTransform = this._activeTransform;\n      activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;\n      activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;\n      this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n    }\n    if (this._moveEvents.observers.length) {\n      this._ngZone.run(() => {\n        this._moveEvents.next({\n          source: this,\n          pointerPosition: constrainedPointerPosition,\n          event,\n          distance: this._getDragDistance(constrainedPointerPosition),\n          delta: this._pointerDirectionDelta\n        });\n      });\n    }\n  };\n  _pointerUp = event => {\n    this._endDragSequence(event);\n  };\n  _endDragSequence(event) {\n    if (!this._dragDropRegistry.isDragging(this)) {\n      return;\n    }\n    this._removeListeners();\n    this._dragDropRegistry.stopDragging(this);\n    this._toggleNativeDragInteractions();\n    if (this._handles) {\n      this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;\n    }\n    if (!this._hasStartedDragging()) {\n      return;\n    }\n    this.released.next({\n      source: this,\n      event\n    });\n    if (this._dropContainer) {\n      this._dropContainer._stopScrolling();\n      this._animatePreviewToPlaceholder().then(() => {\n        this._cleanupDragArtifacts(event);\n        this._cleanupCachedDimensions();\n        this._dragDropRegistry.stopDragging(this);\n      });\n    } else {\n      this._passiveTransform.x = this._activeTransform.x;\n      const pointerPosition = this._getPointerPositionOnPage(event);\n      this._passiveTransform.y = this._activeTransform.y;\n      this._ngZone.run(() => {\n        this.ended.next({\n          source: this,\n          distance: this._getDragDistance(pointerPosition),\n          dropPoint: pointerPosition,\n          event\n        });\n      });\n      this._cleanupCachedDimensions();\n      this._dragDropRegistry.stopDragging(this);\n    }\n  }\n  _startDragSequence(event) {\n    if (isTouchEvent(event)) {\n      this._lastTouchEventTime = Date.now();\n    }\n    this._toggleNativeDragInteractions();\n    const shadowRoot = this._getShadowRoot();\n    const dropContainer = this._dropContainer;\n    if (shadowRoot) {\n      this._ngZone.runOutsideAngular(() => {\n        this._cleanupShadowRootSelectStart = this._renderer.listen(shadowRoot, 'selectstart', shadowDomSelectStart, activeCapturingEventOptions$1);\n      });\n    }\n    if (dropContainer) {\n      const element = this._rootElement;\n      const parent = element.parentNode;\n      const placeholder = this._placeholder = this._createPlaceholderElement();\n      const marker = this._marker = this._marker || this._document.createComment(typeof ngDevMode === 'undefined' || ngDevMode ? 'cdk-drag-marker' : '');\n      parent.insertBefore(marker, element);\n      this._initialTransform = element.style.transform || '';\n      this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1000, this._renderer);\n      this._preview.attach(this._getPreviewInsertionPoint(parent, shadowRoot));\n      toggleVisibility(element, false, dragImportantProperties);\n      this._document.body.appendChild(parent.replaceChild(placeholder, element));\n      this.started.next({\n        source: this,\n        event\n      });\n      dropContainer.start();\n      this._initialContainer = dropContainer;\n      this._initialIndex = dropContainer.getItemIndex(this);\n    } else {\n      this.started.next({\n        source: this,\n        event\n      });\n      this._initialContainer = this._initialIndex = undefined;\n    }\n    this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);\n  }\n  _initializeDragSequence(referenceElement, event) {\n    if (this._parentDragRef) {\n      event.stopPropagation();\n    }\n    const isDragging = this.isDragging();\n    const isTouchSequence = isTouchEvent(event);\n    const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;\n    const rootElement = this._rootElement;\n    const target = _getEventTarget(event);\n    const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n    const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);\n    if (target && target.draggable && event.type === 'mousedown') {\n      event.preventDefault();\n    }\n    if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {\n      return;\n    }\n    if (this._handles.length) {\n      const rootStyles = rootElement.style;\n      this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || '';\n      rootStyles.webkitTapHighlightColor = 'transparent';\n    }\n    this._hasMoved = false;\n    this._hasStartedDragging.set(this._hasMoved);\n    this._removeListeners();\n    this._initialDomRect = this._rootElement.getBoundingClientRect();\n    this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n    this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n    this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(scrollEvent => this._updateOnScroll(scrollEvent));\n    if (this._boundaryElement) {\n      this._boundaryRect = getMutableClientRect(this._boundaryElement);\n    }\n    const previewTemplate = this._previewTemplate;\n    this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {\n      x: 0,\n      y: 0\n    } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);\n    const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);\n    this._pointerDirectionDelta = {\n      x: 0,\n      y: 0\n    };\n    this._pointerPositionAtLastDirectionChange = {\n      x: pointerPosition.x,\n      y: pointerPosition.y\n    };\n    this._dragStartTime = Date.now();\n    this._dragDropRegistry.startDragging(this, event);\n  }\n  _cleanupDragArtifacts(event) {\n    toggleVisibility(this._rootElement, true, dragImportantProperties);\n    this._marker.parentNode.replaceChild(this._rootElement, this._marker);\n    this._destroyPreview();\n    this._destroyPlaceholder();\n    this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = undefined;\n    this._ngZone.run(() => {\n      const container = this._dropContainer;\n      const currentIndex = container.getItemIndex(this);\n      const pointerPosition = this._getPointerPositionOnPage(event);\n      const distance = this._getDragDistance(pointerPosition);\n      const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);\n      this.ended.next({\n        source: this,\n        distance,\n        dropPoint: pointerPosition,\n        event\n      });\n      this.dropped.next({\n        item: this,\n        currentIndex,\n        previousIndex: this._initialIndex,\n        container: container,\n        previousContainer: this._initialContainer,\n        isPointerOverContainer,\n        distance,\n        dropPoint: pointerPosition,\n        event\n      });\n      container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);\n      this._dropContainer = this._initialContainer;\n    });\n  }\n  _updateActiveDropContainer({\n    x,\n    y\n  }, {\n    x: rawX,\n    y: rawY\n  }) {\n    let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n    if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x, y)) {\n      newContainer = this._initialContainer;\n    }\n    if (newContainer && newContainer !== this._dropContainer) {\n      this._ngZone.run(() => {\n        const exitIndex = this._dropContainer.getItemIndex(this);\n        const nextItemElement = this._dropContainer.getItemAtIndex(exitIndex + 1)?.getVisibleElement() || null;\n        this.exited.next({\n          item: this,\n          container: this._dropContainer\n        });\n        this._dropContainer.exit(this);\n        this._conditionallyInsertAnchor(newContainer, this._dropContainer, nextItemElement);\n        this._dropContainer = newContainer;\n        this._dropContainer.enter(this, x, y, newContainer === this._initialContainer && newContainer.sortingDisabled ? this._initialIndex : undefined);\n        this.entered.next({\n          item: this,\n          container: newContainer,\n          currentIndex: newContainer.getItemIndex(this)\n        });\n      });\n    }\n    if (this.isDragging()) {\n      this._dropContainer._startScrollingIfNecessary(rawX, rawY);\n      this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);\n      if (this.constrainPosition) {\n        this._applyPreviewTransform(x, y);\n      } else {\n        this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n      }\n    }\n  }\n  _animatePreviewToPlaceholder() {\n    if (!this._hasMoved) {\n      return Promise.resolve();\n    }\n    const placeholderRect = this._placeholder.getBoundingClientRect();\n    this._preview.addClass('cdk-drag-animating');\n    this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);\n    const duration = this._preview.getTransitionDuration();\n    if (duration === 0) {\n      return Promise.resolve();\n    }\n    return this._ngZone.runOutsideAngular(() => {\n      return new Promise(resolve => {\n        const handler = event => {\n          if (!event || this._preview && _getEventTarget(event) === this._preview.element && event.propertyName === 'transform') {\n            cleanupListener();\n            resolve();\n            clearTimeout(timeout);\n          }\n        };\n        const timeout = setTimeout(handler, duration * 1.5);\n        const cleanupListener = this._preview.addEventListener('transitionend', handler);\n      });\n    });\n  }\n  _createPlaceholderElement() {\n    const placeholderConfig = this._placeholderTemplate;\n    const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n    let placeholder;\n    if (placeholderTemplate) {\n      this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);\n      this._placeholderRef.detectChanges();\n      placeholder = getRootNode(this._placeholderRef, this._document);\n    } else {\n      placeholder = deepCloneNode(this._rootElement);\n    }\n    placeholder.style.pointerEvents = 'none';\n    placeholder.classList.add(PLACEHOLDER_CLASS);\n    return placeholder;\n  }\n  _getPointerPositionInElement(elementRect, referenceElement, event) {\n    const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n    const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n    const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n    const scrollPosition = this._getViewportScrollPosition();\n    const x = point.pageX - referenceRect.left - scrollPosition.left;\n    const y = point.pageY - referenceRect.top - scrollPosition.top;\n    return {\n      x: referenceRect.left - elementRect.left + x,\n      y: referenceRect.top - elementRect.top + y\n    };\n  }\n  _getPointerPositionOnPage(event) {\n    const scrollPosition = this._getViewportScrollPosition();\n    const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] || {\n      pageX: 0,\n      pageY: 0\n    } : event;\n    const x = point.pageX - scrollPosition.left;\n    const y = point.pageY - scrollPosition.top;\n    if (this._ownerSVGElement) {\n      const svgMatrix = this._ownerSVGElement.getScreenCTM();\n      if (svgMatrix) {\n        const svgPoint = this._ownerSVGElement.createSVGPoint();\n        svgPoint.x = x;\n        svgPoint.y = y;\n        return svgPoint.matrixTransform(svgMatrix.inverse());\n      }\n    }\n    return {\n      x,\n      y\n    };\n  }\n  _getConstrainedPointerPosition(point) {\n    const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n    let {\n      x,\n      y\n    } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;\n    if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n      y = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);\n    } else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n      x = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);\n    }\n    if (this._boundaryRect) {\n      const {\n        x: pickupX,\n        y: pickupY\n      } = !this.constrainPosition ? this._pickupPositionInElement : {\n        x: 0,\n        y: 0\n      };\n      const boundaryRect = this._boundaryRect;\n      const {\n        width: previewWidth,\n        height: previewHeight\n      } = this._getPreviewRect();\n      const minY = boundaryRect.top + pickupY;\n      const maxY = boundaryRect.bottom - (previewHeight - pickupY);\n      const minX = boundaryRect.left + pickupX;\n      const maxX = boundaryRect.right - (previewWidth - pickupX);\n      x = clamp$1(x, minX, maxX);\n      y = clamp$1(y, minY, maxY);\n    }\n    return {\n      x,\n      y\n    };\n  }\n  _updatePointerDirectionDelta(pointerPositionOnPage) {\n    const {\n      x,\n      y\n    } = pointerPositionOnPage;\n    const delta = this._pointerDirectionDelta;\n    const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n    const changeX = Math.abs(x - positionSinceLastChange.x);\n    const changeY = Math.abs(y - positionSinceLastChange.y);\n    if (changeX > this._config.pointerDirectionChangeThreshold) {\n      delta.x = x > positionSinceLastChange.x ? 1 : -1;\n      positionSinceLastChange.x = x;\n    }\n    if (changeY > this._config.pointerDirectionChangeThreshold) {\n      delta.y = y > positionSinceLastChange.y ? 1 : -1;\n      positionSinceLastChange.y = y;\n    }\n    return delta;\n  }\n  _toggleNativeDragInteractions() {\n    if (!this._rootElement || !this._handles) {\n      return;\n    }\n    const shouldEnable = this._handles.length > 0 || !this.isDragging();\n    if (shouldEnable !== this._nativeInteractionsEnabled) {\n      this._nativeInteractionsEnabled = shouldEnable;\n      toggleNativeDragInteractions(this._rootElement, shouldEnable);\n    }\n  }\n  _removeRootElementListeners() {\n    this._rootElementCleanups?.forEach(cleanup => cleanup());\n    this._rootElementCleanups = undefined;\n  }\n  _applyRootElementTransform(x, y) {\n    const scale = 1 / this.scale;\n    const transform = getTransform(x * scale, y * scale);\n    const styles = this._rootElement.style;\n    if (this._initialTransform == null) {\n      this._initialTransform = styles.transform && styles.transform != 'none' ? styles.transform : '';\n    }\n    styles.transform = combineTransforms(transform, this._initialTransform);\n  }\n  _applyPreviewTransform(x, y) {\n    const initialTransform = this._previewTemplate?.template ? undefined : this._initialTransform;\n    const transform = getTransform(x, y);\n    this._preview.setTransform(combineTransforms(transform, initialTransform));\n  }\n  _getDragDistance(currentPosition) {\n    const pickupPosition = this._pickupPositionOnPage;\n    if (pickupPosition) {\n      return {\n        x: currentPosition.x - pickupPosition.x,\n        y: currentPosition.y - pickupPosition.y\n      };\n    }\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  _cleanupCachedDimensions() {\n    this._boundaryRect = this._previewRect = undefined;\n    this._parentPositions.clear();\n  }\n  _containInsideBoundaryOnResize() {\n    let {\n      x,\n      y\n    } = this._passiveTransform;\n    if (x === 0 && y === 0 || this.isDragging() || !this._boundaryElement) {\n      return;\n    }\n    const elementRect = this._rootElement.getBoundingClientRect();\n    const boundaryRect = this._boundaryElement.getBoundingClientRect();\n    if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {\n      return;\n    }\n    const leftOverflow = boundaryRect.left - elementRect.left;\n    const rightOverflow = elementRect.right - boundaryRect.right;\n    const topOverflow = boundaryRect.top - elementRect.top;\n    const bottomOverflow = elementRect.bottom - boundaryRect.bottom;\n    if (boundaryRect.width > elementRect.width) {\n      if (leftOverflow > 0) {\n        x += leftOverflow;\n      }\n      if (rightOverflow > 0) {\n        x -= rightOverflow;\n      }\n    } else {\n      x = 0;\n    }\n    if (boundaryRect.height > elementRect.height) {\n      if (topOverflow > 0) {\n        y += topOverflow;\n      }\n      if (bottomOverflow > 0) {\n        y -= bottomOverflow;\n      }\n    } else {\n      y = 0;\n    }\n    if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {\n      this.setFreeDragPosition({\n        y,\n        x\n      });\n    }\n  }\n  _getDragStartDelay(event) {\n    const value = this.dragStartDelay;\n    if (typeof value === 'number') {\n      return value;\n    } else if (isTouchEvent(event)) {\n      return value.touch;\n    }\n    return value ? value.mouse : 0;\n  }\n  _updateOnScroll(event) {\n    const scrollDifference = this._parentPositions.handleScroll(event);\n    if (scrollDifference) {\n      const target = _getEventTarget(event);\n      if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {\n        adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);\n      }\n      this._pickupPositionOnPage.x += scrollDifference.left;\n      this._pickupPositionOnPage.y += scrollDifference.top;\n      if (!this._dropContainer) {\n        this._activeTransform.x -= scrollDifference.left;\n        this._activeTransform.y -= scrollDifference.top;\n        this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);\n      }\n    }\n  }\n  _getViewportScrollPosition() {\n    return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();\n  }\n  _getShadowRoot() {\n    if (this._cachedShadowRoot === undefined) {\n      this._cachedShadowRoot = _getShadowRoot(this._rootElement);\n    }\n    return this._cachedShadowRoot;\n  }\n  _getPreviewInsertionPoint(initialParent, shadowRoot) {\n    const previewContainer = this._previewContainer || 'global';\n    if (previewContainer === 'parent') {\n      return initialParent;\n    }\n    if (previewContainer === 'global') {\n      const documentRef = this._document;\n      return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;\n    }\n    return coerceElement(previewContainer);\n  }\n  _getPreviewRect() {\n    if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {\n      this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;\n    }\n    return this._previewRect;\n  }\n  _nativeDragStart = event => {\n    if (this._handles.length) {\n      const targetHandle = this._getTargetHandle(event);\n      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n        event.preventDefault();\n      }\n    } else if (!this.disabled) {\n      event.preventDefault();\n    }\n  };\n  _getTargetHandle(event) {\n    return this._handles.find(handle => {\n      return event.target && (event.target === handle || handle.contains(event.target));\n    });\n  }\n  _conditionallyInsertAnchor(newContainer, exitContainer, nextItemElement) {\n    if (newContainer === this._initialContainer) {\n      this._anchor?.remove();\n      this._anchor = null;\n    } else if (exitContainer === this._initialContainer && exitContainer.hasAnchor) {\n      const anchor = this._anchor ??= deepCloneNode(this._placeholder);\n      anchor.classList.remove(PLACEHOLDER_CLASS);\n      anchor.classList.add('cdk-drag-anchor');\n      anchor.style.transform = '';\n      if (nextItemElement) {\n        nextItemElement.before(anchor);\n      } else {\n        coerceElement(exitContainer.element).appendChild(anchor);\n      }\n    }\n  }\n}\nfunction clamp$1(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction isTouchEvent(event) {\n  return event.type[0] === 't';\n}\nfunction shadowDomSelectStart(event) {\n  event.preventDefault();\n}\nfunction moveItemInArray(array, fromIndex, toIndex) {\n  const from = clamp(fromIndex, array.length - 1);\n  const to = clamp(toIndex, array.length - 1);\n  if (from === to) {\n    return;\n  }\n  const target = array[from];\n  const delta = to < from ? -1 : 1;\n  for (let i = from; i !== to; i += delta) {\n    array[i] = array[i + delta];\n  }\n  array[to] = target;\n}\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n  const from = clamp(currentIndex, currentArray.length - 1);\n  const to = clamp(targetIndex, targetArray.length);\n  if (currentArray.length) {\n    targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n  }\n}\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n  const to = clamp(targetIndex, targetArray.length);\n  if (currentArray.length) {\n    targetArray.splice(to, 0, currentArray[currentIndex]);\n  }\n}\nfunction clamp(value, max) {\n  return Math.max(0, Math.min(max, value));\n}\nclass SingleAxisSortStrategy {\n  _dragDropRegistry;\n  _element;\n  _sortPredicate;\n  _itemPositions = [];\n  _activeDraggables;\n  orientation = 'vertical';\n  direction;\n  constructor(_dragDropRegistry) {\n    this._dragDropRegistry = _dragDropRegistry;\n  }\n  _previousSwap = {\n    drag: null,\n    delta: 0,\n    overlaps: false\n  };\n  start(items) {\n    this.withItems(items);\n  }\n  sort(item, pointerX, pointerY, pointerDelta) {\n    const siblings = this._itemPositions;\n    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n    if (newIndex === -1 && siblings.length > 0) {\n      return null;\n    }\n    const isHorizontal = this.orientation === 'horizontal';\n    const currentIndex = siblings.findIndex(currentItem => currentItem.drag === item);\n    const siblingAtNewPosition = siblings[newIndex];\n    const currentPosition = siblings[currentIndex].clientRect;\n    const newPosition = siblingAtNewPosition.clientRect;\n    const delta = currentIndex > newIndex ? 1 : -1;\n    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n    const oldOrder = siblings.slice();\n    moveItemInArray(siblings, currentIndex, newIndex);\n    siblings.forEach((sibling, index) => {\n      if (oldOrder[index] === sibling) {\n        return;\n      }\n      const isDraggedItem = sibling.drag === item;\n      const offset = isDraggedItem ? itemOffset : siblingOffset;\n      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();\n      sibling.offset += offset;\n      const transformAmount = Math.round(sibling.offset * (1 / sibling.drag.scale));\n      if (isHorizontal) {\n        elementToOffset.style.transform = combineTransforms(`translate3d(${transformAmount}px, 0, 0)`, sibling.initialTransform);\n        adjustDomRect(sibling.clientRect, 0, offset);\n      } else {\n        elementToOffset.style.transform = combineTransforms(`translate3d(0, ${transformAmount}px, 0)`, sibling.initialTransform);\n        adjustDomRect(sibling.clientRect, offset, 0);\n      }\n    });\n    this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);\n    this._previousSwap.drag = siblingAtNewPosition.drag;\n    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n    return {\n      previousIndex: currentIndex,\n      currentIndex: newIndex\n    };\n  }\n  enter(item, pointerX, pointerY, index) {\n    const newIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;\n    const activeDraggables = this._activeDraggables;\n    const currentIndex = activeDraggables.indexOf(item);\n    const placeholder = item.getPlaceholderElement();\n    let newPositionReference = activeDraggables[newIndex];\n    if (newPositionReference === item) {\n      newPositionReference = activeDraggables[newIndex + 1];\n    }\n    if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {\n      newPositionReference = activeDraggables[0];\n    }\n    if (currentIndex > -1) {\n      activeDraggables.splice(currentIndex, 1);\n    }\n    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n      const element = newPositionReference.getRootElement();\n      element.parentElement.insertBefore(placeholder, element);\n      activeDraggables.splice(newIndex, 0, item);\n    } else {\n      this._element.appendChild(placeholder);\n      activeDraggables.push(item);\n    }\n    placeholder.style.transform = '';\n    this._cacheItemPositions();\n  }\n  withItems(items) {\n    this._activeDraggables = items.slice();\n    this._cacheItemPositions();\n  }\n  withSortPredicate(predicate) {\n    this._sortPredicate = predicate;\n  }\n  reset() {\n    this._activeDraggables?.forEach(item => {\n      const rootElement = item.getRootElement();\n      if (rootElement) {\n        const initialTransform = this._itemPositions.find(p => p.drag === item)?.initialTransform;\n        rootElement.style.transform = initialTransform || '';\n      }\n    });\n    this._itemPositions = [];\n    this._activeDraggables = [];\n    this._previousSwap.drag = null;\n    this._previousSwap.delta = 0;\n    this._previousSwap.overlaps = false;\n  }\n  getActiveItemsSnapshot() {\n    return this._activeDraggables;\n  }\n  getItemIndex(item) {\n    return this._getVisualItemPositions().findIndex(currentItem => currentItem.drag === item);\n  }\n  getItemAtIndex(index) {\n    return this._getVisualItemPositions()[index]?.drag || null;\n  }\n  updateOnScroll(topDifference, leftDifference) {\n    this._itemPositions.forEach(({\n      clientRect\n    }) => {\n      adjustDomRect(clientRect, topDifference, leftDifference);\n    });\n    this._itemPositions.forEach(({\n      drag\n    }) => {\n      if (this._dragDropRegistry.isDragging(drag)) {\n        drag._sortFromLastPointerPosition();\n      }\n    });\n  }\n  withElementContainer(container) {\n    this._element = container;\n  }\n  _cacheItemPositions() {\n    const isHorizontal = this.orientation === 'horizontal';\n    this._itemPositions = this._activeDraggables.map(drag => {\n      const elementToMeasure = drag.getVisibleElement();\n      return {\n        drag,\n        offset: 0,\n        initialTransform: elementToMeasure.style.transform || '',\n        clientRect: getMutableClientRect(elementToMeasure)\n      };\n    }).sort((a, b) => {\n      return isHorizontal ? a.clientRect.left - b.clientRect.left : a.clientRect.top - b.clientRect.top;\n    });\n  }\n  _getVisualItemPositions() {\n    return this.orientation === 'horizontal' && this.direction === 'rtl' ? this._itemPositions.slice().reverse() : this._itemPositions;\n  }\n  _getItemOffsetPx(currentPosition, newPosition, delta) {\n    const isHorizontal = this.orientation === 'horizontal';\n    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;\n    if (delta === -1) {\n      itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;\n    }\n    return itemOffset;\n  }\n  _getSiblingOffsetPx(currentIndex, siblings, delta) {\n    const isHorizontal = this.orientation === 'horizontal';\n    const currentPosition = siblings[currentIndex].clientRect;\n    const immediateSibling = siblings[currentIndex + delta * -1];\n    let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n    if (immediateSibling) {\n      const start = isHorizontal ? 'left' : 'top';\n      const end = isHorizontal ? 'right' : 'bottom';\n      if (delta === -1) {\n        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n      } else {\n        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n      }\n    }\n    return siblingOffset;\n  }\n  _shouldEnterAsFirstChild(pointerX, pointerY) {\n    if (!this._activeDraggables.length) {\n      return false;\n    }\n    const itemPositions = this._itemPositions;\n    const isHorizontal = this.orientation === 'horizontal';\n    const reversed = itemPositions[0].drag !== this._activeDraggables[0];\n    if (reversed) {\n      const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;\n      return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;\n    } else {\n      const firstItemRect = itemPositions[0].clientRect;\n      return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;\n    }\n  }\n  _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n    const isHorizontal = this.orientation === 'horizontal';\n    const index = this._itemPositions.findIndex(({\n      drag,\n      clientRect\n    }) => {\n      if (drag === item) {\n        return false;\n      }\n      if (delta) {\n        const direction = isHorizontal ? delta.x : delta.y;\n        if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {\n          return false;\n        }\n      }\n      return isHorizontal ? pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);\n    });\n    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;\n  }\n}\nclass MixedSortStrategy {\n  _document;\n  _dragDropRegistry;\n  _element;\n  _sortPredicate;\n  _rootNode;\n  _activeItems;\n  _previousSwap = {\n    drag: null,\n    deltaX: 0,\n    deltaY: 0,\n    overlaps: false\n  };\n  _relatedNodes = [];\n  constructor(_document, _dragDropRegistry) {\n    this._document = _document;\n    this._dragDropRegistry = _dragDropRegistry;\n  }\n  start(items) {\n    const childNodes = this._element.childNodes;\n    this._relatedNodes = [];\n    for (let i = 0; i < childNodes.length; i++) {\n      const node = childNodes[i];\n      this._relatedNodes.push([node, node.nextSibling]);\n    }\n    this.withItems(items);\n  }\n  sort(item, pointerX, pointerY, pointerDelta) {\n    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n    const previousSwap = this._previousSwap;\n    if (newIndex === -1 || this._activeItems[newIndex] === item) {\n      return null;\n    }\n    const toSwapWith = this._activeItems[newIndex];\n    if (previousSwap.drag === toSwapWith && previousSwap.overlaps && previousSwap.deltaX === pointerDelta.x && previousSwap.deltaY === pointerDelta.y) {\n      return null;\n    }\n    const previousIndex = this.getItemIndex(item);\n    const current = item.getPlaceholderElement();\n    const overlapElement = toSwapWith.getRootElement();\n    if (newIndex > previousIndex) {\n      overlapElement.after(current);\n    } else {\n      overlapElement.before(current);\n    }\n    moveItemInArray(this._activeItems, previousIndex, newIndex);\n    const newOverlapElement = this._getRootNode().elementFromPoint(pointerX, pointerY);\n    previousSwap.deltaX = pointerDelta.x;\n    previousSwap.deltaY = pointerDelta.y;\n    previousSwap.drag = toSwapWith;\n    previousSwap.overlaps = overlapElement === newOverlapElement || overlapElement.contains(newOverlapElement);\n    return {\n      previousIndex,\n      currentIndex: newIndex\n    };\n  }\n  enter(item, pointerX, pointerY, index) {\n    const currentIndex = this._activeItems.indexOf(item);\n    if (currentIndex > -1) {\n      this._activeItems.splice(currentIndex, 1);\n    }\n    let enterIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;\n    if (enterIndex === -1) {\n      enterIndex = this._getClosestItemIndexToPointer(item, pointerX, pointerY);\n    }\n    const targetItem = this._activeItems[enterIndex];\n    if (targetItem && !this._dragDropRegistry.isDragging(targetItem)) {\n      this._activeItems.splice(enterIndex, 0, item);\n      targetItem.getRootElement().before(item.getPlaceholderElement());\n    } else {\n      this._activeItems.push(item);\n      this._element.appendChild(item.getPlaceholderElement());\n    }\n  }\n  withItems(items) {\n    this._activeItems = items.slice();\n  }\n  withSortPredicate(predicate) {\n    this._sortPredicate = predicate;\n  }\n  reset() {\n    const root = this._element;\n    const previousSwap = this._previousSwap;\n    for (let i = this._relatedNodes.length - 1; i > -1; i--) {\n      const [node, nextSibling] = this._relatedNodes[i];\n      if (node.parentNode === root && node.nextSibling !== nextSibling) {\n        if (nextSibling === null) {\n          root.appendChild(node);\n        } else if (nextSibling.parentNode === root) {\n          root.insertBefore(node, nextSibling);\n        }\n      }\n    }\n    this._relatedNodes = [];\n    this._activeItems = [];\n    previousSwap.drag = null;\n    previousSwap.deltaX = previousSwap.deltaY = 0;\n    previousSwap.overlaps = false;\n  }\n  getActiveItemsSnapshot() {\n    return this._activeItems;\n  }\n  getItemIndex(item) {\n    return this._activeItems.indexOf(item);\n  }\n  getItemAtIndex(index) {\n    return this._activeItems[index] || null;\n  }\n  updateOnScroll() {\n    this._activeItems.forEach(item => {\n      if (this._dragDropRegistry.isDragging(item)) {\n        item._sortFromLastPointerPosition();\n      }\n    });\n  }\n  withElementContainer(container) {\n    if (container !== this._element) {\n      this._element = container;\n      this._rootNode = undefined;\n    }\n  }\n  _getItemIndexFromPointerPosition(item, pointerX, pointerY) {\n    const elementAtPoint = this._getRootNode().elementFromPoint(Math.floor(pointerX), Math.floor(pointerY));\n    const index = elementAtPoint ? this._activeItems.findIndex(item => {\n      const root = item.getRootElement();\n      return elementAtPoint === root || root.contains(elementAtPoint);\n    }) : -1;\n    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;\n  }\n  _getRootNode() {\n    if (!this._rootNode) {\n      this._rootNode = _getShadowRoot(this._element) || this._document;\n    }\n    return this._rootNode;\n  }\n  _getClosestItemIndexToPointer(item, pointerX, pointerY) {\n    if (this._activeItems.length === 0) {\n      return -1;\n    }\n    if (this._activeItems.length === 1) {\n      return 0;\n    }\n    let minDistance = Infinity;\n    let minIndex = -1;\n    for (let i = 0; i < this._activeItems.length; i++) {\n      const current = this._activeItems[i];\n      if (current !== item) {\n        const {\n          x,\n          y\n        } = current.getRootElement().getBoundingClientRect();\n        const distance = Math.hypot(pointerX - x, pointerY - y);\n        if (distance < minDistance) {\n          minDistance = distance;\n          minIndex = i;\n        }\n      }\n    }\n    return minIndex;\n  }\n}\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\nvar AutoScrollVerticalDirection = /*#__PURE__*/function (AutoScrollVerticalDirection) {\n  AutoScrollVerticalDirection[AutoScrollVerticalDirection[\"NONE\"] = 0] = \"NONE\";\n  AutoScrollVerticalDirection[AutoScrollVerticalDirection[\"UP\"] = 1] = \"UP\";\n  AutoScrollVerticalDirection[AutoScrollVerticalDirection[\"DOWN\"] = 2] = \"DOWN\";\n  return AutoScrollVerticalDirection;\n}(AutoScrollVerticalDirection || {});\nvar AutoScrollHorizontalDirection = /*#__PURE__*/function (AutoScrollHorizontalDirection) {\n  AutoScrollHorizontalDirection[AutoScrollHorizontalDirection[\"NONE\"] = 0] = \"NONE\";\n  AutoScrollHorizontalDirection[AutoScrollHorizontalDirection[\"LEFT\"] = 1] = \"LEFT\";\n  AutoScrollHorizontalDirection[AutoScrollHorizontalDirection[\"RIGHT\"] = 2] = \"RIGHT\";\n  return AutoScrollHorizontalDirection;\n}(AutoScrollHorizontalDirection || {});\nclass DropListRef {\n  _dragDropRegistry;\n  _ngZone;\n  _viewportRuler;\n  element;\n  disabled = false;\n  sortingDisabled = false;\n  lockAxis = null;\n  autoScrollDisabled = false;\n  autoScrollStep = 2;\n  hasAnchor = false;\n  enterPredicate = () => true;\n  sortPredicate = () => true;\n  beforeStarted = /*#__PURE__*/new Subject();\n  entered = /*#__PURE__*/new Subject();\n  exited = /*#__PURE__*/new Subject();\n  dropped = /*#__PURE__*/new Subject();\n  sorted = /*#__PURE__*/new Subject();\n  receivingStarted = /*#__PURE__*/new Subject();\n  receivingStopped = /*#__PURE__*/new Subject();\n  data;\n  _container;\n  _isDragging = false;\n  _parentPositions;\n  _sortStrategy;\n  _domRect;\n  _draggables = [];\n  _siblings = [];\n  _activeSiblings = /*#__PURE__*/new Set();\n  _viewportScrollSubscription = Subscription.EMPTY;\n  _verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n  _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n  _scrollNode;\n  _stopScrollTimers = /*#__PURE__*/new Subject();\n  _cachedShadowRoot = null;\n  _document;\n  _scrollableElements = [];\n  _initialScrollSnap;\n  _direction = 'ltr';\n  constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {\n    this._dragDropRegistry = _dragDropRegistry;\n    this._ngZone = _ngZone;\n    this._viewportRuler = _viewportRuler;\n    const coercedElement = this.element = coerceElement(element);\n    this._document = _document;\n    this.withOrientation('vertical').withElementContainer(coercedElement);\n    _dragDropRegistry.registerDropContainer(this);\n    this._parentPositions = new ParentPositionTracker(_document);\n  }\n  dispose() {\n    this._stopScrolling();\n    this._stopScrollTimers.complete();\n    this._viewportScrollSubscription.unsubscribe();\n    this.beforeStarted.complete();\n    this.entered.complete();\n    this.exited.complete();\n    this.dropped.complete();\n    this.sorted.complete();\n    this.receivingStarted.complete();\n    this.receivingStopped.complete();\n    this._activeSiblings.clear();\n    this._scrollNode = null;\n    this._parentPositions.clear();\n    this._dragDropRegistry.removeDropContainer(this);\n  }\n  isDragging() {\n    return this._isDragging;\n  }\n  start() {\n    this._draggingStarted();\n    this._notifyReceivingSiblings();\n  }\n  enter(item, pointerX, pointerY, index) {\n    this._draggingStarted();\n    if (index == null && this.sortingDisabled) {\n      index = this._draggables.indexOf(item);\n    }\n    this._sortStrategy.enter(item, pointerX, pointerY, index);\n    this._cacheParentPositions();\n    this._notifyReceivingSiblings();\n    this.entered.next({\n      item,\n      container: this,\n      currentIndex: this.getItemIndex(item)\n    });\n  }\n  exit(item) {\n    this._reset();\n    this.exited.next({\n      item,\n      container: this\n    });\n  }\n  drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {\n    this._reset();\n    this.dropped.next({\n      item,\n      currentIndex,\n      previousIndex,\n      container: this,\n      previousContainer,\n      isPointerOverContainer,\n      distance,\n      dropPoint,\n      event\n    });\n  }\n  withItems(items) {\n    const previousItems = this._draggables;\n    this._draggables = items;\n    items.forEach(item => item._withDropContainer(this));\n    if (this.isDragging()) {\n      const draggedItems = previousItems.filter(item => item.isDragging());\n      if (draggedItems.every(item => items.indexOf(item) === -1)) {\n        this._reset();\n      } else {\n        this._sortStrategy.withItems(this._draggables);\n      }\n    }\n    return this;\n  }\n  withDirection(direction) {\n    this._direction = direction;\n    if (this._sortStrategy instanceof SingleAxisSortStrategy) {\n      this._sortStrategy.direction = direction;\n    }\n    return this;\n  }\n  connectedTo(connectedTo) {\n    this._siblings = connectedTo.slice();\n    return this;\n  }\n  withOrientation(orientation) {\n    if (orientation === 'mixed') {\n      this._sortStrategy = new MixedSortStrategy(this._document, this._dragDropRegistry);\n    } else {\n      const strategy = new SingleAxisSortStrategy(this._dragDropRegistry);\n      strategy.direction = this._direction;\n      strategy.orientation = orientation;\n      this._sortStrategy = strategy;\n    }\n    this._sortStrategy.withElementContainer(this._container);\n    this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));\n    return this;\n  }\n  withScrollableParents(elements) {\n    const element = this._container;\n    this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();\n    return this;\n  }\n  withElementContainer(container) {\n    if (container === this._container) {\n      return this;\n    }\n    const element = coerceElement(this.element);\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && container !== element && !element.contains(container)) {\n      throw new Error('Invalid DOM structure for drop list. Alternate container element must be a descendant of the drop list.');\n    }\n    const oldContainerIndex = this._scrollableElements.indexOf(this._container);\n    const newContainerIndex = this._scrollableElements.indexOf(container);\n    if (oldContainerIndex > -1) {\n      this._scrollableElements.splice(oldContainerIndex, 1);\n    }\n    if (newContainerIndex > -1) {\n      this._scrollableElements.splice(newContainerIndex, 1);\n    }\n    if (this._sortStrategy) {\n      this._sortStrategy.withElementContainer(container);\n    }\n    this._cachedShadowRoot = null;\n    this._scrollableElements.unshift(container);\n    this._container = container;\n    return this;\n  }\n  getScrollableParents() {\n    return this._scrollableElements;\n  }\n  getItemIndex(item) {\n    return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);\n  }\n  getItemAtIndex(index) {\n    return this._isDragging ? this._sortStrategy.getItemAtIndex(index) : this._draggables[index] || null;\n  }\n  isReceiving() {\n    return this._activeSiblings.size > 0;\n  }\n  _sortItem(item, pointerX, pointerY, pointerDelta) {\n    if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {\n      return;\n    }\n    const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);\n    if (result) {\n      this.sorted.next({\n        previousIndex: result.previousIndex,\n        currentIndex: result.currentIndex,\n        container: this,\n        item\n      });\n    }\n  }\n  _startScrollingIfNecessary(pointerX, pointerY) {\n    if (this.autoScrollDisabled) {\n      return;\n    }\n    let scrollNode;\n    let verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n    let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n    this._parentPositions.positions.forEach((position, element) => {\n      if (element === this._document || !position.clientRect || scrollNode) {\n        return;\n      }\n      if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {\n        [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._direction, pointerX, pointerY);\n        if (verticalScrollDirection || horizontalScrollDirection) {\n          scrollNode = element;\n        }\n      }\n    });\n    if (!verticalScrollDirection && !horizontalScrollDirection) {\n      const {\n        width,\n        height\n      } = this._viewportRuler.getViewportSize();\n      const domRect = {\n        width,\n        height,\n        top: 0,\n        right: width,\n        bottom: height,\n        left: 0\n      };\n      verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);\n      horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);\n      scrollNode = window;\n    }\n    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {\n      this._verticalScrollDirection = verticalScrollDirection;\n      this._horizontalScrollDirection = horizontalScrollDirection;\n      this._scrollNode = scrollNode;\n      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n        this._ngZone.runOutsideAngular(this._startScrollInterval);\n      } else {\n        this._stopScrolling();\n      }\n    }\n  }\n  _stopScrolling() {\n    this._stopScrollTimers.next();\n  }\n  _draggingStarted() {\n    const styles = this._container.style;\n    this.beforeStarted.next();\n    this._isDragging = true;\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && this._container !== coerceElement(this.element)) {\n      for (const drag of this._draggables) {\n        if (!drag.isDragging() && drag.getVisibleElement().parentNode !== this._container) {\n          throw new Error('Invalid DOM structure for drop list. All items must be placed directly inside of the element container.');\n        }\n      }\n    }\n    this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || '';\n    styles.scrollSnapType = styles.msScrollSnapType = 'none';\n    this._sortStrategy.start(this._draggables);\n    this._cacheParentPositions();\n    this._viewportScrollSubscription.unsubscribe();\n    this._listenToScrollEvents();\n  }\n  _cacheParentPositions() {\n    this._parentPositions.cache(this._scrollableElements);\n    this._domRect = this._parentPositions.positions.get(this._container).clientRect;\n  }\n  _reset() {\n    this._isDragging = false;\n    const styles = this._container.style;\n    styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;\n    this._siblings.forEach(sibling => sibling._stopReceiving(this));\n    this._sortStrategy.reset();\n    this._stopScrolling();\n    this._viewportScrollSubscription.unsubscribe();\n    this._parentPositions.clear();\n  }\n  _startScrollInterval = () => {\n    this._stopScrolling();\n    interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {\n      const node = this._scrollNode;\n      const scrollStep = this.autoScrollStep;\n      if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {\n        node.scrollBy(0, -scrollStep);\n      } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {\n        node.scrollBy(0, scrollStep);\n      }\n      if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {\n        node.scrollBy(-scrollStep, 0);\n      } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {\n        node.scrollBy(scrollStep, 0);\n      }\n    });\n  };\n  _isOverContainer(x, y) {\n    return this._domRect != null && isInsideClientRect(this._domRect, x, y);\n  }\n  _getSiblingContainerFromPosition(item, x, y) {\n    return this._siblings.find(sibling => sibling._canReceive(item, x, y));\n  }\n  _canReceive(item, x, y) {\n    if (!this._domRect || !isInsideClientRect(this._domRect, x, y) || !this.enterPredicate(item, this)) {\n      return false;\n    }\n    const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);\n    if (!elementFromPoint) {\n      return false;\n    }\n    return elementFromPoint === this._container || this._container.contains(elementFromPoint);\n  }\n  _startReceiving(sibling, items) {\n    const activeSiblings = this._activeSiblings;\n    if (!activeSiblings.has(sibling) && items.every(item => {\n      return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;\n    })) {\n      activeSiblings.add(sibling);\n      this._cacheParentPositions();\n      this._listenToScrollEvents();\n      this.receivingStarted.next({\n        initiator: sibling,\n        receiver: this,\n        items\n      });\n    }\n  }\n  _stopReceiving(sibling) {\n    this._activeSiblings.delete(sibling);\n    this._viewportScrollSubscription.unsubscribe();\n    this.receivingStopped.next({\n      initiator: sibling,\n      receiver: this\n    });\n  }\n  _listenToScrollEvents() {\n    this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(event => {\n      if (this.isDragging()) {\n        const scrollDifference = this._parentPositions.handleScroll(event);\n        if (scrollDifference) {\n          this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);\n        }\n      } else if (this.isReceiving()) {\n        this._cacheParentPositions();\n      }\n    });\n  }\n  _getShadowRoot() {\n    if (!this._cachedShadowRoot) {\n      const shadowRoot = _getShadowRoot(this._container);\n      this._cachedShadowRoot = shadowRoot || this._document;\n    }\n    return this._cachedShadowRoot;\n  }\n  _notifyReceivingSiblings() {\n    const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter(item => item.isDragging());\n    this._siblings.forEach(sibling => sibling._startReceiving(this, draggedItems));\n  }\n}\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n  const {\n    top,\n    bottom,\n    height\n  } = clientRect;\n  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n    return AutoScrollVerticalDirection.UP;\n  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n    return AutoScrollVerticalDirection.DOWN;\n  }\n  return AutoScrollVerticalDirection.NONE;\n}\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n  const {\n    left,\n    right,\n    width\n  } = clientRect;\n  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n    return AutoScrollHorizontalDirection.LEFT;\n  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n    return AutoScrollHorizontalDirection.RIGHT;\n  }\n  return AutoScrollHorizontalDirection.NONE;\n}\nfunction getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {\n  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n  if (computedVertical) {\n    const scrollTop = element.scrollTop;\n    if (computedVertical === AutoScrollVerticalDirection.UP) {\n      if (scrollTop > 0) {\n        verticalScrollDirection = AutoScrollVerticalDirection.UP;\n      }\n    } else if (element.scrollHeight - scrollTop > element.clientHeight) {\n      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;\n    }\n  }\n  if (computedHorizontal) {\n    const scrollLeft = element.scrollLeft;\n    if (direction === 'rtl') {\n      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {\n        if (scrollLeft < 0) {\n          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;\n        }\n      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {\n        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;\n      }\n    } else {\n      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {\n        if (scrollLeft > 0) {\n          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;\n        }\n      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;\n      }\n    }\n  }\n  return [verticalScrollDirection, horizontalScrollDirection];\n}\nconst capturingEventOptions = {\n  capture: true\n};\nconst activeCapturingEventOptions = {\n  passive: false,\n  capture: true\n};\nlet _ResetsLoader = /*#__PURE__*/(() => {\n  class _ResetsLoader {\n    static ɵfac = function _ResetsLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _ResetsLoader)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: _ResetsLoader,\n      selectors: [[\"ng-component\"]],\n      hostAttrs: [\"cdk-drag-resets-container\", \"\"],\n      decls: 0,\n      vars: 0,\n      template: function _ResetsLoader_Template(rf, ctx) {},\n      styles: [\"@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return _ResetsLoader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DragDropRegistry = /*#__PURE__*/(() => {\n  class DragDropRegistry {\n    _ngZone = inject(NgZone);\n    _document = inject(DOCUMENT);\n    _styleLoader = inject(_CdkPrivateStyleLoader);\n    _renderer = inject(RendererFactory2).createRenderer(null, null);\n    _cleanupDocumentTouchmove;\n    _scroll = new Subject();\n    _dropInstances = new Set();\n    _dragInstances = new Set();\n    _activeDragInstances = signal([], ...(ngDevMode ? [{\n      debugName: \"_activeDragInstances\"\n    }] : []));\n    _globalListeners;\n    _draggingPredicate = item => item.isDragging();\n    _domNodesToDirectives = null;\n    pointerMove = new Subject();\n    pointerUp = new Subject();\n    constructor() {}\n    registerDropContainer(drop) {\n      if (!this._dropInstances.has(drop)) {\n        this._dropInstances.add(drop);\n      }\n    }\n    registerDragItem(drag) {\n      this._dragInstances.add(drag);\n      if (this._dragInstances.size === 1) {\n        this._ngZone.runOutsideAngular(() => {\n          this._cleanupDocumentTouchmove?.();\n          this._cleanupDocumentTouchmove = this._renderer.listen(this._document, 'touchmove', this._persistentTouchmoveListener, activeCapturingEventOptions);\n        });\n      }\n    }\n    removeDropContainer(drop) {\n      this._dropInstances.delete(drop);\n    }\n    removeDragItem(drag) {\n      this._dragInstances.delete(drag);\n      this.stopDragging(drag);\n      if (this._dragInstances.size === 0) {\n        this._cleanupDocumentTouchmove?.();\n      }\n    }\n    startDragging(drag, event) {\n      if (this._activeDragInstances().indexOf(drag) > -1) {\n        return;\n      }\n      this._styleLoader.load(_ResetsLoader);\n      this._activeDragInstances.update(instances => [...instances, drag]);\n      if (this._activeDragInstances().length === 1) {\n        const isTouchEvent = event.type.startsWith('touch');\n        const endEventHandler = e => this.pointerUp.next(e);\n        const toBind = [['scroll', e => this._scroll.next(e), capturingEventOptions], ['selectstart', this._preventDefaultWhileDragging, activeCapturingEventOptions]];\n        if (isTouchEvent) {\n          toBind.push(['touchend', endEventHandler, capturingEventOptions], ['touchcancel', endEventHandler, capturingEventOptions]);\n        } else {\n          toBind.push(['mouseup', endEventHandler, capturingEventOptions]);\n        }\n        if (!isTouchEvent) {\n          toBind.push(['mousemove', e => this.pointerMove.next(e), activeCapturingEventOptions]);\n        }\n        this._ngZone.runOutsideAngular(() => {\n          this._globalListeners = toBind.map(([name, handler, options]) => this._renderer.listen(this._document, name, handler, options));\n        });\n      }\n    }\n    stopDragging(drag) {\n      this._activeDragInstances.update(instances => {\n        const index = instances.indexOf(drag);\n        if (index > -1) {\n          instances.splice(index, 1);\n          return [...instances];\n        }\n        return instances;\n      });\n      if (this._activeDragInstances().length === 0) {\n        this._clearGlobalListeners();\n      }\n    }\n    isDragging(drag) {\n      return this._activeDragInstances().indexOf(drag) > -1;\n    }\n    scrolled(shadowRoot) {\n      const streams = [this._scroll];\n      if (shadowRoot && shadowRoot !== this._document) {\n        streams.push(new Observable(observer => {\n          return this._ngZone.runOutsideAngular(() => {\n            const cleanup = this._renderer.listen(shadowRoot, 'scroll', event => {\n              if (this._activeDragInstances().length) {\n                observer.next(event);\n              }\n            }, capturingEventOptions);\n            return () => {\n              cleanup();\n            };\n          });\n        }));\n      }\n      return merge(...streams);\n    }\n    registerDirectiveNode(node, dragRef) {\n      this._domNodesToDirectives ??= new WeakMap();\n      this._domNodesToDirectives.set(node, dragRef);\n    }\n    removeDirectiveNode(node) {\n      this._domNodesToDirectives?.delete(node);\n    }\n    getDragDirectiveForNode(node) {\n      return this._domNodesToDirectives?.get(node) || null;\n    }\n    ngOnDestroy() {\n      this._dragInstances.forEach(instance => this.removeDragItem(instance));\n      this._dropInstances.forEach(instance => this.removeDropContainer(instance));\n      this._domNodesToDirectives = null;\n      this._clearGlobalListeners();\n      this.pointerMove.complete();\n      this.pointerUp.complete();\n    }\n    _preventDefaultWhileDragging = event => {\n      if (this._activeDragInstances().length > 0) {\n        event.preventDefault();\n      }\n    };\n    _persistentTouchmoveListener = event => {\n      if (this._activeDragInstances().length > 0) {\n        if (this._activeDragInstances().some(this._draggingPredicate)) {\n          event.preventDefault();\n        }\n        this.pointerMove.next(event);\n      }\n    };\n    _clearGlobalListeners() {\n      this._globalListeners?.forEach(cleanup => cleanup());\n      this._globalListeners = undefined;\n    }\n    static ɵfac = function DragDropRegistry_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DragDropRegistry)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DragDropRegistry,\n      factory: DragDropRegistry.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DragDropRegistry;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_CONFIG = {\n  dragStartThreshold: 5,\n  pointerDirectionChangeThreshold: 5\n};\nlet DragDrop = /*#__PURE__*/(() => {\n  class DragDrop {\n    _document = inject(DOCUMENT);\n    _ngZone = inject(NgZone);\n    _viewportRuler = inject(ViewportRuler);\n    _dragDropRegistry = inject(DragDropRegistry);\n    _renderer = inject(RendererFactory2).createRenderer(null, null);\n    constructor() {}\n    createDrag(element, config = DEFAULT_CONFIG) {\n      return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);\n    }\n    createDropList(element) {\n      return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);\n    }\n    static ɵfac = function DragDrop_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DragDrop)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DragDrop,\n      factory: DragDrop.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DragDrop;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CDK_DRAG_PARENT = /*#__PURE__*/new InjectionToken('CDK_DRAG_PARENT');\nfunction assertElementNode(node, name) {\n  if (node.nodeType !== 1) {\n    throw Error(`${name} must be attached to an element node. ` + `Currently attached to \"${node.nodeName}\".`);\n  }\n}\nconst CDK_DRAG_HANDLE = /*#__PURE__*/new InjectionToken('CdkDragHandle');\nlet CdkDragHandle = /*#__PURE__*/(() => {\n  class CdkDragHandle {\n    element = inject(ElementRef);\n    _parentDrag = inject(CDK_DRAG_PARENT, {\n      optional: true,\n      skipSelf: true\n    });\n    _dragDropRegistry = inject(DragDropRegistry);\n    _stateChanges = new Subject();\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = value;\n      this._stateChanges.next(this);\n    }\n    _disabled = false;\n    constructor() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        assertElementNode(this.element.nativeElement, 'cdkDragHandle');\n      }\n      this._parentDrag?._addHandle(this);\n    }\n    ngAfterViewInit() {\n      if (!this._parentDrag) {\n        let parent = this.element.nativeElement.parentElement;\n        while (parent) {\n          const ref = this._dragDropRegistry.getDragDirectiveForNode(parent);\n          if (ref) {\n            this._parentDrag = ref;\n            ref._addHandle(this);\n            break;\n          }\n          parent = parent.parentElement;\n        }\n      }\n    }\n    ngOnDestroy() {\n      this._parentDrag?._removeHandle(this);\n      this._stateChanges.complete();\n    }\n    static ɵfac = function CdkDragHandle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkDragHandle)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkDragHandle,\n      selectors: [[\"\", \"cdkDragHandle\", \"\"]],\n      hostAttrs: [1, \"cdk-drag-handle\"],\n      inputs: {\n        disabled: [2, \"cdkDragHandleDisabled\", \"disabled\", booleanAttribute]\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CDK_DRAG_HANDLE,\n        useExisting: CdkDragHandle\n      }])]\n    });\n  }\n  return CdkDragHandle;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CDK_DRAG_CONFIG = /*#__PURE__*/new InjectionToken('CDK_DRAG_CONFIG');\nconst CDK_DROP_LIST = /*#__PURE__*/new InjectionToken('CdkDropList');\nlet CdkDrag = /*#__PURE__*/(() => {\n  class CdkDrag {\n    element = inject(ElementRef);\n    dropContainer = inject(CDK_DROP_LIST, {\n      optional: true,\n      skipSelf: true\n    });\n    _ngZone = inject(NgZone);\n    _viewContainerRef = inject(ViewContainerRef);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _selfHandle = inject(CDK_DRAG_HANDLE, {\n      optional: true,\n      self: true\n    });\n    _parentDrag = inject(CDK_DRAG_PARENT, {\n      optional: true,\n      skipSelf: true\n    });\n    _dragDropRegistry = inject(DragDropRegistry);\n    _destroyed = new Subject();\n    _handles = new BehaviorSubject([]);\n    _previewTemplate;\n    _placeholderTemplate;\n    _dragRef;\n    data;\n    lockAxis = null;\n    rootElementSelector;\n    boundaryElement;\n    dragStartDelay;\n    freeDragPosition;\n    get disabled() {\n      return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);\n    }\n    set disabled(value) {\n      this._disabled = value;\n      this._dragRef.disabled = this._disabled;\n    }\n    _disabled;\n    constrainPosition;\n    previewClass;\n    previewContainer;\n    scale = 1;\n    started = new EventEmitter();\n    released = new EventEmitter();\n    ended = new EventEmitter();\n    entered = new EventEmitter();\n    exited = new EventEmitter();\n    dropped = new EventEmitter();\n    moved = new Observable(observer => {\n      const subscription = this._dragRef.moved.pipe(map(movedEvent => ({\n        source: this,\n        pointerPosition: movedEvent.pointerPosition,\n        event: movedEvent.event,\n        delta: movedEvent.delta,\n        distance: movedEvent.distance\n      }))).subscribe(observer);\n      return () => {\n        subscription.unsubscribe();\n      };\n    });\n    _injector = inject(Injector);\n    constructor() {\n      const dropContainer = this.dropContainer;\n      const config = inject(CDK_DRAG_CONFIG, {\n        optional: true\n      });\n      const dragDrop = inject(DragDrop);\n      this._dragRef = dragDrop.createDrag(this.element, {\n        dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,\n        pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ? config.pointerDirectionChangeThreshold : 5,\n        zIndex: config?.zIndex\n      });\n      this._dragRef.data = this;\n      this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this);\n      if (config) {\n        this._assignDefaults(config);\n      }\n      if (dropContainer) {\n        dropContainer.addItem(this);\n        dropContainer._dropListRef.beforeStarted.pipe(takeUntil(this._destroyed)).subscribe(() => {\n          this._dragRef.scale = this.scale;\n        });\n      }\n      this._syncInputs(this._dragRef);\n      this._handleEvents(this._dragRef);\n    }\n    getPlaceholderElement() {\n      return this._dragRef.getPlaceholderElement();\n    }\n    getRootElement() {\n      return this._dragRef.getRootElement();\n    }\n    reset() {\n      this._dragRef.reset();\n    }\n    resetToBoundary() {\n      this._dragRef.resetToBoundary();\n    }\n    getFreeDragPosition() {\n      return this._dragRef.getFreeDragPosition();\n    }\n    setFreeDragPosition(value) {\n      this._dragRef.setFreeDragPosition(value);\n    }\n    ngAfterViewInit() {\n      afterNextRender(() => {\n        this._updateRootElement();\n        this._setupHandlesListener();\n        this._dragRef.scale = this.scale;\n        if (this.freeDragPosition) {\n          this._dragRef.setFreeDragPosition(this.freeDragPosition);\n        }\n      }, {\n        injector: this._injector\n      });\n    }\n    ngOnChanges(changes) {\n      const rootSelectorChange = changes['rootElementSelector'];\n      const positionChange = changes['freeDragPosition'];\n      if (rootSelectorChange && !rootSelectorChange.firstChange) {\n        this._updateRootElement();\n      }\n      this._dragRef.scale = this.scale;\n      if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n        this._dragRef.setFreeDragPosition(this.freeDragPosition);\n      }\n    }\n    ngOnDestroy() {\n      if (this.dropContainer) {\n        this.dropContainer.removeItem(this);\n      }\n      this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement);\n      this._ngZone.runOutsideAngular(() => {\n        this._handles.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._dragRef.dispose();\n      });\n    }\n    _addHandle(handle) {\n      const handles = this._handles.getValue();\n      handles.push(handle);\n      this._handles.next(handles);\n    }\n    _removeHandle(handle) {\n      const handles = this._handles.getValue();\n      const index = handles.indexOf(handle);\n      if (index > -1) {\n        handles.splice(index, 1);\n        this._handles.next(handles);\n      }\n    }\n    _setPreviewTemplate(preview) {\n      this._previewTemplate = preview;\n    }\n    _resetPreviewTemplate(preview) {\n      if (preview === this._previewTemplate) {\n        this._previewTemplate = null;\n      }\n    }\n    _setPlaceholderTemplate(placeholder) {\n      this._placeholderTemplate = placeholder;\n    }\n    _resetPlaceholderTemplate(placeholder) {\n      if (placeholder === this._placeholderTemplate) {\n        this._placeholderTemplate = null;\n      }\n    }\n    _updateRootElement() {\n      const element = this.element.nativeElement;\n      let rootElement = element;\n      if (this.rootElementSelector) {\n        rootElement = element.closest !== undefined ? element.closest(this.rootElementSelector) : element.parentElement?.closest(this.rootElementSelector);\n      }\n      if (rootElement && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        assertElementNode(rootElement, 'cdkDrag');\n      }\n      this._dragRef.withRootElement(rootElement || element);\n    }\n    _getBoundaryElement() {\n      const boundary = this.boundaryElement;\n      if (!boundary) {\n        return null;\n      }\n      if (typeof boundary === 'string') {\n        return this.element.nativeElement.closest(boundary);\n      }\n      return coerceElement(boundary);\n    }\n    _syncInputs(ref) {\n      ref.beforeStarted.subscribe(() => {\n        if (!ref.isDragging()) {\n          const dir = this._dir;\n          const dragStartDelay = this.dragStartDelay;\n          const placeholder = this._placeholderTemplate ? {\n            template: this._placeholderTemplate.templateRef,\n            context: this._placeholderTemplate.data,\n            viewContainer: this._viewContainerRef\n          } : null;\n          const preview = this._previewTemplate ? {\n            template: this._previewTemplate.templateRef,\n            context: this._previewTemplate.data,\n            matchSize: this._previewTemplate.matchSize,\n            viewContainer: this._viewContainerRef\n          } : null;\n          ref.disabled = this.disabled;\n          ref.lockAxis = this.lockAxis;\n          ref.scale = this.scale;\n          ref.dragStartDelay = typeof dragStartDelay === 'object' && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);\n          ref.constrainPosition = this.constrainPosition;\n          ref.previewClass = this.previewClass;\n          ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || 'global');\n          if (dir) {\n            ref.withDirection(dir.value);\n          }\n        }\n      });\n      ref.beforeStarted.pipe(take(1)).subscribe(() => {\n        if (this._parentDrag) {\n          ref.withParent(this._parentDrag._dragRef);\n          return;\n        }\n        let parent = this.element.nativeElement.parentElement;\n        while (parent) {\n          const parentDrag = this._dragDropRegistry.getDragDirectiveForNode(parent);\n          if (parentDrag) {\n            ref.withParent(parentDrag._dragRef);\n            break;\n          }\n          parent = parent.parentElement;\n        }\n      });\n    }\n    _handleEvents(ref) {\n      ref.started.subscribe(startEvent => {\n        this.started.emit({\n          source: this,\n          event: startEvent.event\n        });\n        this._changeDetectorRef.markForCheck();\n      });\n      ref.released.subscribe(releaseEvent => {\n        this.released.emit({\n          source: this,\n          event: releaseEvent.event\n        });\n      });\n      ref.ended.subscribe(endEvent => {\n        this.ended.emit({\n          source: this,\n          distance: endEvent.distance,\n          dropPoint: endEvent.dropPoint,\n          event: endEvent.event\n        });\n        this._changeDetectorRef.markForCheck();\n      });\n      ref.entered.subscribe(enterEvent => {\n        this.entered.emit({\n          container: enterEvent.container.data,\n          item: this,\n          currentIndex: enterEvent.currentIndex\n        });\n      });\n      ref.exited.subscribe(exitEvent => {\n        this.exited.emit({\n          container: exitEvent.container.data,\n          item: this\n        });\n      });\n      ref.dropped.subscribe(dropEvent => {\n        this.dropped.emit({\n          previousIndex: dropEvent.previousIndex,\n          currentIndex: dropEvent.currentIndex,\n          previousContainer: dropEvent.previousContainer.data,\n          container: dropEvent.container.data,\n          isPointerOverContainer: dropEvent.isPointerOverContainer,\n          item: this,\n          distance: dropEvent.distance,\n          dropPoint: dropEvent.dropPoint,\n          event: dropEvent.event\n        });\n      });\n    }\n    _assignDefaults(config) {\n      const {\n        lockAxis,\n        dragStartDelay,\n        constrainPosition,\n        previewClass,\n        boundaryElement,\n        draggingDisabled,\n        rootElementSelector,\n        previewContainer\n      } = config;\n      this.disabled = draggingDisabled == null ? false : draggingDisabled;\n      this.dragStartDelay = dragStartDelay || 0;\n      this.lockAxis = lockAxis || null;\n      if (constrainPosition) {\n        this.constrainPosition = constrainPosition;\n      }\n      if (previewClass) {\n        this.previewClass = previewClass;\n      }\n      if (boundaryElement) {\n        this.boundaryElement = boundaryElement;\n      }\n      if (rootElementSelector) {\n        this.rootElementSelector = rootElementSelector;\n      }\n      if (previewContainer) {\n        this.previewContainer = previewContainer;\n      }\n    }\n    _setupHandlesListener() {\n      this._handles.pipe(tap(handles => {\n        const handleElements = handles.map(handle => handle.element);\n        if (this._selfHandle && this.rootElementSelector) {\n          handleElements.push(this.element);\n        }\n        this._dragRef.withHandles(handleElements);\n      }), switchMap(handles => {\n        return merge(...handles.map(item => item._stateChanges.pipe(startWith(item))));\n      }), takeUntil(this._destroyed)).subscribe(handleInstance => {\n        const dragRef = this._dragRef;\n        const handle = handleInstance.element.nativeElement;\n        handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n      });\n    }\n    static ɵfac = function CdkDrag_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkDrag)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkDrag,\n      selectors: [[\"\", \"cdkDrag\", \"\"]],\n      hostAttrs: [1, \"cdk-drag\"],\n      hostVars: 4,\n      hostBindings: function CdkDrag_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"cdk-drag-disabled\", ctx.disabled)(\"cdk-drag-dragging\", ctx._dragRef.isDragging());\n        }\n      },\n      inputs: {\n        data: [0, \"cdkDragData\", \"data\"],\n        lockAxis: [0, \"cdkDragLockAxis\", \"lockAxis\"],\n        rootElementSelector: [0, \"cdkDragRootElement\", \"rootElementSelector\"],\n        boundaryElement: [0, \"cdkDragBoundary\", \"boundaryElement\"],\n        dragStartDelay: [0, \"cdkDragStartDelay\", \"dragStartDelay\"],\n        freeDragPosition: [0, \"cdkDragFreeDragPosition\", \"freeDragPosition\"],\n        disabled: [2, \"cdkDragDisabled\", \"disabled\", booleanAttribute],\n        constrainPosition: [0, \"cdkDragConstrainPosition\", \"constrainPosition\"],\n        previewClass: [0, \"cdkDragPreviewClass\", \"previewClass\"],\n        previewContainer: [0, \"cdkDragPreviewContainer\", \"previewContainer\"],\n        scale: [2, \"cdkDragScale\", \"scale\", numberAttribute]\n      },\n      outputs: {\n        started: \"cdkDragStarted\",\n        released: \"cdkDragReleased\",\n        ended: \"cdkDragEnded\",\n        entered: \"cdkDragEntered\",\n        exited: \"cdkDragExited\",\n        dropped: \"cdkDragDropped\",\n        moved: \"cdkDragMoved\"\n      },\n      exportAs: [\"cdkDrag\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CDK_DRAG_PARENT,\n        useExisting: CdkDrag\n      }]), i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return CdkDrag;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CDK_DROP_LIST_GROUP = /*#__PURE__*/new InjectionToken('CdkDropListGroup');\nlet CdkDropListGroup = /*#__PURE__*/(() => {\n  class CdkDropListGroup {\n    _items = new Set();\n    disabled = false;\n    ngOnDestroy() {\n      this._items.clear();\n    }\n    static ɵfac = function CdkDropListGroup_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkDropListGroup)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkDropListGroup,\n      selectors: [[\"\", \"cdkDropListGroup\", \"\"]],\n      inputs: {\n        disabled: [2, \"cdkDropListGroupDisabled\", \"disabled\", booleanAttribute]\n      },\n      exportAs: [\"cdkDropListGroup\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CDK_DROP_LIST_GROUP,\n        useExisting: CdkDropListGroup\n      }])]\n    });\n  }\n  return CdkDropListGroup;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkDropList = /*#__PURE__*/(() => {\n  class CdkDropList {\n    element = inject(ElementRef);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _scrollDispatcher = inject(ScrollDispatcher);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _group = inject(CDK_DROP_LIST_GROUP, {\n      optional: true,\n      skipSelf: true\n    });\n    _latestSortedRefs;\n    _destroyed = new Subject();\n    _scrollableParentsResolved;\n    static _dropLists = [];\n    _dropListRef;\n    connectedTo = [];\n    data;\n    orientation;\n    id = inject(_IdGenerator).getId('cdk-drop-list-');\n    lockAxis = null;\n    get disabled() {\n      return this._disabled || !!this._group && this._group.disabled;\n    }\n    set disabled(value) {\n      this._dropListRef.disabled = this._disabled = value;\n    }\n    _disabled;\n    sortingDisabled;\n    enterPredicate = () => true;\n    sortPredicate = () => true;\n    autoScrollDisabled;\n    autoScrollStep;\n    elementContainerSelector;\n    hasAnchor;\n    dropped = new EventEmitter();\n    entered = new EventEmitter();\n    exited = new EventEmitter();\n    sorted = new EventEmitter();\n    _unsortedItems = new Set();\n    constructor() {\n      const dragDrop = inject(DragDrop);\n      const config = inject(CDK_DRAG_CONFIG, {\n        optional: true\n      });\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        assertElementNode(this.element.nativeElement, 'cdkDropList');\n      }\n      this._dropListRef = dragDrop.createDropList(this.element);\n      this._dropListRef.data = this;\n      if (config) {\n        this._assignDefaults(config);\n      }\n      this._dropListRef.enterPredicate = (drag, drop) => {\n        return this.enterPredicate(drag.data, drop.data);\n      };\n      this._dropListRef.sortPredicate = (index, drag, drop) => {\n        return this.sortPredicate(index, drag.data, drop.data);\n      };\n      this._setupInputSyncSubscription(this._dropListRef);\n      this._handleEvents(this._dropListRef);\n      CdkDropList._dropLists.push(this);\n      if (this._group) {\n        this._group._items.add(this);\n      }\n    }\n    addItem(item) {\n      this._unsortedItems.add(item);\n      item._dragRef._withDropContainer(this._dropListRef);\n      if (this._dropListRef.isDragging()) {\n        this._syncItemsWithRef(this.getSortedItems().map(item => item._dragRef));\n      }\n    }\n    removeItem(item) {\n      this._unsortedItems.delete(item);\n      if (this._latestSortedRefs) {\n        const index = this._latestSortedRefs.indexOf(item._dragRef);\n        if (index > -1) {\n          this._latestSortedRefs.splice(index, 1);\n          this._syncItemsWithRef(this._latestSortedRefs);\n        }\n      }\n    }\n    getSortedItems() {\n      return Array.from(this._unsortedItems).sort((a, b) => {\n        const documentPosition = a._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement());\n        return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\n      });\n    }\n    ngOnDestroy() {\n      const index = CdkDropList._dropLists.indexOf(this);\n      if (index > -1) {\n        CdkDropList._dropLists.splice(index, 1);\n      }\n      if (this._group) {\n        this._group._items.delete(this);\n      }\n      this._latestSortedRefs = undefined;\n      this._unsortedItems.clear();\n      this._dropListRef.dispose();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    _setupInputSyncSubscription(ref) {\n      if (this._dir) {\n        this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe(value => ref.withDirection(value));\n      }\n      ref.beforeStarted.subscribe(() => {\n        const siblings = coerceArray(this.connectedTo).map(drop => {\n          if (typeof drop === 'string') {\n            const correspondingDropList = CdkDropList._dropLists.find(list => list.id === drop);\n            if (!correspondingDropList && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n              console.warn(`CdkDropList could not find connected drop list with id \"${drop}\"`);\n            }\n            return correspondingDropList;\n          }\n          return drop;\n        });\n        if (this._group) {\n          this._group._items.forEach(drop => {\n            if (siblings.indexOf(drop) === -1) {\n              siblings.push(drop);\n            }\n          });\n        }\n        if (!this._scrollableParentsResolved) {\n          const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map(scrollable => scrollable.getElementRef().nativeElement);\n          this._dropListRef.withScrollableParents(scrollableParents);\n          this._scrollableParentsResolved = true;\n        }\n        if (this.elementContainerSelector) {\n          const container = this.element.nativeElement.querySelector(this.elementContainerSelector);\n          if (!container && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw new Error(`CdkDropList could not find an element container matching the selector \"${this.elementContainerSelector}\"`);\n          }\n          ref.withElementContainer(container);\n        }\n        ref.disabled = this.disabled;\n        ref.lockAxis = this.lockAxis;\n        ref.sortingDisabled = this.sortingDisabled;\n        ref.autoScrollDisabled = this.autoScrollDisabled;\n        ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);\n        ref.hasAnchor = this.hasAnchor;\n        ref.connectedTo(siblings.filter(drop => drop && drop !== this).map(list => list._dropListRef)).withOrientation(this.orientation);\n      });\n    }\n    _handleEvents(ref) {\n      ref.beforeStarted.subscribe(() => {\n        this._syncItemsWithRef(this.getSortedItems().map(item => item._dragRef));\n        this._changeDetectorRef.markForCheck();\n      });\n      ref.entered.subscribe(event => {\n        this.entered.emit({\n          container: this,\n          item: event.item.data,\n          currentIndex: event.currentIndex\n        });\n      });\n      ref.exited.subscribe(event => {\n        this.exited.emit({\n          container: this,\n          item: event.item.data\n        });\n        this._changeDetectorRef.markForCheck();\n      });\n      ref.sorted.subscribe(event => {\n        this.sorted.emit({\n          previousIndex: event.previousIndex,\n          currentIndex: event.currentIndex,\n          container: this,\n          item: event.item.data\n        });\n      });\n      ref.dropped.subscribe(dropEvent => {\n        this.dropped.emit({\n          previousIndex: dropEvent.previousIndex,\n          currentIndex: dropEvent.currentIndex,\n          previousContainer: dropEvent.previousContainer.data,\n          container: dropEvent.container.data,\n          item: dropEvent.item.data,\n          isPointerOverContainer: dropEvent.isPointerOverContainer,\n          distance: dropEvent.distance,\n          dropPoint: dropEvent.dropPoint,\n          event: dropEvent.event\n        });\n        this._changeDetectorRef.markForCheck();\n      });\n      merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n    _assignDefaults(config) {\n      const {\n        lockAxis,\n        draggingDisabled,\n        sortingDisabled,\n        listAutoScrollDisabled,\n        listOrientation\n      } = config;\n      this.disabled = draggingDisabled == null ? false : draggingDisabled;\n      this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;\n      this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;\n      this.orientation = listOrientation || 'vertical';\n      this.lockAxis = lockAxis || null;\n    }\n    _syncItemsWithRef(items) {\n      this._latestSortedRefs = items;\n      this._dropListRef.withItems(items);\n    }\n    static ɵfac = function CdkDropList_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkDropList)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkDropList,\n      selectors: [[\"\", \"cdkDropList\", \"\"], [\"cdk-drop-list\"]],\n      hostAttrs: [1, \"cdk-drop-list\"],\n      hostVars: 7,\n      hostBindings: function CdkDropList_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"id\", ctx.id);\n          i0.ɵɵclassProp(\"cdk-drop-list-disabled\", ctx.disabled)(\"cdk-drop-list-dragging\", ctx._dropListRef.isDragging())(\"cdk-drop-list-receiving\", ctx._dropListRef.isReceiving());\n        }\n      },\n      inputs: {\n        connectedTo: [0, \"cdkDropListConnectedTo\", \"connectedTo\"],\n        data: [0, \"cdkDropListData\", \"data\"],\n        orientation: [0, \"cdkDropListOrientation\", \"orientation\"],\n        id: \"id\",\n        lockAxis: [0, \"cdkDropListLockAxis\", \"lockAxis\"],\n        disabled: [2, \"cdkDropListDisabled\", \"disabled\", booleanAttribute],\n        sortingDisabled: [2, \"cdkDropListSortingDisabled\", \"sortingDisabled\", booleanAttribute],\n        enterPredicate: [0, \"cdkDropListEnterPredicate\", \"enterPredicate\"],\n        sortPredicate: [0, \"cdkDropListSortPredicate\", \"sortPredicate\"],\n        autoScrollDisabled: [2, \"cdkDropListAutoScrollDisabled\", \"autoScrollDisabled\", booleanAttribute],\n        autoScrollStep: [0, \"cdkDropListAutoScrollStep\", \"autoScrollStep\"],\n        elementContainerSelector: [0, \"cdkDropListElementContainer\", \"elementContainerSelector\"],\n        hasAnchor: [2, \"cdkDropListHasAnchor\", \"hasAnchor\", booleanAttribute]\n      },\n      outputs: {\n        dropped: \"cdkDropListDropped\",\n        entered: \"cdkDropListEntered\",\n        exited: \"cdkDropListExited\",\n        sorted: \"cdkDropListSorted\"\n      },\n      exportAs: [\"cdkDropList\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CDK_DROP_LIST_GROUP,\n        useValue: undefined\n      }, {\n        provide: CDK_DROP_LIST,\n        useExisting: CdkDropList\n      }])]\n    });\n  }\n  return CdkDropList;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CDK_DRAG_PREVIEW = /*#__PURE__*/new InjectionToken('CdkDragPreview');\nlet CdkDragPreview = /*#__PURE__*/(() => {\n  class CdkDragPreview {\n    templateRef = inject(TemplateRef);\n    _drag = inject(CDK_DRAG_PARENT, {\n      optional: true\n    });\n    data;\n    matchSize = false;\n    constructor() {\n      this._drag?._setPreviewTemplate(this);\n    }\n    ngOnDestroy() {\n      this._drag?._resetPreviewTemplate(this);\n    }\n    static ɵfac = function CdkDragPreview_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkDragPreview)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkDragPreview,\n      selectors: [[\"ng-template\", \"cdkDragPreview\", \"\"]],\n      inputs: {\n        data: \"data\",\n        matchSize: [2, \"matchSize\", \"matchSize\", booleanAttribute]\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CDK_DRAG_PREVIEW,\n        useExisting: CdkDragPreview\n      }])]\n    });\n  }\n  return CdkDragPreview;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CDK_DRAG_PLACEHOLDER = /*#__PURE__*/new InjectionToken('CdkDragPlaceholder');\nlet CdkDragPlaceholder = /*#__PURE__*/(() => {\n  class CdkDragPlaceholder {\n    templateRef = inject(TemplateRef);\n    _drag = inject(CDK_DRAG_PARENT, {\n      optional: true\n    });\n    data;\n    constructor() {\n      this._drag?._setPlaceholderTemplate(this);\n    }\n    ngOnDestroy() {\n      this._drag?._resetPlaceholderTemplate(this);\n    }\n    static ɵfac = function CdkDragPlaceholder_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkDragPlaceholder)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkDragPlaceholder,\n      selectors: [[\"ng-template\", \"cdkDragPlaceholder\", \"\"]],\n      inputs: {\n        data: \"data\"\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CDK_DRAG_PLACEHOLDER,\n        useExisting: CdkDragPlaceholder\n      }])]\n    });\n  }\n  return CdkDragPlaceholder;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];\nlet DragDropModule = /*#__PURE__*/(() => {\n  class DragDropModule {\n    static ɵfac = function DragDropModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DragDropModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: DragDropModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [DragDrop],\n      imports: [CdkScrollableModule]\n    });\n  }\n  return DragDropModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { CDK_DRAG_CONFIG, CDK_DRAG_HANDLE, CDK_DRAG_PARENT, CDK_DRAG_PLACEHOLDER, CDK_DRAG_PREVIEW, CDK_DROP_LIST, CDK_DROP_LIST_GROUP, CdkDrag, CdkDragHandle, CdkDragPlaceholder, CdkDragPreview, CdkDropList, CdkDropListGroup, DragDrop, DragDropModule, DragDropRegistry, DragRef, DropListRef, copyArrayItem, moveItemInArray, transferArrayItem };\n//# sourceMappingURL=drag-drop.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}