{"ast":null,"code":"import { SelectionModel } from './_selection-model-chunk.mjs';\nimport { isObservable, Subject, BehaviorSubject, of, combineLatest, EMPTY, concat } from 'rxjs';\nimport { take, filter, takeUntil, startWith, tap, switchMap, map, reduce, concatMap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ViewContainerRef, Directive, TemplateRef, IterableDiffers, ChangeDetectorRef, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, ContentChildren, EventEmitter, booleanAttribute, Output, numberAttribute, NgModule } from '@angular/core';\nimport { TREE_KEY_MANAGER } from './_tree-key-manager-chunk.mjs';\nimport { Directionality } from './_directionality-chunk.mjs';\nimport { isDataSource } from './_data-source-chunk.mjs';\nimport { coerceObservable } from './coercion-private.mjs';\nimport './_typeahead-chunk.mjs';\nimport './_keycodes-chunk.mjs';\nclass BaseTreeControl {\n  dataNodes;\n  expansionModel = /*#__PURE__*/new SelectionModel(true);\n  trackBy;\n  getLevel;\n  isExpandable;\n  getChildren;\n  toggle(dataNode) {\n    this.expansionModel.toggle(this._trackByValue(dataNode));\n  }\n  expand(dataNode) {\n    this.expansionModel.select(this._trackByValue(dataNode));\n  }\n  collapse(dataNode) {\n    this.expansionModel.deselect(this._trackByValue(dataNode));\n  }\n  isExpanded(dataNode) {\n    return this.expansionModel.isSelected(this._trackByValue(dataNode));\n  }\n  toggleDescendants(dataNode) {\n    this.expansionModel.isSelected(this._trackByValue(dataNode)) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);\n  }\n  collapseAll() {\n    this.expansionModel.clear();\n  }\n  expandDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  collapseDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  _trackByValue(value) {\n    return this.trackBy ? this.trackBy(value) : value;\n  }\n}\nclass FlatTreeControl extends BaseTreeControl {\n  getLevel;\n  isExpandable;\n  options;\n  constructor(getLevel, isExpandable, options) {\n    super();\n    this.getLevel = getLevel;\n    this.isExpandable = isExpandable;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n  }\n  getDescendants(dataNode) {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results = [];\n    for (let i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n  expandAll() {\n    this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n  }\n}\nclass NestedTreeControl extends BaseTreeControl {\n  getChildren;\n  options;\n  constructor(getChildren, options) {\n    super();\n    this.getChildren = getChildren;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n    if (this.options?.isExpandable) {\n      this.isExpandable = this.options.isExpandable;\n    }\n  }\n  expandAll() {\n    this.expansionModel.clear();\n    const allNodes = this.dataNodes.reduce((accumulator, dataNode) => [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n    this.expansionModel.select(...allNodes.map(node => this._trackByValue(node)));\n  }\n  getDescendants(dataNode) {\n    const descendants = [];\n    this._getDescendants(descendants, dataNode);\n    return descendants.splice(1);\n  }\n  _getDescendants(descendants, dataNode) {\n    descendants.push(dataNode);\n    const childrenNodes = this.getChildren(dataNode);\n    if (Array.isArray(childrenNodes)) {\n      childrenNodes.forEach(child => this._getDescendants(descendants, child));\n    } else if (isObservable(childrenNodes)) {\n      childrenNodes.pipe(take(1), filter(Boolean)).subscribe(children => {\n        for (const child of children) {\n          this._getDescendants(descendants, child);\n        }\n      });\n    }\n  }\n}\nconst CDK_TREE_NODE_OUTLET_NODE = /*#__PURE__*/new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\nlet CdkTreeNodeOutlet = /*#__PURE__*/(() => {\n  class CdkTreeNodeOutlet {\n    viewContainer = inject(ViewContainerRef);\n    _node = inject(CDK_TREE_NODE_OUTLET_NODE, {\n      optional: true\n    });\n    constructor() {}\n    static ɵfac = function CdkTreeNodeOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeOutlet,\n      selectors: [[\"\", \"cdkTreeNodeOutlet\", \"\"]]\n    });\n  }\n  return CdkTreeNodeOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass CdkTreeNodeOutletContext {\n  $implicit;\n  level;\n  index;\n  count;\n  constructor(data) {\n    this.$implicit = data;\n  }\n}\nlet CdkTreeNodeDef = /*#__PURE__*/(() => {\n  class CdkTreeNodeDef {\n    template = inject(TemplateRef);\n    when;\n    constructor() {}\n    static ɵfac = function CdkTreeNodeDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeDef,\n      selectors: [[\"\", \"cdkTreeNodeDef\", \"\"]],\n      inputs: {\n        when: [0, \"cdkTreeNodeDefWhen\", \"when\"]\n      }\n    });\n  }\n  return CdkTreeNodeDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getTreeNoValidDataSourceError() {\n  return Error(`A valid data source must be provided.`);\n}\nfunction getTreeMultipleDefaultNodeDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\nfunction getTreeMissingMatchingNodeDefError() {\n  return Error(`Could not find a matching node definition for the provided node data.`);\n}\nfunction getTreeControlMissingError() {\n  return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);\n}\nfunction getMultipleTreeControlsError() {\n  return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);\n}\nlet CdkTree = /*#__PURE__*/(() => {\n  class CdkTree {\n    _differs = inject(IterableDiffers);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dir = inject(Directionality);\n    _onDestroy = new Subject();\n    _dataDiffer;\n    _defaultNodeDef;\n    _dataSubscription;\n    _levels = new Map();\n    _parents = new Map();\n    _ariaSets = new Map();\n    get dataSource() {\n      return this._dataSource;\n    }\n    set dataSource(dataSource) {\n      if (this._dataSource !== dataSource) {\n        this._switchDataSource(dataSource);\n      }\n    }\n    _dataSource;\n    treeControl;\n    levelAccessor;\n    childrenAccessor;\n    trackBy;\n    expansionKey;\n    _nodeOutlet;\n    _nodeDefs;\n    viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n    _expansionModel;\n    _flattenedNodes = new BehaviorSubject([]);\n    _nodeType = new BehaviorSubject(null);\n    _nodes = new BehaviorSubject(new Map());\n    _keyManagerNodes = new BehaviorSubject([]);\n    _keyManagerFactory = inject(TREE_KEY_MANAGER);\n    _keyManager;\n    _viewInit = false;\n    constructor() {}\n    ngAfterContentInit() {\n      this._initializeKeyManager();\n    }\n    ngAfterContentChecked() {\n      this._updateDefaultNodeDefinition();\n      this._subscribeToDataChanges();\n    }\n    ngOnDestroy() {\n      this._nodeOutlet.viewContainer.clear();\n      this._nodes.complete();\n      this._keyManagerNodes.complete();\n      this._nodeType.complete();\n      this._flattenedNodes.complete();\n      this.viewChange.complete();\n      this._onDestroy.next();\n      this._onDestroy.complete();\n      if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n        this.dataSource.disconnect(this);\n      }\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n        this._dataSubscription = null;\n      }\n      this._keyManager?.destroy();\n    }\n    ngOnInit() {\n      this._checkTreeControlUsage();\n      this._initializeDataDiffer();\n    }\n    ngAfterViewInit() {\n      this._viewInit = true;\n    }\n    _updateDefaultNodeDefinition() {\n      const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n      if (defaultNodeDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTreeMultipleDefaultNodeDefsError();\n      }\n      this._defaultNodeDef = defaultNodeDefs[0];\n    }\n    _setNodeTypeIfUnset(newType) {\n      const currentType = this._nodeType.value;\n      if (currentType === null) {\n        this._nodeType.next(newType);\n      } else if ((typeof ngDevMode === 'undefined' || ngDevMode) && currentType !== newType) {\n        console.warn(`Tree is using conflicting node types which can cause unexpected behavior. ` + `Please use tree nodes of the same type (e.g. only flat or only nested). ` + `Current node type: \"${currentType}\", new node type \"${newType}\".`);\n      }\n    }\n    _switchDataSource(dataSource) {\n      if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n        this.dataSource.disconnect(this);\n      }\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n        this._dataSubscription = null;\n      }\n      if (!dataSource) {\n        this._nodeOutlet.viewContainer.clear();\n      }\n      this._dataSource = dataSource;\n      if (this._nodeDefs) {\n        this._subscribeToDataChanges();\n      }\n    }\n    _getExpansionModel() {\n      if (!this.treeControl) {\n        this._expansionModel ??= new SelectionModel(true);\n        return this._expansionModel;\n      }\n      return this.treeControl.expansionModel;\n    }\n    _subscribeToDataChanges() {\n      if (this._dataSubscription) {\n        return;\n      }\n      let dataStream;\n      if (isDataSource(this._dataSource)) {\n        dataStream = this._dataSource.connect(this);\n      } else if (isObservable(this._dataSource)) {\n        dataStream = this._dataSource;\n      } else if (Array.isArray(this._dataSource)) {\n        dataStream = of(this._dataSource);\n      }\n      if (!dataStream) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          throw getTreeNoValidDataSourceError();\n        }\n        return;\n      }\n      this._dataSubscription = this._getRenderData(dataStream).pipe(takeUntil(this._onDestroy)).subscribe(renderingData => {\n        this._renderDataChanges(renderingData);\n      });\n    }\n    _getRenderData(dataStream) {\n      const expansionModel = this._getExpansionModel();\n      return combineLatest([dataStream, this._nodeType, expansionModel.changed.pipe(startWith(null), tap(expansionChanges => {\n        this._emitExpansionChanges(expansionChanges);\n      }))]).pipe(switchMap(([data, nodeType]) => {\n        if (nodeType === null) {\n          return of({\n            renderNodes: data,\n            flattenedNodes: null,\n            nodeType\n          });\n        }\n        return this._computeRenderingData(data, nodeType).pipe(map(convertedData => ({\n          ...convertedData,\n          nodeType\n        })));\n      }));\n    }\n    _renderDataChanges(data) {\n      if (data.nodeType === null) {\n        this.renderNodeChanges(data.renderNodes);\n        return;\n      }\n      this._updateCachedData(data.flattenedNodes);\n      this.renderNodeChanges(data.renderNodes);\n      this._updateKeyManagerItems(data.flattenedNodes);\n    }\n    _emitExpansionChanges(expansionChanges) {\n      if (!expansionChanges) {\n        return;\n      }\n      const nodes = this._nodes.value;\n      for (const added of expansionChanges.added) {\n        const node = nodes.get(added);\n        node?._emitExpansionState(true);\n      }\n      for (const removed of expansionChanges.removed) {\n        const node = nodes.get(removed);\n        node?._emitExpansionState(false);\n      }\n    }\n    _initializeKeyManager() {\n      const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(map(([keyManagerNodes, renderNodes]) => keyManagerNodes.reduce((items, data) => {\n        const node = renderNodes.get(this._getExpansionKey(data));\n        if (node) {\n          items.push(node);\n        }\n        return items;\n      }, [])));\n      const keyManagerOptions = {\n        trackBy: node => this._getExpansionKey(node.data),\n        skipPredicate: node => !!node.isDisabled,\n        typeAheadDebounceInterval: true,\n        horizontalOrientation: this._dir.value\n      };\n      this._keyManager = this._keyManagerFactory(items, keyManagerOptions);\n    }\n    _initializeDataDiffer() {\n      const trackBy = this.trackBy ?? ((_index, item) => this._getExpansionKey(item));\n      this._dataDiffer = this._differs.find([]).create(trackBy);\n    }\n    _checkTreeControlUsage() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        let numTreeControls = 0;\n        if (this.treeControl) {\n          numTreeControls++;\n        }\n        if (this.levelAccessor) {\n          numTreeControls++;\n        }\n        if (this.childrenAccessor) {\n          numTreeControls++;\n        }\n        if (!numTreeControls) {\n          throw getTreeControlMissingError();\n        } else if (numTreeControls > 1) {\n          throw getMultipleTreeControlsError();\n        }\n      }\n    }\n    renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {\n      const changes = dataDiffer.diff(data);\n      if (!changes && !this._viewInit) {\n        return;\n      }\n      changes?.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n        if (item.previousIndex == null) {\n          this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(adjustedPreviousIndex);\n        } else {\n          const view = viewContainer.get(adjustedPreviousIndex);\n          viewContainer.move(view, currentIndex);\n        }\n      });\n      changes?.forEachIdentityChange(record => {\n        const newData = record.item;\n        if (record.currentIndex != undefined) {\n          const view = viewContainer.get(record.currentIndex);\n          view.context.$implicit = newData;\n        }\n      });\n      if (parentData) {\n        this._changeDetectorRef.markForCheck();\n      } else {\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    _getNodeDef(data, i) {\n      if (this._nodeDefs.length === 1) {\n        return this._nodeDefs.first;\n      }\n      const nodeDef = this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n      if (!nodeDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTreeMissingMatchingNodeDefError();\n      }\n      return nodeDef;\n    }\n    insertNode(nodeData, index, viewContainer, parentData) {\n      const levelAccessor = this._getLevelAccessor();\n      const node = this._getNodeDef(nodeData, index);\n      const key = this._getExpansionKey(nodeData);\n      const context = new CdkTreeNodeOutletContext(nodeData);\n      context.index = index;\n      parentData ??= this._parents.get(key) ?? undefined;\n      if (levelAccessor) {\n        context.level = levelAccessor(nodeData);\n      } else if (parentData !== undefined && this._levels.has(this._getExpansionKey(parentData))) {\n        context.level = this._levels.get(this._getExpansionKey(parentData)) + 1;\n      } else {\n        context.level = 0;\n      }\n      this._levels.set(key, context.level);\n      const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n      container.createEmbeddedView(node.template, context, index);\n      if (CdkTreeNode.mostRecentTreeNode) {\n        CdkTreeNode.mostRecentTreeNode.data = nodeData;\n      }\n    }\n    isExpanded(dataNode) {\n      return !!(this.treeControl?.isExpanded(dataNode) || this._expansionModel?.isSelected(this._getExpansionKey(dataNode)));\n    }\n    toggle(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.toggle(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.toggle(this._getExpansionKey(dataNode));\n      }\n    }\n    expand(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.expand(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.select(this._getExpansionKey(dataNode));\n      }\n    }\n    collapse(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.collapse(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.deselect(this._getExpansionKey(dataNode));\n      }\n    }\n    toggleDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.toggleDescendants(dataNode);\n      } else if (this._expansionModel) {\n        if (this.isExpanded(dataNode)) {\n          this.collapseDescendants(dataNode);\n        } else {\n          this.expandDescendants(dataNode);\n        }\n      }\n    }\n    expandDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.expandDescendants(dataNode);\n      } else if (this._expansionModel) {\n        const expansionModel = this._expansionModel;\n        expansionModel.select(this._getExpansionKey(dataNode));\n        this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n          expansionModel.select(...children.map(child => this._getExpansionKey(child)));\n        });\n      }\n    }\n    collapseDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.collapseDescendants(dataNode);\n      } else if (this._expansionModel) {\n        const expansionModel = this._expansionModel;\n        expansionModel.deselect(this._getExpansionKey(dataNode));\n        this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n          expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));\n        });\n      }\n    }\n    expandAll() {\n      if (this.treeControl) {\n        this.treeControl.expandAll();\n      } else if (this._expansionModel) {\n        this._forEachExpansionKey(keys => this._expansionModel?.select(...keys));\n      }\n    }\n    collapseAll() {\n      if (this.treeControl) {\n        this.treeControl.collapseAll();\n      } else if (this._expansionModel) {\n        this._forEachExpansionKey(keys => this._expansionModel?.deselect(...keys));\n      }\n    }\n    _getLevelAccessor() {\n      return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;\n    }\n    _getChildrenAccessor() {\n      return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;\n    }\n    _getDirectChildren(dataNode) {\n      const levelAccessor = this._getLevelAccessor();\n      const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;\n      if (!expansionModel) {\n        return of([]);\n      }\n      const key = this._getExpansionKey(dataNode);\n      const isExpanded = expansionModel.changed.pipe(switchMap(changes => {\n        if (changes.added.includes(key)) {\n          return of(true);\n        } else if (changes.removed.includes(key)) {\n          return of(false);\n        }\n        return EMPTY;\n      }), startWith(this.isExpanded(dataNode)));\n      if (levelAccessor) {\n        return combineLatest([isExpanded, this._flattenedNodes]).pipe(map(([expanded, flattenedNodes]) => {\n          if (!expanded) {\n            return [];\n          }\n          return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);\n        }));\n      }\n      const childrenAccessor = this._getChildrenAccessor();\n      if (childrenAccessor) {\n        return coerceObservable(childrenAccessor(dataNode) ?? []);\n      }\n      throw getTreeControlMissingError();\n    }\n    _findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, levelDelta) {\n      const key = this._getExpansionKey(dataNode);\n      const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);\n      const dataNodeLevel = levelAccessor(dataNode);\n      const expectedLevel = dataNodeLevel + levelDelta;\n      const results = [];\n      for (let i = startIndex + 1; i < flattenedNodes.length; i++) {\n        const currentLevel = levelAccessor(flattenedNodes[i]);\n        if (currentLevel <= dataNodeLevel) {\n          break;\n        }\n        if (currentLevel <= expectedLevel) {\n          results.push(flattenedNodes[i]);\n        }\n      }\n      return results;\n    }\n    _registerNode(node) {\n      this._nodes.value.set(this._getExpansionKey(node.data), node);\n      this._nodes.next(this._nodes.value);\n    }\n    _unregisterNode(node) {\n      this._nodes.value.delete(this._getExpansionKey(node.data));\n      this._nodes.next(this._nodes.value);\n    }\n    _getLevel(node) {\n      return this._levels.get(this._getExpansionKey(node));\n    }\n    _getSetSize(dataNode) {\n      const set = this._getAriaSet(dataNode);\n      return set.length;\n    }\n    _getPositionInSet(dataNode) {\n      const set = this._getAriaSet(dataNode);\n      const key = this._getExpansionKey(dataNode);\n      return set.findIndex(node => this._getExpansionKey(node) === key) + 1;\n    }\n    _getNodeParent(node) {\n      const parent = this._parents.get(this._getExpansionKey(node.data));\n      return parent && this._nodes.value.get(this._getExpansionKey(parent));\n    }\n    _getNodeChildren(node) {\n      return this._getDirectChildren(node.data).pipe(map(children => children.reduce((nodes, child) => {\n        const value = this._nodes.value.get(this._getExpansionKey(child));\n        if (value) {\n          nodes.push(value);\n        }\n        return nodes;\n      }, [])));\n    }\n    _sendKeydownToKeyManager(event) {\n      if (event.target === this._elementRef.nativeElement) {\n        this._keyManager.onKeydown(event);\n      } else {\n        const nodes = this._nodes.getValue();\n        for (const [, node] of nodes) {\n          if (event.target === node._elementRef.nativeElement) {\n            this._keyManager.onKeydown(event);\n            break;\n          }\n        }\n      }\n    }\n    _getDescendants(dataNode) {\n      if (this.treeControl) {\n        return of(this.treeControl.getDescendants(dataNode));\n      }\n      if (this.levelAccessor) {\n        const results = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, dataNode, Infinity);\n        return of(results);\n      }\n      if (this.childrenAccessor) {\n        return this._getAllChildrenRecursively(dataNode).pipe(reduce((allChildren, nextChildren) => {\n          allChildren.push(...nextChildren);\n          return allChildren;\n        }, []));\n      }\n      throw getTreeControlMissingError();\n    }\n    _getAllChildrenRecursively(dataNode) {\n      if (!this.childrenAccessor) {\n        return of([]);\n      }\n      return coerceObservable(this.childrenAccessor(dataNode)).pipe(take(1), switchMap(children => {\n        for (const child of children) {\n          this._parents.set(this._getExpansionKey(child), dataNode);\n        }\n        return of(...children).pipe(concatMap(child => concat(of([child]), this._getAllChildrenRecursively(child))));\n      }));\n    }\n    _getExpansionKey(dataNode) {\n      return this.expansionKey?.(dataNode) ?? dataNode;\n    }\n    _getAriaSet(node) {\n      const key = this._getExpansionKey(node);\n      const parent = this._parents.get(key);\n      const parentKey = parent ? this._getExpansionKey(parent) : null;\n      const set = this._ariaSets.get(parentKey);\n      return set ?? [node];\n    }\n    _findParentForNode(node, index, cachedNodes) {\n      if (!cachedNodes.length) {\n        return null;\n      }\n      const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;\n      for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {\n        const parentNode = cachedNodes[parentIndex];\n        const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;\n        if (parentLevel < currentLevel) {\n          return parentNode;\n        }\n      }\n      return null;\n    }\n    _flattenNestedNodesWithExpansion(nodes, level = 0) {\n      const childrenAccessor = this._getChildrenAccessor();\n      if (!childrenAccessor) {\n        return of([...nodes]);\n      }\n      return of(...nodes).pipe(concatMap(node => {\n        const parentKey = this._getExpansionKey(node);\n        if (!this._parents.has(parentKey)) {\n          this._parents.set(parentKey, null);\n        }\n        this._levels.set(parentKey, level);\n        const children = coerceObservable(childrenAccessor(node));\n        return concat(of([node]), children.pipe(take(1), tap(childNodes => {\n          this._ariaSets.set(parentKey, [...(childNodes ?? [])]);\n          for (const child of childNodes ?? []) {\n            const childKey = this._getExpansionKey(child);\n            this._parents.set(childKey, node);\n            this._levels.set(childKey, level + 1);\n          }\n        }), switchMap(childNodes => {\n          if (!childNodes) {\n            return of([]);\n          }\n          return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(map(nestedNodes => this.isExpanded(node) ? nestedNodes : []));\n        })));\n      }), reduce((results, children) => {\n        results.push(...children);\n        return results;\n      }, []));\n    }\n    _computeRenderingData(nodes, nodeType) {\n      if (this.childrenAccessor && nodeType === 'flat') {\n        this._clearPreviousCache();\n        this._ariaSets.set(null, [...nodes]);\n        return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n          renderNodes: flattenedNodes,\n          flattenedNodes\n        })));\n      } else if (this.levelAccessor && nodeType === 'nested') {\n        const levelAccessor = this.levelAccessor;\n        return of(nodes.filter(node => levelAccessor(node) === 0)).pipe(map(rootNodes => ({\n          renderNodes: rootNodes,\n          flattenedNodes: nodes\n        })), tap(({\n          flattenedNodes\n        }) => {\n          this._calculateParents(flattenedNodes);\n        }));\n      } else if (nodeType === 'flat') {\n        return of({\n          renderNodes: nodes,\n          flattenedNodes: nodes\n        }).pipe(tap(({\n          flattenedNodes\n        }) => {\n          this._calculateParents(flattenedNodes);\n        }));\n      } else {\n        this._clearPreviousCache();\n        this._ariaSets.set(null, [...nodes]);\n        return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n          renderNodes: nodes,\n          flattenedNodes\n        })));\n      }\n    }\n    _updateCachedData(flattenedNodes) {\n      this._flattenedNodes.next(flattenedNodes);\n    }\n    _updateKeyManagerItems(flattenedNodes) {\n      this._keyManagerNodes.next(flattenedNodes);\n    }\n    _calculateParents(flattenedNodes) {\n      const levelAccessor = this._getLevelAccessor();\n      if (!levelAccessor) {\n        return;\n      }\n      this._clearPreviousCache();\n      for (let index = 0; index < flattenedNodes.length; index++) {\n        const dataNode = flattenedNodes[index];\n        const key = this._getExpansionKey(dataNode);\n        this._levels.set(key, levelAccessor(dataNode));\n        const parent = this._findParentForNode(dataNode, index, flattenedNodes);\n        this._parents.set(key, parent);\n        const parentKey = parent ? this._getExpansionKey(parent) : null;\n        const group = this._ariaSets.get(parentKey) ?? [];\n        group.splice(index, 0, dataNode);\n        this._ariaSets.set(parentKey, group);\n      }\n    }\n    _forEachExpansionKey(callback) {\n      const toToggle = [];\n      const observables = [];\n      this._nodes.value.forEach(node => {\n        toToggle.push(this._getExpansionKey(node.data));\n        observables.push(this._getDescendants(node.data));\n      });\n      if (observables.length > 0) {\n        combineLatest(observables).pipe(take(1), takeUntil(this._onDestroy)).subscribe(results => {\n          results.forEach(inner => inner.forEach(r => toToggle.push(this._getExpansionKey(r))));\n          callback(toToggle);\n        });\n      } else {\n        callback(toToggle);\n      }\n    }\n    _clearPreviousCache() {\n      this._parents.clear();\n      this._levels.clear();\n      this._ariaSets.clear();\n    }\n    static ɵfac = function CdkTree_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTree)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkTree,\n      selectors: [[\"cdk-tree\"]],\n      contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeDefs = _t);\n        }\n      },\n      viewQuery: function CdkTree_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(CdkTreeNodeOutlet, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"tree\", 1, \"cdk-tree\"],\n      hostBindings: function CdkTree_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function CdkTree_keydown_HostBindingHandler($event) {\n            return ctx._sendKeydownToKeyManager($event);\n          });\n        }\n      },\n      inputs: {\n        dataSource: \"dataSource\",\n        treeControl: \"treeControl\",\n        levelAccessor: \"levelAccessor\",\n        childrenAccessor: \"childrenAccessor\",\n        trackBy: \"trackBy\",\n        expansionKey: \"expansionKey\"\n      },\n      exportAs: [\"cdkTree\"],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkTreeNodeOutlet\", \"\"]],\n      template: function CdkTree_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainer(0, 0);\n        }\n      },\n      dependencies: [CdkTreeNodeOutlet],\n      encapsulation: 2\n    });\n  }\n  return CdkTree;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkTreeNode = /*#__PURE__*/(() => {\n  class CdkTreeNode {\n    _elementRef = inject(ElementRef);\n    _tree = inject(CdkTree);\n    _tabindex = -1;\n    _type = 'flat';\n    get role() {\n      return 'treeitem';\n    }\n    set role(_role) {}\n    get isExpandable() {\n      return this._isExpandable();\n    }\n    set isExpandable(isExpandable) {\n      this._inputIsExpandable = isExpandable;\n      if (this.data && !this._isExpandable || !this._inputIsExpandable) {\n        return;\n      }\n      if (this._inputIsExpanded) {\n        this.expand();\n      } else if (this._inputIsExpanded === false) {\n        this.collapse();\n      }\n    }\n    get isExpanded() {\n      return this._tree.isExpanded(this._data);\n    }\n    set isExpanded(isExpanded) {\n      this._inputIsExpanded = isExpanded;\n      if (isExpanded) {\n        this.expand();\n      } else {\n        this.collapse();\n      }\n    }\n    isDisabled;\n    typeaheadLabel;\n    getLabel() {\n      return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n    }\n    activation = new EventEmitter();\n    expandedChange = new EventEmitter();\n    static mostRecentTreeNode = null;\n    _destroyed = new Subject();\n    _dataChanges = new Subject();\n    _inputIsExpandable = false;\n    _inputIsExpanded = undefined;\n    _shouldFocus = true;\n    _parentNodeAriaLevel;\n    get data() {\n      return this._data;\n    }\n    set data(value) {\n      if (value !== this._data) {\n        this._data = value;\n        this._dataChanges.next();\n      }\n    }\n    _data;\n    get isLeafNode() {\n      if (this._tree.treeControl?.isExpandable !== undefined && !this._tree.treeControl.isExpandable(this._data)) {\n        return true;\n      } else if (this._tree.treeControl?.isExpandable === undefined && this._tree.treeControl?.getDescendants(this._data).length === 0) {\n        return true;\n      }\n      return false;\n    }\n    get level() {\n      return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;\n    }\n    _isExpandable() {\n      if (this._tree.treeControl) {\n        if (this.isLeafNode) {\n          return false;\n        }\n        return true;\n      }\n      return this._inputIsExpandable;\n    }\n    _getAriaExpanded() {\n      if (!this._isExpandable()) {\n        return null;\n      }\n      return String(this.isExpanded);\n    }\n    _getSetSize() {\n      return this._tree._getSetSize(this._data);\n    }\n    _getPositionInSet() {\n      return this._tree._getPositionInSet(this._data);\n    }\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    constructor() {\n      CdkTreeNode.mostRecentTreeNode = this;\n    }\n    ngOnInit() {\n      this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);\n      this._tree._getExpansionModel().changed.pipe(map(() => this.isExpanded), distinctUntilChanged(), takeUntil(this._destroyed)).pipe(takeUntil(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck());\n      this._tree._setNodeTypeIfUnset(this._type);\n      this._tree._registerNode(this);\n    }\n    ngOnDestroy() {\n      if (CdkTreeNode.mostRecentTreeNode === this) {\n        CdkTreeNode.mostRecentTreeNode = null;\n      }\n      this._dataChanges.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    getParent() {\n      return this._tree._getNodeParent(this) ?? null;\n    }\n    getChildren() {\n      return this._tree._getNodeChildren(this);\n    }\n    focus() {\n      this._tabindex = 0;\n      if (this._shouldFocus) {\n        this._elementRef.nativeElement.focus();\n      }\n      this._changeDetectorRef.markForCheck();\n    }\n    unfocus() {\n      this._tabindex = -1;\n      this._changeDetectorRef.markForCheck();\n    }\n    activate() {\n      if (this.isDisabled) {\n        return;\n      }\n      this.activation.next(this._data);\n    }\n    collapse() {\n      if (this.isExpandable) {\n        this._tree.collapse(this._data);\n      }\n    }\n    expand() {\n      if (this.isExpandable) {\n        this._tree.expand(this._data);\n      }\n    }\n    makeFocusable() {\n      this._tabindex = 0;\n      this._changeDetectorRef.markForCheck();\n    }\n    _focusItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      this._tree._keyManager.focusItem(this);\n    }\n    _setActiveItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      this._shouldFocus = false;\n      this._tree._keyManager.focusItem(this);\n      this._shouldFocus = true;\n    }\n    _emitExpansionState(expanded) {\n      this.expandedChange.emit(expanded);\n    }\n    static ɵfac = function CdkTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNode)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNode,\n      selectors: [[\"cdk-tree-node\"]],\n      hostAttrs: [\"role\", \"treeitem\", 1, \"cdk-tree-node\"],\n      hostVars: 5,\n      hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function CdkTreeNode_click_HostBindingHandler() {\n            return ctx._setActiveItem();\n          })(\"focus\", function CdkTreeNode_focus_HostBindingHandler() {\n            return ctx._focusItem();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"tabIndex\", ctx._tabindex);\n          i0.ɵɵattribute(\"aria-expanded\", ctx._getAriaExpanded())(\"aria-level\", ctx.level + 1)(\"aria-posinset\", ctx._getPositionInSet())(\"aria-setsize\", ctx._getSetSize());\n        }\n      },\n      inputs: {\n        role: \"role\",\n        isExpandable: [2, \"isExpandable\", \"isExpandable\", booleanAttribute],\n        isExpanded: \"isExpanded\",\n        isDisabled: [2, \"isDisabled\", \"isDisabled\", booleanAttribute],\n        typeaheadLabel: [0, \"cdkTreeNodeTypeaheadLabel\", \"typeaheadLabel\"]\n      },\n      outputs: {\n        activation: \"activation\",\n        expandedChange: \"expandedChange\"\n      },\n      exportAs: [\"cdkTreeNode\"]\n    });\n  }\n  return CdkTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getParentNodeAriaLevel(nodeElement) {\n  let parent = nodeElement.parentElement;\n  while (parent && !isNodeElement(parent)) {\n    parent = parent.parentElement;\n  }\n  if (!parent) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw Error('Incorrect tree structure containing detached node.');\n    } else {\n      return -1;\n    }\n  } else if (parent.classList.contains('cdk-nested-tree-node')) {\n    return numberAttribute(parent.getAttribute('aria-level'));\n  } else {\n    return 0;\n  }\n}\nfunction isNodeElement(element) {\n  const classList = element.classList;\n  return !!(classList?.contains('cdk-nested-tree-node') || classList?.contains('cdk-tree'));\n}\nlet CdkNestedTreeNode = /*#__PURE__*/(() => {\n  class CdkNestedTreeNode extends CdkTreeNode {\n    _type = 'nested';\n    _differs = inject(IterableDiffers);\n    _dataDiffer;\n    _children;\n    nodeOutlet;\n    constructor() {\n      super();\n    }\n    ngAfterContentInit() {\n      this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n      this._tree._getDirectChildren(this.data).pipe(takeUntil(this._destroyed)).subscribe(result => this.updateChildrenNodes(result));\n      this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(() => this.updateChildrenNodes());\n    }\n    ngOnDestroy() {\n      this._clear();\n      super.ngOnDestroy();\n    }\n    updateChildrenNodes(children) {\n      const outlet = this._getNodeOutlet();\n      if (children) {\n        this._children = children;\n      }\n      if (outlet && this._children) {\n        const viewContainer = outlet.viewContainer;\n        this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n      } else {\n        this._dataDiffer.diff([]);\n      }\n    }\n    _clear() {\n      const outlet = this._getNodeOutlet();\n      if (outlet) {\n        outlet.viewContainer.clear();\n        this._dataDiffer.diff([]);\n      }\n    }\n    _getNodeOutlet() {\n      const outlets = this.nodeOutlet;\n      return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n    }\n    static ɵfac = function CdkNestedTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkNestedTreeNode)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkNestedTreeNode,\n      selectors: [[\"cdk-nested-tree-node\"]],\n      contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeOutlet = _t);\n        }\n      },\n      hostAttrs: [1, \"cdk-nested-tree-node\"],\n      exportAs: [\"cdkNestedTreeNode\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNode,\n        useExisting: CdkNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: CdkNestedTreeNode\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return CdkNestedTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst cssUnitPattern = /([A-Za-z%]+)$/;\nlet CdkTreeNodePadding = /*#__PURE__*/(() => {\n  class CdkTreeNodePadding {\n    _treeNode = inject(CdkTreeNode);\n    _tree = inject(CdkTree);\n    _element = inject(ElementRef);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _currentPadding;\n    _destroyed = new Subject();\n    indentUnits = 'px';\n    get level() {\n      return this._level;\n    }\n    set level(value) {\n      this._setLevelInput(value);\n    }\n    _level;\n    get indent() {\n      return this._indent;\n    }\n    set indent(indent) {\n      this._setIndentInput(indent);\n    }\n    _indent = 40;\n    constructor() {\n      this._setPadding();\n      this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n      this._treeNode._dataChanges.subscribe(() => this._setPadding());\n    }\n    ngOnDestroy() {\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    _paddingIndent() {\n      const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;\n      const level = this._level == null ? nodeLevel : this._level;\n      return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n    }\n    _setPadding(forceChange = false) {\n      const padding = this._paddingIndent();\n      if (padding !== this._currentPadding || forceChange) {\n        const element = this._element.nativeElement;\n        const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n        const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n        element.style[paddingProp] = padding || '';\n        element.style[resetProp] = '';\n        this._currentPadding = padding;\n      }\n    }\n    _setLevelInput(value) {\n      this._level = isNaN(value) ? null : value;\n      this._setPadding();\n    }\n    _setIndentInput(indent) {\n      let value = indent;\n      let units = 'px';\n      if (typeof indent === 'string') {\n        const parts = indent.split(cssUnitPattern);\n        value = parts[0];\n        units = parts[1] || units;\n      }\n      this.indentUnits = units;\n      this._indent = numberAttribute(value);\n      this._setPadding();\n    }\n    static ɵfac = function CdkTreeNodePadding_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodePadding)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodePadding,\n      selectors: [[\"\", \"cdkTreeNodePadding\", \"\"]],\n      inputs: {\n        level: [2, \"cdkTreeNodePadding\", \"level\", numberAttribute],\n        indent: [0, \"cdkTreeNodePaddingIndent\", \"indent\"]\n      }\n    });\n  }\n  return CdkTreeNodePadding;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkTreeNodeToggle = /*#__PURE__*/(() => {\n  class CdkTreeNodeToggle {\n    _tree = inject(CdkTree);\n    _treeNode = inject(CdkTreeNode);\n    recursive = false;\n    constructor() {}\n    _toggle() {\n      this.recursive ? this._tree.toggleDescendants(this._treeNode.data) : this._tree.toggle(this._treeNode.data);\n      this._tree._keyManager.focusItem(this._treeNode);\n    }\n    static ɵfac = function CdkTreeNodeToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeToggle)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeToggle,\n      selectors: [[\"\", \"cdkTreeNodeToggle\", \"\"]],\n      hostAttrs: [\"tabindex\", \"-1\"],\n      hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function CdkTreeNodeToggle_click_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.stopPropagation();\n          })(\"keydown.Enter\", function CdkTreeNodeToggle_keydown_Enter_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          })(\"keydown.Space\", function CdkTreeNodeToggle_keydown_Space_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          });\n        }\n      },\n      inputs: {\n        recursive: [2, \"cdkTreeNodeToggleRecursive\", \"recursive\", booleanAttribute]\n      }\n    });\n  }\n  return CdkTreeNodeToggle;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\nlet CdkTreeModule = /*#__PURE__*/(() => {\n  class CdkTreeModule {\n    static ɵfac = function CdkTreeModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CdkTreeModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return CdkTreeModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { BaseTreeControl, CDK_TREE_NODE_OUTLET_NODE, CdkNestedTreeNode, CdkTree, CdkTreeModule, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeOutletContext, CdkTreeNodePadding, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl, getMultipleTreeControlsError, getTreeControlMissingError, getTreeMissingMatchingNodeDefError, getTreeMultipleDefaultNodeDefsError, getTreeNoValidDataSourceError };\n//# sourceMappingURL=tree.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}