{"ast":null,"code":"/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nconst _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + '(([\\\\.\\\\#]?)[-\\\\w]+)|' + '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\"\\']?)([^\\\\]\"\\']*)\\\\5)?\\\\])|' + '(\\\\))|' + '(\\\\s*,\\\\s*)', 'g');\nclass CssSelector {\n  element = null;\n  classNames = [];\n  attrs = [];\n  notSelectors = [];\n  static parse(selector) {\n    const results = [];\n    const _addResult = (res, cssSel) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[1]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[2];\n      if (tag) {\n        const prefix = match[3];\n        if (prefix === '#') {\n          current.addAttribute('id', tag.slice(1));\n        } else if (prefix === '.') {\n          current.addClassName(tag.slice(1));\n        } else {\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[4];\n      if (attribute) {\n        current.addAttribute(current.unescapeAttribute(attribute), match[6]);\n      }\n      if (match[7]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[8]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n  unescapeAttribute(attr) {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(`Error in attribute selector \"${attr}\". ` + `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n  escapeAttribute(attr) {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n  isElementSelector() {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;\n  }\n  hasElementSelector() {\n    return !!this.element;\n  }\n  setElement(element = null) {\n    this.element = element;\n  }\n  getAttrs() {\n    const result = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n  addAttribute(name, value = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n  addClassName(name) {\n    this.classNames.push(name.toLowerCase());\n  }\n  toString() {\n    let res = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\nclass SelectorMatcher {\n  static createNotMatcher(notSelectors) {\n    const notMatcher = new SelectorMatcher();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n  _elementMap = new Map();\n  _elementPartialMap = new Map();\n  _classMap = new Map();\n  _classPartialMap = new Map();\n  _attrValueMap = new Map();\n  _attrValuePartialMap = new Map();\n  _listContexts = [];\n  addSelectables(cssSelectors, callbackCtxt) {\n    let listContext = null;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n    }\n  }\n  _addSelectable(cssSelector, callbackCtxt, listContext) {\n    let matcher = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n  _addTerminal(map, name, selectable) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n  _addPartial(map, name) {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n  match(cssSelector, matchedCallback) {\n    let result = false;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;\n      }\n    }\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        const terminalValuesMap = this._attrValueMap.get(name);\n        if (value) {\n          result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n        const partialValuesMap = this._attrValuePartialMap.get(name);\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n  _matchTerminal(map, name, cssSelector, matchedCallback) {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n    let selectables = map.get(name) || [];\n    const starSelectables = map.get('*');\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n  _matchPartial(map, name, cssSelector, matchedCallback) {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\nclass SelectorListContext {\n  selectors;\n  alreadyMatched = false;\n  constructor(selectors) {\n    this.selectors = selectors;\n  }\n}\nclass SelectorContext {\n  selector;\n  cbContext;\n  listContext;\n  notSelectors;\n  constructor(selector, cbContext, listContext) {\n    this.selector = selector;\n    this.cbContext = cbContext;\n    this.listContext = listContext;\n    this.notSelectors = selector.notSelectors;\n  }\n  finalize(cssSelector, callback) {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\nclass SelectorlessMatcher {\n  registry;\n  constructor(registry) {\n    this.registry = registry;\n  }\n  match(name) {\n    return this.registry.has(name) ? this.registry.get(name) : [];\n  }\n}\nconst emitDistinctChangesOnlyDefaultValue = true;\nvar ViewEncapsulation$1 = /*#__PURE__*/function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n  ViewEncapsulation[ViewEncapsulation[\"ExperimentalIsolatedShadowDom\"] = 4] = \"ExperimentalIsolatedShadowDom\";\n  return ViewEncapsulation;\n}(ViewEncapsulation$1 || {});\nvar ChangeDetectionStrategy = /*#__PURE__*/function (ChangeDetectionStrategy) {\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n  return ChangeDetectionStrategy;\n}(ChangeDetectionStrategy || {});\nvar InputFlags = /*#__PURE__*/function (InputFlags) {\n  InputFlags[InputFlags[\"None\"] = 0] = \"None\";\n  InputFlags[InputFlags[\"SignalBased\"] = 1] = \"SignalBased\";\n  InputFlags[InputFlags[\"HasDecoratorInputTransform\"] = 2] = \"HasDecoratorInputTransform\";\n  return InputFlags;\n}(InputFlags || {});\nconst CUSTOM_ELEMENTS_SCHEMA = {\n  name: 'custom-elements'\n};\nconst NO_ERRORS_SCHEMA = {\n  name: 'no-errors-schema'\n};\nconst Type$1 = Function;\nvar SecurityContext = /*#__PURE__*/function (SecurityContext) {\n  SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n  SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n  SecurityContext[SecurityContext[\"ATTRIBUTE_NO_BINDING\"] = 6] = \"ATTRIBUTE_NO_BINDING\";\n  return SecurityContext;\n}(SecurityContext || {});\nvar MissingTranslationStrategy = /*#__PURE__*/function (MissingTranslationStrategy) {\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n  return MissingTranslationStrategy;\n}(MissingTranslationStrategy || {});\nfunction parserSelectorToSimpleSelector(selector) {\n  const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\nfunction parserSelectorToNegativeSelector(selector) {\n  const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];\n  if (selector.element) {\n    return [1 | 4, selector.element, ...selector.attrs, ...classes];\n  } else if (selector.attrs.length) {\n    return [1 | 2, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length ? [1 | 8, ...selector.classNames] : [];\n  }\n}\nfunction parserSelectorToR3Selector(selector) {\n  const positive = parserSelectorToSimpleSelector(selector);\n  const negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) : [];\n  return positive.concat(...negative);\n}\nfunction parseSelectorToR3Selector(selector) {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\nvar core = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n  get ChangeDetectionStrategy() {\n    return ChangeDetectionStrategy;\n  },\n  get InputFlags() {\n    return InputFlags;\n  },\n  get MissingTranslationStrategy() {\n    return MissingTranslationStrategy;\n  },\n  NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n  get SecurityContext() {\n    return SecurityContext;\n  },\n  Type: Type$1,\n  get ViewEncapsulation() {\n    return ViewEncapsulation$1;\n  },\n  emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,\n  parseSelectorToR3Selector: parseSelectorToR3Selector\n});\nvar FactoryTarget = /*#__PURE__*/function (FactoryTarget) {\n  FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n  FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n  return FactoryTarget;\n}(FactoryTarget || {});\nvar R3TemplateDependencyKind$1 = /*#__PURE__*/function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n  return R3TemplateDependencyKind;\n}(R3TemplateDependencyKind$1 || {});\nvar ViewEncapsulation = /*#__PURE__*/function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n  ViewEncapsulation[ViewEncapsulation[\"ExperimentalIsolatedShadowDom\"] = 4] = \"ExperimentalIsolatedShadowDom\";\n  return ViewEncapsulation;\n}(ViewEncapsulation || {});\nlet textEncoder;\nfunction digest$1(message) {\n  return message.id || computeDigest(message);\n}\nfunction computeDigest(message) {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\nfunction decimalDigest(message) {\n  return message.id || computeDecimalDigest(message);\n}\nfunction computeDecimalDigest(message) {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\nclass _SerializerVisitor {\n  visitText(text, context) {\n    return text.value;\n  }\n  visitContainer(container, context) {\n    return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n  }\n  visitIcu(icu, context) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n  visitTagPlaceholder(ph, context) {\n    return ph.isVoid ? `<ph tag name=\"${ph.startName}\"/>` : `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n  visitPlaceholder(ph, context) {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n  visitBlockPlaceholder(ph, context) {\n    return `<ph block name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n}\nconst serializerVisitor$1 = new _SerializerVisitor();\nfunction serializeNodes(nodes) {\n  return nodes.map(a => a.visit(serializerVisitor$1, null));\n}\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  visitIcu(icu) {\n    let strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\nfunction sha1(str) {\n  textEncoder ??= new TextEncoder();\n  const utf8 = [...textEncoder.encode(str)];\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n  const w = new Uint32Array(80);\n  let a = 0x67452301,\n    b = 0xefcdab89,\n    c = 0x98badcfe,\n    d = 0x10325476,\n    e = 0xc3d2e1f0;\n  words32[len >> 5] |= 0x80 << 24 - len % 32;\n  words32[(len + 64 >> 9 << 4) + 15] = len;\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a,\n      h1 = b,\n      h2 = c,\n      h3 = d,\n      h4 = e;\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n  return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\nfunction toHexU32(value) {\n  return (value >>> 0).toString(16).padStart(8, '0');\n}\nfunction fk(index, b, c, d) {\n  if (index < 20) {\n    return [b & c | ~b & d, 0x5a827999];\n  }\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n  if (index < 60) {\n    return [b & c | b & d | c & d, 0x8f1bbcdc];\n  }\n  return [b ^ c ^ d, 0xca62c1d6];\n}\nfunction fingerprint(str) {\n  textEncoder ??= new TextEncoder();\n  const utf8 = textEncoder.encode(str);\n  const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n  let hi = hash32(view, utf8.length, 0);\n  let lo = hash32(view, utf8.length, 102072);\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n  return BigInt.asUintN(32, BigInt(hi)) << BigInt(32) | BigInt.asUintN(32, BigInt(lo));\n}\nfunction computeMsgId(msg, meaning = '') {\n  let msgFingerprint = fingerprint(msg);\n  if (meaning) {\n    msgFingerprint = BigInt.asUintN(64, msgFingerprint << BigInt(1)) | msgFingerprint >> BigInt(63) & BigInt(1);\n    msgFingerprint += fingerprint(meaning);\n  }\n  return BigInt.asUintN(63, msgFingerprint).toString();\n}\nfunction hash32(view, length, c) {\n  let a = 0x9e3779b9,\n    b = 0x9e3779b9;\n  let index = 0;\n  const end = length - 12;\n  for (; index <= end; index += 12) {\n    a += view.getUint32(index, true);\n    b += view.getUint32(index + 4, true);\n    c += view.getUint32(index + 8, true);\n    const res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n  const remainder = length - index;\n  c += length;\n  if (remainder >= 4) {\n    a += view.getUint32(index, true);\n    index += 4;\n    if (remainder >= 8) {\n      b += view.getUint32(index, true);\n      index += 4;\n      if (remainder >= 9) {\n        c += view.getUint8(index++) << 8;\n      }\n      if (remainder >= 10) {\n        c += view.getUint8(index++) << 16;\n      }\n      if (remainder === 11) {\n        c += view.getUint8(index++) << 24;\n      }\n    } else {\n      if (remainder >= 5) {\n        b += view.getUint8(index++);\n      }\n      if (remainder >= 6) {\n        b += view.getUint8(index++) << 8;\n      }\n      if (remainder === 7) {\n        b += view.getUint8(index++) << 16;\n      }\n    }\n  } else {\n    if (remainder >= 1) {\n      a += view.getUint8(index++);\n    }\n    if (remainder >= 2) {\n      a += view.getUint8(index++) << 8;\n    }\n    if (remainder === 3) {\n      a += view.getUint8(index++) << 16;\n    }\n  }\n  return mix(a, b, c)[2];\n}\nfunction mix(a, b, c) {\n  a -= b;\n  a -= c;\n  a ^= c >>> 13;\n  b -= c;\n  b -= a;\n  b ^= a << 8;\n  c -= a;\n  c -= b;\n  c ^= b >>> 13;\n  a -= b;\n  a -= c;\n  a ^= c >>> 12;\n  b -= c;\n  b -= a;\n  b ^= a << 16;\n  c -= a;\n  c -= b;\n  c ^= b >>> 5;\n  a -= b;\n  a -= c;\n  a ^= c >>> 3;\n  b -= c;\n  b -= a;\n  b ^= a << 10;\n  c -= a;\n  c -= b;\n  c ^= b >>> 15;\n  return [a, b, c];\n}\nvar Endian = /*#__PURE__*/function (Endian) {\n  Endian[Endian[\"Little\"] = 0] = \"Little\";\n  Endian[Endian[\"Big\"] = 1] = \"Big\";\n  return Endian;\n}(Endian || {});\nfunction add32(a, b) {\n  return add32to64(a, b)[1];\n}\nfunction add32to64(a, b) {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, high << 16 | low & 0xffff];\n}\nfunction rol32(a, count) {\n  return a << count | a >>> 32 - count;\n}\nfunction bytesToWords32(bytes, endian) {\n  const size = bytes.length + 3 >>> 2;\n  const words32 = [];\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n  return words32;\n}\nfunction byteAt(bytes, index) {\n  return index >= bytes.length ? 0 : bytes[index];\n}\nfunction wordAt(bytes, index, endian) {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 24 - 8 * i;\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 8 * i;\n    }\n  }\n  return word;\n}\nvar TypeModifier = /*#__PURE__*/function (TypeModifier) {\n  TypeModifier[TypeModifier[\"None\"] = 0] = \"None\";\n  TypeModifier[TypeModifier[\"Const\"] = 1] = \"Const\";\n  return TypeModifier;\n}(TypeModifier || {});\nclass Type {\n  modifiers;\n  constructor(modifiers = TypeModifier.None) {\n    this.modifiers = modifiers;\n  }\n  hasModifier(modifier) {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\nvar BuiltinTypeName = /*#__PURE__*/function (BuiltinTypeName) {\n  BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n  BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n  BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n  BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n  BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n  BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n  BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n  BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n  return BuiltinTypeName;\n}(BuiltinTypeName || {});\nclass BuiltinType extends Type {\n  name;\n  constructor(name, modifiers) {\n    super(modifiers);\n    this.name = name;\n  }\n  visitType(visitor, context) {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\nclass ExpressionType extends Type {\n  value;\n  typeParams;\n  constructor(value, modifiers, typeParams = null) {\n    super(modifiers);\n    this.value = value;\n    this.typeParams = typeParams;\n  }\n  visitType(visitor, context) {\n    return visitor.visitExpressionType(this, context);\n  }\n}\nclass ArrayType extends Type {\n  of;\n  constructor(of, modifiers) {\n    super(modifiers);\n    this.of = of;\n  }\n  visitType(visitor, context) {\n    return visitor.visitArrayType(this, context);\n  }\n}\nclass MapType extends Type {\n  valueType;\n  constructor(valueType, modifiers) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  visitType(visitor, context) {\n    return visitor.visitMapType(this, context);\n  }\n}\nclass TransplantedType extends Type {\n  type;\n  constructor(type, modifiers) {\n    super(modifiers);\n    this.type = type;\n  }\n  visitType(visitor, context) {\n    return visitor.visitTransplantedType(this, context);\n  }\n}\nconst DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nconst INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nconst BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nconst INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nconst NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nconst STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nconst FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nconst NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\nvar UnaryOperator = /*#__PURE__*/function (UnaryOperator) {\n  UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n  UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\n  return UnaryOperator;\n}(UnaryOperator || {});\nvar BinaryOperator = /*#__PURE__*/function (BinaryOperator) {\n  BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n  BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n  BinaryOperator[BinaryOperator[\"Assign\"] = 2] = \"Assign\";\n  BinaryOperator[BinaryOperator[\"Identical\"] = 3] = \"Identical\";\n  BinaryOperator[BinaryOperator[\"NotIdentical\"] = 4] = \"NotIdentical\";\n  BinaryOperator[BinaryOperator[\"Minus\"] = 5] = \"Minus\";\n  BinaryOperator[BinaryOperator[\"Plus\"] = 6] = \"Plus\";\n  BinaryOperator[BinaryOperator[\"Divide\"] = 7] = \"Divide\";\n  BinaryOperator[BinaryOperator[\"Multiply\"] = 8] = \"Multiply\";\n  BinaryOperator[BinaryOperator[\"Modulo\"] = 9] = \"Modulo\";\n  BinaryOperator[BinaryOperator[\"And\"] = 10] = \"And\";\n  BinaryOperator[BinaryOperator[\"Or\"] = 11] = \"Or\";\n  BinaryOperator[BinaryOperator[\"BitwiseOr\"] = 12] = \"BitwiseOr\";\n  BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 13] = \"BitwiseAnd\";\n  BinaryOperator[BinaryOperator[\"Lower\"] = 14] = \"Lower\";\n  BinaryOperator[BinaryOperator[\"LowerEquals\"] = 15] = \"LowerEquals\";\n  BinaryOperator[BinaryOperator[\"Bigger\"] = 16] = \"Bigger\";\n  BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 17] = \"BiggerEquals\";\n  BinaryOperator[BinaryOperator[\"NullishCoalesce\"] = 18] = \"NullishCoalesce\";\n  BinaryOperator[BinaryOperator[\"Exponentiation\"] = 19] = \"Exponentiation\";\n  BinaryOperator[BinaryOperator[\"In\"] = 20] = \"In\";\n  BinaryOperator[BinaryOperator[\"AdditionAssignment\"] = 21] = \"AdditionAssignment\";\n  BinaryOperator[BinaryOperator[\"SubtractionAssignment\"] = 22] = \"SubtractionAssignment\";\n  BinaryOperator[BinaryOperator[\"MultiplicationAssignment\"] = 23] = \"MultiplicationAssignment\";\n  BinaryOperator[BinaryOperator[\"DivisionAssignment\"] = 24] = \"DivisionAssignment\";\n  BinaryOperator[BinaryOperator[\"RemainderAssignment\"] = 25] = \"RemainderAssignment\";\n  BinaryOperator[BinaryOperator[\"ExponentiationAssignment\"] = 26] = \"ExponentiationAssignment\";\n  BinaryOperator[BinaryOperator[\"AndAssignment\"] = 27] = \"AndAssignment\";\n  BinaryOperator[BinaryOperator[\"OrAssignment\"] = 28] = \"OrAssignment\";\n  BinaryOperator[BinaryOperator[\"NullishCoalesceAssignment\"] = 29] = \"NullishCoalesceAssignment\";\n  return BinaryOperator;\n}(BinaryOperator || {});\nfunction nullSafeIsEquivalent(base, other) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\nfunction areAllEquivalentPredicate(base, other, equivalentPredicate) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction areAllEquivalent(base, other) {\n  return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));\n}\nclass Expression {\n  type;\n  sourceSpan;\n  constructor(type, sourceSpan) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n  prop(name, sourceSpan) {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n  key(index, type, sourceSpan) {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n  callFn(params, sourceSpan, pure) {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n  instantiate(params, type, sourceSpan) {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n  conditional(trueCase, falseCase = null, sourceSpan) {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n  equals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  power(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Exponentiation, this, rhs, null, sourceSpan);\n  }\n  and(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseOr(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseOr, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan);\n  }\n  or(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan) {\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n  toStmt() {\n    return new ExpressionStatement(this, null);\n  }\n}\nclass ReadVarExpr extends Expression {\n  name;\n  constructor(name, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.name = name;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadVarExpr(this, context);\n  }\n  clone() {\n    return new ReadVarExpr(this.name, this.type, this.sourceSpan);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this, value, null, this.sourceSpan);\n  }\n}\nclass TypeofExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new TypeofExpr(this.expr.clone());\n  }\n}\nclass VoidExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitVoidExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof VoidExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new VoidExpr(this.expr.clone());\n  }\n}\nclass WrappedNodeExpr extends Expression {\n  node;\n  constructor(node, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.node = node;\n  }\n  isEquivalent(e) {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n  clone() {\n    return new WrappedNodeExpr(this.node, this.type, this.sourceSpan);\n  }\n}\nclass InvokeFunctionExpr extends Expression {\n  fn;\n  args;\n  pure;\n  constructor(fn, args, type, sourceSpan, pure = false) {\n    super(type, sourceSpan);\n    this.fn = fn;\n    this.args = args;\n    this.pure = pure;\n  }\n  get receiver() {\n    return this.fn;\n  }\n  isEquivalent(e) {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n  clone() {\n    return new InvokeFunctionExpr(this.fn.clone(), this.args.map(arg => arg.clone()), this.type, this.sourceSpan, this.pure);\n  }\n}\nclass TaggedTemplateLiteralExpr extends Expression {\n  tag;\n  template;\n  constructor(tag, template, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.tag = tag;\n    this.template = template;\n  }\n  isEquivalent(e) {\n    return e instanceof TaggedTemplateLiteralExpr && this.tag.isEquivalent(e.tag) && this.template.isEquivalent(e.template);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTaggedTemplateLiteralExpr(this, context);\n  }\n  clone() {\n    return new TaggedTemplateLiteralExpr(this.tag.clone(), this.template.clone(), this.type, this.sourceSpan);\n  }\n}\nclass InstantiateExpr extends Expression {\n  classExpr;\n  args;\n  constructor(classExpr, args, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.classExpr = classExpr;\n    this.args = args;\n  }\n  isEquivalent(e) {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n  clone() {\n    return new InstantiateExpr(this.classExpr.clone(), this.args.map(arg => arg.clone()), this.type, this.sourceSpan);\n  }\n}\nclass RegularExpressionLiteralExpr extends Expression {\n  body;\n  flags;\n  constructor(body, flags, sourceSpan) {\n    super(null, sourceSpan);\n    this.body = body;\n    this.flags = flags;\n  }\n  isEquivalent(e) {\n    return e instanceof RegularExpressionLiteralExpr && this.body === e.body && this.flags === e.flags;\n  }\n  isConstant() {\n    return true;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitRegularExpressionLiteral(this, context);\n  }\n  clone() {\n    return new RegularExpressionLiteralExpr(this.body, this.flags, this.sourceSpan);\n  }\n}\nclass LiteralExpr extends Expression {\n  value;\n  constructor(value, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.value = value;\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n  isConstant() {\n    return true;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralExpr(this, context);\n  }\n  clone() {\n    return new LiteralExpr(this.value, this.type, this.sourceSpan);\n  }\n}\nclass TemplateLiteralExpr extends Expression {\n  elements;\n  expressions;\n  constructor(elements, expressions, sourceSpan) {\n    super(null, sourceSpan);\n    this.elements = elements;\n    this.expressions = expressions;\n  }\n  isEquivalent(e) {\n    return e instanceof TemplateLiteralExpr && areAllEquivalentPredicate(this.elements, e.elements, (a, b) => a.text === b.text) && areAllEquivalent(this.expressions, e.expressions);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTemplateLiteralExpr(this, context);\n  }\n  clone() {\n    return new TemplateLiteralExpr(this.elements.map(el => el.clone()), this.expressions.map(expr => expr.clone()));\n  }\n}\nclass TemplateLiteralElementExpr extends Expression {\n  text;\n  rawText;\n  constructor(text, sourceSpan, rawText) {\n    super(STRING_TYPE, sourceSpan);\n    this.text = text;\n    this.rawText = rawText ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTemplateLiteralElementExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof TemplateLiteralElementExpr && e.text === this.text && e.rawText === this.rawText;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new TemplateLiteralElementExpr(this.text, this.sourceSpan, this.rawText);\n  }\n}\nclass LiteralPiece {\n  text;\n  sourceSpan;\n  constructor(text, sourceSpan) {\n    this.text = text;\n    this.sourceSpan = sourceSpan;\n  }\n}\nclass PlaceholderPiece {\n  text;\n  sourceSpan;\n  associatedMessage;\n  constructor(text, sourceSpan, associatedMessage) {\n    this.text = text;\n    this.sourceSpan = sourceSpan;\n    this.associatedMessage = associatedMessage;\n  }\n}\nconst MEANING_SEPARATOR$1 = '|';\nconst ID_SEPARATOR$1 = '@@';\nconst LEGACY_ID_INDICATOR = 'âŸ';\nclass LocalizedString extends Expression {\n  metaBlock;\n  messageParts;\n  placeHolderNames;\n  expressions;\n  constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n    super(STRING_TYPE, sourceSpan);\n    this.metaBlock = metaBlock;\n    this.messageParts = messageParts;\n    this.placeHolderNames = placeHolderNames;\n    this.expressions = expressions;\n  }\n  isEquivalent(e) {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLocalizedString(this, context);\n  }\n  clone() {\n    return new LocalizedString(this.metaBlock, this.messageParts, this.placeHolderNames, this.expressions.map(expr => expr.clone()), this.sourceSpan);\n  }\n  serializeI18nHead() {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR$1}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR$1}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(legacyId => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n  }\n  getMessagePartSourceSpan(i) {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n  getPlaceholderSourceSpan(i) {\n    return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ?? this.sourceSpan;\n  }\n  serializeI18nTemplatePart(partIndex) {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR$1}${computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n    }\n    return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n  }\n}\nconst escapeSlashes = str => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = str => str.replace(/^:/, '\\\\:');\nconst escapeColons = str => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = str => str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\nfunction createCookedRawString(metaBlock, messagePart, range) {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n      range\n    };\n  }\n}\nclass ExternalExpr extends Expression {\n  value;\n  typeParams;\n  constructor(value, type, typeParams = null, sourceSpan) {\n    super(type, sourceSpan);\n    this.value = value;\n    this.typeParams = typeParams;\n  }\n  isEquivalent(e) {\n    return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitExternalExpr(this, context);\n  }\n  clone() {\n    return new ExternalExpr(this.value, this.type, this.typeParams, this.sourceSpan);\n  }\n}\nclass ExternalReference {\n  moduleName;\n  name;\n  constructor(moduleName, name) {\n    this.moduleName = moduleName;\n    this.name = name;\n  }\n}\nclass ConditionalExpr extends Expression {\n  condition;\n  falseCase;\n  trueCase;\n  constructor(condition, trueCase, falseCase = null, type, sourceSpan) {\n    super(type || trueCase.type, sourceSpan);\n    this.condition = condition;\n    this.falseCase = falseCase;\n    this.trueCase = trueCase;\n  }\n  isEquivalent(e) {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitConditionalExpr(this, context);\n  }\n  clone() {\n    return new ConditionalExpr(this.condition.clone(), this.trueCase.clone(), this.falseCase?.clone(), this.type, this.sourceSpan);\n  }\n}\nclass DynamicImportExpr extends Expression {\n  url;\n  urlComment;\n  constructor(url, sourceSpan, urlComment) {\n    super(null, sourceSpan);\n    this.url = url;\n    this.urlComment = urlComment;\n  }\n  isEquivalent(e) {\n    return e instanceof DynamicImportExpr && this.url === e.url && this.urlComment === e.urlComment;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitDynamicImportExpr(this, context);\n  }\n  clone() {\n    return new DynamicImportExpr(typeof this.url === 'string' ? this.url : this.url.clone(), this.sourceSpan, this.urlComment);\n  }\n}\nclass NotExpr extends Expression {\n  condition;\n  constructor(condition, sourceSpan) {\n    super(BOOL_TYPE, sourceSpan);\n    this.condition = condition;\n  }\n  isEquivalent(e) {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitNotExpr(this, context);\n  }\n  clone() {\n    return new NotExpr(this.condition.clone(), this.sourceSpan);\n  }\n}\nclass FnParam {\n  name;\n  type;\n  constructor(name, type = null) {\n    this.name = name;\n    this.type = type;\n  }\n  isEquivalent(param) {\n    return this.name === param.name;\n  }\n  clone() {\n    return new FnParam(this.name, this.type);\n  }\n}\nclass FunctionExpr extends Expression {\n  params;\n  statements;\n  name;\n  constructor(params, statements, type, sourceSpan, name) {\n    super(type, sourceSpan);\n    this.params = params;\n    this.statements = statements;\n    this.name = name;\n  }\n  isEquivalent(e) {\n    return (e instanceof FunctionExpr || e instanceof DeclareFunctionStmt) && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitFunctionExpr(this, context);\n  }\n  toDeclStmt(name, modifiers) {\n    return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n  clone() {\n    return new FunctionExpr(this.params.map(p => p.clone()), this.statements, this.type, this.sourceSpan, this.name);\n  }\n}\nclass ArrowFunctionExpr extends Expression {\n  params;\n  body;\n  constructor(params, body, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.params = params;\n    this.body = body;\n  }\n  isEquivalent(e) {\n    if (!(e instanceof ArrowFunctionExpr) || !areAllEquivalent(this.params, e.params)) {\n      return false;\n    }\n    if (this.body instanceof Expression && e.body instanceof Expression) {\n      return this.body.isEquivalent(e.body);\n    }\n    if (Array.isArray(this.body) && Array.isArray(e.body)) {\n      return areAllEquivalent(this.body, e.body);\n    }\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitArrowFunctionExpr(this, context);\n  }\n  clone() {\n    return new ArrowFunctionExpr(this.params.map(p => p.clone()), Array.isArray(this.body) ? this.body : this.body.clone(), this.type, this.sourceSpan);\n  }\n  toDeclStmt(name, modifiers) {\n    return new DeclareVarStmt(name, this, INFERRED_TYPE, modifiers, this.sourceSpan);\n  }\n}\nclass UnaryOperatorExpr extends Expression {\n  operator;\n  expr;\n  parens;\n  constructor(operator, expr, type, sourceSpan, parens = true) {\n    super(type || NUMBER_TYPE, sourceSpan);\n    this.operator = operator;\n    this.expr = expr;\n    this.parens = parens;\n  }\n  isEquivalent(e) {\n    return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n  clone() {\n    return new UnaryOperatorExpr(this.operator, this.expr.clone(), this.type, this.sourceSpan, this.parens);\n  }\n}\nclass ParenthesizedExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitParenthesizedExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof ParenthesizedExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new ParenthesizedExpr(this.expr.clone());\n  }\n}\nclass BinaryOperatorExpr extends Expression {\n  operator;\n  rhs;\n  lhs;\n  constructor(operator, lhs, rhs, type, sourceSpan) {\n    super(type || lhs.type, sourceSpan);\n    this.operator = operator;\n    this.rhs = rhs;\n    this.lhs = lhs;\n  }\n  isEquivalent(e) {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n  clone() {\n    return new BinaryOperatorExpr(this.operator, this.lhs.clone(), this.rhs.clone(), this.type, this.sourceSpan);\n  }\n  isAssignment() {\n    const op = this.operator;\n    return op === BinaryOperator.Assign || op === BinaryOperator.AdditionAssignment || op === BinaryOperator.SubtractionAssignment || op === BinaryOperator.MultiplicationAssignment || op === BinaryOperator.DivisionAssignment || op === BinaryOperator.RemainderAssignment || op === BinaryOperator.ExponentiationAssignment || op === BinaryOperator.AndAssignment || op === BinaryOperator.OrAssignment || op === BinaryOperator.NullishCoalesceAssignment;\n  }\n}\nclass ReadPropExpr extends Expression {\n  receiver;\n  name;\n  constructor(receiver, name, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  get index() {\n    return this.name;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadPropExpr(this, context);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this.receiver.prop(this.name), value, null, this.sourceSpan);\n  }\n  clone() {\n    return new ReadPropExpr(this.receiver.clone(), this.name, this.type, this.sourceSpan);\n  }\n}\nclass ReadKeyExpr extends Expression {\n  receiver;\n  index;\n  constructor(receiver, index, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.receiver = receiver;\n    this.index = index;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this.receiver.key(this.index), value, null, this.sourceSpan);\n  }\n  clone() {\n    return new ReadKeyExpr(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan);\n  }\n}\nclass LiteralArrayExpr extends Expression {\n  entries;\n  constructor(entries, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n  isConstant() {\n    return this.entries.every(e => e.isConstant());\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n  clone() {\n    return new LiteralArrayExpr(this.entries.map(e => e.clone()), this.type, this.sourceSpan);\n  }\n}\nclass LiteralMapEntry {\n  key;\n  value;\n  quoted;\n  constructor(key, value, quoted) {\n    this.key = key;\n    this.value = value;\n    this.quoted = quoted;\n  }\n  isEquivalent(e) {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n  clone() {\n    return new LiteralMapEntry(this.key, this.value.clone(), this.quoted);\n  }\n}\nclass LiteralMapExpr extends Expression {\n  entries;\n  valueType = null;\n  constructor(entries, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.entries = entries;\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  isConstant() {\n    return this.entries.every(e => e.value.isConstant());\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n  clone() {\n    const entriesClone = this.entries.map(entry => entry.clone());\n    return new LiteralMapExpr(entriesClone, this.type, this.sourceSpan);\n  }\n}\nclass CommaExpr extends Expression {\n  parts;\n  constructor(parts, sourceSpan) {\n    super(parts[parts.length - 1].type, sourceSpan);\n    this.parts = parts;\n  }\n  isEquivalent(e) {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitCommaExpr(this, context);\n  }\n  clone() {\n    return new CommaExpr(this.parts.map(p => p.clone()));\n  }\n}\nconst NULL_EXPR = new LiteralExpr(null, null, null);\nconst TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\nvar StmtModifier = /*#__PURE__*/function (StmtModifier) {\n  StmtModifier[StmtModifier[\"None\"] = 0] = \"None\";\n  StmtModifier[StmtModifier[\"Final\"] = 1] = \"Final\";\n  StmtModifier[StmtModifier[\"Private\"] = 2] = \"Private\";\n  StmtModifier[StmtModifier[\"Exported\"] = 4] = \"Exported\";\n  StmtModifier[StmtModifier[\"Static\"] = 8] = \"Static\";\n  return StmtModifier;\n}(StmtModifier || {});\nclass LeadingComment {\n  text;\n  multiline;\n  trailingNewline;\n  constructor(text, multiline, trailingNewline) {\n    this.text = text;\n    this.multiline = multiline;\n    this.trailingNewline = trailingNewline;\n  }\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nclass JSDocComment extends LeadingComment {\n  tags;\n  constructor(tags) {\n    super('', true, true);\n    this.tags = tags;\n  }\n  toString() {\n    return serializeTags(this.tags);\n  }\n}\nclass Statement {\n  modifiers;\n  sourceSpan;\n  leadingComments;\n  constructor(modifiers = StmtModifier.None, sourceSpan = null, leadingComments) {\n    this.modifiers = modifiers;\n    this.sourceSpan = sourceSpan;\n    this.leadingComments = leadingComments;\n  }\n  hasModifier(modifier) {\n    return (this.modifiers & modifier) !== 0;\n  }\n  addLeadingComment(leadingComment) {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\nclass DeclareVarStmt extends Statement {\n  name;\n  value;\n  type;\n  constructor(name, value, type, modifiers, sourceSpan, leadingComments) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.name = name;\n    this.value = value;\n    this.type = type || value && value.type || null;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\nclass DeclareFunctionStmt extends Statement {\n  name;\n  params;\n  statements;\n  type;\n  constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.name = name;\n    this.params = params;\n    this.statements = statements;\n    this.type = type || null;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\nclass ExpressionStatement extends Statement {\n  expr;\n  constructor(expr, sourceSpan, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.expr = expr;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\nclass ReturnStatement extends Statement {\n  value;\n  constructor(value, sourceSpan = null, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.value = value;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\nclass IfStmt extends Statement {\n  condition;\n  trueCase;\n  falseCase;\n  constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.condition = condition;\n    this.trueCase = trueCase;\n    this.falseCase = falseCase;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitIfStmt(this, context);\n  }\n}\nlet RecursiveAstVisitor$1 = class RecursiveAstVisitor {\n  visitType(ast, context) {\n    return ast;\n  }\n  visitExpression(ast, context) {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type, context) {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitMapType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitTransplantedType(type, context) {\n    return type;\n  }\n  visitWrappedNodeExpr(ast, context) {\n    return ast;\n  }\n  visitReadVarExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitDynamicImportExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast, context) {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateLiteralExpr(ast, context) {\n    ast.tag.visitExpression(this, context);\n    ast.template.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast, context) {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitRegularExpressionLiteral(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast, context) {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast, context) {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast, context) {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast, context) {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitArrowFunctionExpr(ast, context) {\n    if (Array.isArray(ast.body)) {\n      this.visitAllStatements(ast.body, context);\n    } else {\n      ast.body.visitExpression(this, context);\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTypeofExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitVoidExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast, context) {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast, context) {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast, context) {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast, context) {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast, context) {\n    ast.entries.forEach(entry => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast, context) {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralExpr(ast, context) {\n    this.visitAllExpressions(ast.elements, context);\n    this.visitAllExpressions(ast.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralElementExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitParenthesizedExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs, context) {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n  visitDeclareVarStmt(stmt, context) {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt, context) {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt, context) {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt, context) {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt, context) {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts, context) {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n};\nfunction leadingComment(text, multiline = false, trailingNewline = true) {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\nfunction jsDocComment(tags = []) {\n  return new JSDocComment(tags);\n}\nfunction variable(name, type, sourceSpan) {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\nfunction importExpr(id, typeParams = null, sourceSpan) {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\nfunction importType(id, typeParams, typeModifiers) {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\nfunction expressionType(expr, typeModifiers, typeParams) {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\nfunction transplantedType(type, typeModifiers) {\n  return new TransplantedType(type, typeModifiers);\n}\nfunction typeofExpr(expr) {\n  return new TypeofExpr(expr);\n}\nfunction literalArr(values, type, sourceSpan) {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\nfunction literalMap(values, type = null) {\n  return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\nfunction unary(operator, expr, type, sourceSpan) {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\nfunction not(expr, sourceSpan) {\n  return new NotExpr(expr, sourceSpan);\n}\nfunction fn(params, body, type, sourceSpan, name) {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\nfunction arrowFn(params, body, type, sourceSpan) {\n  return new ArrowFunctionExpr(params, body, type, sourceSpan);\n}\nfunction ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\nfunction taggedTemplate(tag, template, type, sourceSpan) {\n  return new TaggedTemplateLiteralExpr(tag, template, type, sourceSpan);\n}\nfunction literal(value, type, sourceSpan) {\n  return new LiteralExpr(value, type, sourceSpan);\n}\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\nfunction isNull(exp) {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\nfunction tagToString(tag) {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\nfunction serializeTags(tags) {\n  if (tags.length === 0) return '';\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    return `*${tagToString(tags[0])} `;\n  }\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\nvar output_ast = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArrayType: ArrayType,\n  ArrowFunctionExpr: ArrowFunctionExpr,\n  BOOL_TYPE: BOOL_TYPE,\n  get BinaryOperator() {\n    return BinaryOperator;\n  },\n  BinaryOperatorExpr: BinaryOperatorExpr,\n  BuiltinType: BuiltinType,\n  get BuiltinTypeName() {\n    return BuiltinTypeName;\n  },\n  CommaExpr: CommaExpr,\n  ConditionalExpr: ConditionalExpr,\n  DYNAMIC_TYPE: DYNAMIC_TYPE,\n  DeclareFunctionStmt: DeclareFunctionStmt,\n  DeclareVarStmt: DeclareVarStmt,\n  DynamicImportExpr: DynamicImportExpr,\n  Expression: Expression,\n  ExpressionStatement: ExpressionStatement,\n  ExpressionType: ExpressionType,\n  ExternalExpr: ExternalExpr,\n  ExternalReference: ExternalReference,\n  FUNCTION_TYPE: FUNCTION_TYPE,\n  FnParam: FnParam,\n  FunctionExpr: FunctionExpr,\n  INFERRED_TYPE: INFERRED_TYPE,\n  INT_TYPE: INT_TYPE,\n  IfStmt: IfStmt,\n  InstantiateExpr: InstantiateExpr,\n  InvokeFunctionExpr: InvokeFunctionExpr,\n  JSDocComment: JSDocComment,\n  LeadingComment: LeadingComment,\n  LiteralArrayExpr: LiteralArrayExpr,\n  LiteralExpr: LiteralExpr,\n  LiteralMapEntry: LiteralMapEntry,\n  LiteralMapExpr: LiteralMapExpr,\n  LiteralPiece: LiteralPiece,\n  LocalizedString: LocalizedString,\n  MapType: MapType,\n  NONE_TYPE: NONE_TYPE,\n  NULL_EXPR: NULL_EXPR,\n  NUMBER_TYPE: NUMBER_TYPE,\n  NotExpr: NotExpr,\n  ParenthesizedExpr: ParenthesizedExpr,\n  PlaceholderPiece: PlaceholderPiece,\n  ReadKeyExpr: ReadKeyExpr,\n  ReadPropExpr: ReadPropExpr,\n  ReadVarExpr: ReadVarExpr,\n  RecursiveAstVisitor: RecursiveAstVisitor$1,\n  RegularExpressionLiteralExpr: RegularExpressionLiteralExpr,\n  ReturnStatement: ReturnStatement,\n  STRING_TYPE: STRING_TYPE,\n  Statement: Statement,\n  get StmtModifier() {\n    return StmtModifier;\n  },\n  TYPED_NULL_EXPR: TYPED_NULL_EXPR,\n  TaggedTemplateLiteralExpr: TaggedTemplateLiteralExpr,\n  TemplateLiteralElementExpr: TemplateLiteralElementExpr,\n  TemplateLiteralExpr: TemplateLiteralExpr,\n  TransplantedType: TransplantedType,\n  Type: Type,\n  get TypeModifier() {\n    return TypeModifier;\n  },\n  TypeofExpr: TypeofExpr,\n  get UnaryOperator() {\n    return UnaryOperator;\n  },\n  UnaryOperatorExpr: UnaryOperatorExpr,\n  VoidExpr: VoidExpr,\n  WrappedNodeExpr: WrappedNodeExpr,\n  areAllEquivalent: areAllEquivalent,\n  arrowFn: arrowFn,\n  expressionType: expressionType,\n  fn: fn,\n  ifStmt: ifStmt,\n  importExpr: importExpr,\n  importType: importType,\n  isNull: isNull,\n  jsDocComment: jsDocComment,\n  leadingComment: leadingComment,\n  literal: literal,\n  literalArr: literalArr,\n  literalMap: literalMap,\n  localizedString: localizedString,\n  not: not,\n  nullSafeIsEquivalent: nullSafeIsEquivalent,\n  taggedTemplate: taggedTemplate,\n  transplantedType: transplantedType,\n  typeofExpr: typeofExpr,\n  unary: unary,\n  variable: variable\n});\nconst CONSTANT_PREFIX = '_c';\nconst UNKNOWN_VALUE_KEY = variable('<unknown>');\nconst KEY_CONTEXT = {};\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\nclass FixupExpression extends Expression {\n  resolved;\n  original;\n  shared = false;\n  constructor(resolved) {\n    super(resolved.type);\n    this.resolved = resolved;\n    this.original = resolved;\n  }\n  visitExpression(visitor, context) {\n    if (context === KEY_CONTEXT) {\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    throw new Error(`Not supported.`);\n  }\n  fixup(expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\nclass ConstantPool {\n  isClosureCompilerEnabled;\n  statements = [];\n  literals = new Map();\n  literalFactories = new Map();\n  sharedConstants = new Map();\n  _claimedNames = new Map();\n  nextNameIndex = 0;\n  constructor(isClosureCompilerEnabled = false) {\n    this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n  }\n  getConstLiteral(literal, forceShared) {\n    if (literal instanceof LiteralExpr && !isLongStringLiteral(literal) || literal instanceof FixupExpression) {\n      return literal;\n    }\n    const key = GenericKeyFn.INSTANCE.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n    if (!newValue && !fixup.shared || newValue && forceShared) {\n      const name = this.freshName();\n      let value;\n      let usage;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        value = new FunctionExpr([], [new ReturnStatement(literal)]);\n        usage = variable(name).callFn([]);\n      } else {\n        value = literal;\n        usage = variable(name);\n      }\n      this.statements.push(new DeclareVarStmt(name, value, INFERRED_TYPE, StmtModifier.Final));\n      fixup.fixup(usage);\n    }\n    return fixup;\n  }\n  getSharedConstant(def, expr) {\n    const key = def.keyOf(expr);\n    if (!this.sharedConstants.has(key)) {\n      const id = this.freshName();\n      this.sharedConstants.set(key, variable(id));\n      this.statements.push(def.toSharedConstantDeclaration(id, expr));\n    }\n    return this.sharedConstants.get(key);\n  }\n  getLiteralFactory(literal) {\n    if (literal instanceof LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n      const key = GenericKeyFn.INSTANCE.keyOf(literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));\n    } else {\n      const expressionForKey = literalMap(literal.entries.map(e => ({\n        key: e.key,\n        value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n        quoted: e.quoted\n      })));\n      const key = GenericKeyFn.INSTANCE.keyOf(expressionForKey);\n      return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({\n        key: literal.entries[index].key,\n        value,\n        quoted: literal.entries[index].quoted\n      }))));\n    }\n  }\n  getSharedFunctionReference(fn, prefix, useUniqueName = true) {\n    const isArrow = fn instanceof ArrowFunctionExpr;\n    for (const current of this.statements) {\n      if (isArrow && current instanceof DeclareVarStmt && current.value?.isEquivalent(fn)) {\n        return variable(current.name);\n      }\n      if (!isArrow && current instanceof DeclareFunctionStmt && fn instanceof FunctionExpr && fn.isEquivalent(current)) {\n        return variable(current.name);\n      }\n    }\n    const name = useUniqueName ? this.uniqueName(prefix) : prefix;\n    this.statements.push(fn instanceof FunctionExpr ? fn.toDeclStmt(name, StmtModifier.Final) : new DeclareVarStmt(name, fn, INFERRED_TYPE, StmtModifier.Final, fn.sourceSpan));\n    return variable(name);\n  }\n  _getLiteralFactory(key, values, resultMap) {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter(e => !e.isConstant());\n    if (!literalFactory) {\n      const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));\n      const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));\n      const pureFunctionDeclaration = arrowFn(parameters, resultMap(resultExpressions), INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(new DeclareVarStmt(name, pureFunctionDeclaration, INFERRED_TYPE, StmtModifier.Final));\n      literalFactory = variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {\n      literalFactory,\n      literalFactoryArguments\n    };\n  }\n  uniqueName(name, alwaysIncludeSuffix = true) {\n    const count = this._claimedNames.get(name) ?? 0;\n    const result = count === 0 && !alwaysIncludeSuffix ? `${name}` : `${name}${count}`;\n    this._claimedNames.set(name, count + 1);\n    return result;\n  }\n  freshName() {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n}\nclass GenericKeyFn {\n  static INSTANCE = new GenericKeyFn();\n  keyOf(expr) {\n    if (expr instanceof LiteralExpr && typeof expr.value === 'string') {\n      return `\"${expr.value}\"`;\n    } else if (expr instanceof LiteralExpr) {\n      return String(expr.value);\n    } else if (expr instanceof RegularExpressionLiteralExpr) {\n      return `/${expr.body}/${expr.flags ?? ''}`;\n    } else if (expr instanceof LiteralArrayExpr) {\n      const entries = [];\n      for (const entry of expr.entries) {\n        entries.push(this.keyOf(entry));\n      }\n      return `[${entries.join(',')}]`;\n    } else if (expr instanceof LiteralMapExpr) {\n      const entries = [];\n      for (const entry of expr.entries) {\n        let key = entry.key;\n        if (entry.quoted) {\n          key = `\"${key}\"`;\n        }\n        entries.push(key + ':' + this.keyOf(entry.value));\n      }\n      return `{${entries.join(',')}}`;\n    } else if (expr instanceof ExternalExpr) {\n      return `import(\"${expr.value.moduleName}\", ${expr.value.name})`;\n    } else if (expr instanceof ReadVarExpr) {\n      return `read(${expr.name})`;\n    } else if (expr instanceof TypeofExpr) {\n      return `typeof(${this.keyOf(expr.expr)})`;\n    } else {\n      throw new Error(`${this.constructor.name} does not handle expressions of type ${expr.constructor.name}`);\n    }\n  }\n}\nfunction isVariable(e) {\n  return e instanceof ReadVarExpr;\n}\nfunction isLongStringLiteral(expr) {\n  return expr instanceof LiteralExpr && typeof expr.value === 'string' && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\nconst CORE = '@angular/core';\nlet Identifiers = /*#__PURE__*/(() => {\n  class Identifiers {\n    static NEW_METHOD = 'factory';\n    static TRANSFORM_METHOD = 'transform';\n    static PATCH_DEPS = 'patchedDeps';\n    static core = {\n      name: null,\n      moduleName: CORE\n    };\n    static namespaceHTML = {\n      name: 'ÉµÉµnamespaceHTML',\n      moduleName: CORE\n    };\n    static namespaceMathML = {\n      name: 'ÉµÉµnamespaceMathML',\n      moduleName: CORE\n    };\n    static namespaceSVG = {\n      name: 'ÉµÉµnamespaceSVG',\n      moduleName: CORE\n    };\n    static element = {\n      name: 'ÉµÉµelement',\n      moduleName: CORE\n    };\n    static elementStart = {\n      name: 'ÉµÉµelementStart',\n      moduleName: CORE\n    };\n    static elementEnd = {\n      name: 'ÉµÉµelementEnd',\n      moduleName: CORE\n    };\n    static domElement = {\n      name: 'ÉµÉµdomElement',\n      moduleName: CORE\n    };\n    static domElementStart = {\n      name: 'ÉµÉµdomElementStart',\n      moduleName: CORE\n    };\n    static domElementEnd = {\n      name: 'ÉµÉµdomElementEnd',\n      moduleName: CORE\n    };\n    static domElementContainer = {\n      name: 'ÉµÉµdomElementContainer',\n      moduleName: CORE\n    };\n    static domElementContainerStart = {\n      name: 'ÉµÉµdomElementContainerStart',\n      moduleName: CORE\n    };\n    static domElementContainerEnd = {\n      name: 'ÉµÉµdomElementContainerEnd',\n      moduleName: CORE\n    };\n    static domTemplate = {\n      name: 'ÉµÉµdomTemplate',\n      moduleName: CORE\n    };\n    static domListener = {\n      name: 'ÉµÉµdomListener',\n      moduleName: CORE\n    };\n    static advance = {\n      name: 'ÉµÉµadvance',\n      moduleName: CORE\n    };\n    static syntheticHostProperty = {\n      name: 'ÉµÉµsyntheticHostProperty',\n      moduleName: CORE\n    };\n    static syntheticHostListener = {\n      name: 'ÉµÉµsyntheticHostListener',\n      moduleName: CORE\n    };\n    static attribute = {\n      name: 'ÉµÉµattribute',\n      moduleName: CORE\n    };\n    static classProp = {\n      name: 'ÉµÉµclassProp',\n      moduleName: CORE\n    };\n    static elementContainerStart = {\n      name: 'ÉµÉµelementContainerStart',\n      moduleName: CORE\n    };\n    static elementContainerEnd = {\n      name: 'ÉµÉµelementContainerEnd',\n      moduleName: CORE\n    };\n    static elementContainer = {\n      name: 'ÉµÉµelementContainer',\n      moduleName: CORE\n    };\n    static styleMap = {\n      name: 'ÉµÉµstyleMap',\n      moduleName: CORE\n    };\n    static classMap = {\n      name: 'ÉµÉµclassMap',\n      moduleName: CORE\n    };\n    static styleProp = {\n      name: 'ÉµÉµstyleProp',\n      moduleName: CORE\n    };\n    static interpolate = {\n      name: 'ÉµÉµinterpolate',\n      moduleName: CORE\n    };\n    static interpolate1 = {\n      name: 'ÉµÉµinterpolate1',\n      moduleName: CORE\n    };\n    static interpolate2 = {\n      name: 'ÉµÉµinterpolate2',\n      moduleName: CORE\n    };\n    static interpolate3 = {\n      name: 'ÉµÉµinterpolate3',\n      moduleName: CORE\n    };\n    static interpolate4 = {\n      name: 'ÉµÉµinterpolate4',\n      moduleName: CORE\n    };\n    static interpolate5 = {\n      name: 'ÉµÉµinterpolate5',\n      moduleName: CORE\n    };\n    static interpolate6 = {\n      name: 'ÉµÉµinterpolate6',\n      moduleName: CORE\n    };\n    static interpolate7 = {\n      name: 'ÉµÉµinterpolate7',\n      moduleName: CORE\n    };\n    static interpolate8 = {\n      name: 'ÉµÉµinterpolate8',\n      moduleName: CORE\n    };\n    static interpolateV = {\n      name: 'ÉµÉµinterpolateV',\n      moduleName: CORE\n    };\n    static nextContext = {\n      name: 'ÉµÉµnextContext',\n      moduleName: CORE\n    };\n    static resetView = {\n      name: 'ÉµÉµresetView',\n      moduleName: CORE\n    };\n    static templateCreate = {\n      name: 'ÉµÉµtemplate',\n      moduleName: CORE\n    };\n    static defer = {\n      name: 'ÉµÉµdefer',\n      moduleName: CORE\n    };\n    static deferWhen = {\n      name: 'ÉµÉµdeferWhen',\n      moduleName: CORE\n    };\n    static deferOnIdle = {\n      name: 'ÉµÉµdeferOnIdle',\n      moduleName: CORE\n    };\n    static deferOnImmediate = {\n      name: 'ÉµÉµdeferOnImmediate',\n      moduleName: CORE\n    };\n    static deferOnTimer = {\n      name: 'ÉµÉµdeferOnTimer',\n      moduleName: CORE\n    };\n    static deferOnHover = {\n      name: 'ÉµÉµdeferOnHover',\n      moduleName: CORE\n    };\n    static deferOnInteraction = {\n      name: 'ÉµÉµdeferOnInteraction',\n      moduleName: CORE\n    };\n    static deferOnViewport = {\n      name: 'ÉµÉµdeferOnViewport',\n      moduleName: CORE\n    };\n    static deferPrefetchWhen = {\n      name: 'ÉµÉµdeferPrefetchWhen',\n      moduleName: CORE\n    };\n    static deferPrefetchOnIdle = {\n      name: 'ÉµÉµdeferPrefetchOnIdle',\n      moduleName: CORE\n    };\n    static deferPrefetchOnImmediate = {\n      name: 'ÉµÉµdeferPrefetchOnImmediate',\n      moduleName: CORE\n    };\n    static deferPrefetchOnTimer = {\n      name: 'ÉµÉµdeferPrefetchOnTimer',\n      moduleName: CORE\n    };\n    static deferPrefetchOnHover = {\n      name: 'ÉµÉµdeferPrefetchOnHover',\n      moduleName: CORE\n    };\n    static deferPrefetchOnInteraction = {\n      name: 'ÉµÉµdeferPrefetchOnInteraction',\n      moduleName: CORE\n    };\n    static deferPrefetchOnViewport = {\n      name: 'ÉµÉµdeferPrefetchOnViewport',\n      moduleName: CORE\n    };\n    static deferHydrateWhen = {\n      name: 'ÉµÉµdeferHydrateWhen',\n      moduleName: CORE\n    };\n    static deferHydrateNever = {\n      name: 'ÉµÉµdeferHydrateNever',\n      moduleName: CORE\n    };\n    static deferHydrateOnIdle = {\n      name: 'ÉµÉµdeferHydrateOnIdle',\n      moduleName: CORE\n    };\n    static deferHydrateOnImmediate = {\n      name: 'ÉµÉµdeferHydrateOnImmediate',\n      moduleName: CORE\n    };\n    static deferHydrateOnTimer = {\n      name: 'ÉµÉµdeferHydrateOnTimer',\n      moduleName: CORE\n    };\n    static deferHydrateOnHover = {\n      name: 'ÉµÉµdeferHydrateOnHover',\n      moduleName: CORE\n    };\n    static deferHydrateOnInteraction = {\n      name: 'ÉµÉµdeferHydrateOnInteraction',\n      moduleName: CORE\n    };\n    static deferHydrateOnViewport = {\n      name: 'ÉµÉµdeferHydrateOnViewport',\n      moduleName: CORE\n    };\n    static deferEnableTimerScheduling = {\n      name: 'ÉµÉµdeferEnableTimerScheduling',\n      moduleName: CORE\n    };\n    static conditionalCreate = {\n      name: 'ÉµÉµconditionalCreate',\n      moduleName: CORE\n    };\n    static conditionalBranchCreate = {\n      name: 'ÉµÉµconditionalBranchCreate',\n      moduleName: CORE\n    };\n    static conditional = {\n      name: 'ÉµÉµconditional',\n      moduleName: CORE\n    };\n    static repeater = {\n      name: 'ÉµÉµrepeater',\n      moduleName: CORE\n    };\n    static repeaterCreate = {\n      name: 'ÉµÉµrepeaterCreate',\n      moduleName: CORE\n    };\n    static repeaterTrackByIndex = {\n      name: 'ÉµÉµrepeaterTrackByIndex',\n      moduleName: CORE\n    };\n    static repeaterTrackByIdentity = {\n      name: 'ÉµÉµrepeaterTrackByIdentity',\n      moduleName: CORE\n    };\n    static componentInstance = {\n      name: 'ÉµÉµcomponentInstance',\n      moduleName: CORE\n    };\n    static text = {\n      name: 'ÉµÉµtext',\n      moduleName: CORE\n    };\n    static enableBindings = {\n      name: 'ÉµÉµenableBindings',\n      moduleName: CORE\n    };\n    static disableBindings = {\n      name: 'ÉµÉµdisableBindings',\n      moduleName: CORE\n    };\n    static getCurrentView = {\n      name: 'ÉµÉµgetCurrentView',\n      moduleName: CORE\n    };\n    static textInterpolate = {\n      name: 'ÉµÉµtextInterpolate',\n      moduleName: CORE\n    };\n    static textInterpolate1 = {\n      name: 'ÉµÉµtextInterpolate1',\n      moduleName: CORE\n    };\n    static textInterpolate2 = {\n      name: 'ÉµÉµtextInterpolate2',\n      moduleName: CORE\n    };\n    static textInterpolate3 = {\n      name: 'ÉµÉµtextInterpolate3',\n      moduleName: CORE\n    };\n    static textInterpolate4 = {\n      name: 'ÉµÉµtextInterpolate4',\n      moduleName: CORE\n    };\n    static textInterpolate5 = {\n      name: 'ÉµÉµtextInterpolate5',\n      moduleName: CORE\n    };\n    static textInterpolate6 = {\n      name: 'ÉµÉµtextInterpolate6',\n      moduleName: CORE\n    };\n    static textInterpolate7 = {\n      name: 'ÉµÉµtextInterpolate7',\n      moduleName: CORE\n    };\n    static textInterpolate8 = {\n      name: 'ÉµÉµtextInterpolate8',\n      moduleName: CORE\n    };\n    static textInterpolateV = {\n      name: 'ÉµÉµtextInterpolateV',\n      moduleName: CORE\n    };\n    static restoreView = {\n      name: 'ÉµÉµrestoreView',\n      moduleName: CORE\n    };\n    static pureFunction0 = {\n      name: 'ÉµÉµpureFunction0',\n      moduleName: CORE\n    };\n    static pureFunction1 = {\n      name: 'ÉµÉµpureFunction1',\n      moduleName: CORE\n    };\n    static pureFunction2 = {\n      name: 'ÉµÉµpureFunction2',\n      moduleName: CORE\n    };\n    static pureFunction3 = {\n      name: 'ÉµÉµpureFunction3',\n      moduleName: CORE\n    };\n    static pureFunction4 = {\n      name: 'ÉµÉµpureFunction4',\n      moduleName: CORE\n    };\n    static pureFunction5 = {\n      name: 'ÉµÉµpureFunction5',\n      moduleName: CORE\n    };\n    static pureFunction6 = {\n      name: 'ÉµÉµpureFunction6',\n      moduleName: CORE\n    };\n    static pureFunction7 = {\n      name: 'ÉµÉµpureFunction7',\n      moduleName: CORE\n    };\n    static pureFunction8 = {\n      name: 'ÉµÉµpureFunction8',\n      moduleName: CORE\n    };\n    static pureFunctionV = {\n      name: 'ÉµÉµpureFunctionV',\n      moduleName: CORE\n    };\n    static pipeBind1 = {\n      name: 'ÉµÉµpipeBind1',\n      moduleName: CORE\n    };\n    static pipeBind2 = {\n      name: 'ÉµÉµpipeBind2',\n      moduleName: CORE\n    };\n    static pipeBind3 = {\n      name: 'ÉµÉµpipeBind3',\n      moduleName: CORE\n    };\n    static pipeBind4 = {\n      name: 'ÉµÉµpipeBind4',\n      moduleName: CORE\n    };\n    static pipeBindV = {\n      name: 'ÉµÉµpipeBindV',\n      moduleName: CORE\n    };\n    static domProperty = {\n      name: 'ÉµÉµdomProperty',\n      moduleName: CORE\n    };\n    static ariaProperty = {\n      name: 'ÉµÉµariaProperty',\n      moduleName: CORE\n    };\n    static property = {\n      name: 'ÉµÉµproperty',\n      moduleName: CORE\n    };\n    static control = {\n      name: 'ÉµÉµcontrol',\n      moduleName: CORE\n    };\n    static controlCreate = {\n      name: 'ÉµÉµcontrolCreate',\n      moduleName: CORE\n    };\n    static animationEnterListener = {\n      name: 'ÉµÉµanimateEnterListener',\n      moduleName: CORE\n    };\n    static animationLeaveListener = {\n      name: 'ÉµÉµanimateLeaveListener',\n      moduleName: CORE\n    };\n    static animationEnter = {\n      name: 'ÉµÉµanimateEnter',\n      moduleName: CORE\n    };\n    static animationLeave = {\n      name: 'ÉµÉµanimateLeave',\n      moduleName: CORE\n    };\n    static i18n = {\n      name: 'ÉµÉµi18n',\n      moduleName: CORE\n    };\n    static i18nAttributes = {\n      name: 'ÉµÉµi18nAttributes',\n      moduleName: CORE\n    };\n    static i18nExp = {\n      name: 'ÉµÉµi18nExp',\n      moduleName: CORE\n    };\n    static i18nStart = {\n      name: 'ÉµÉµi18nStart',\n      moduleName: CORE\n    };\n    static i18nEnd = {\n      name: 'ÉµÉµi18nEnd',\n      moduleName: CORE\n    };\n    static i18nApply = {\n      name: 'ÉµÉµi18nApply',\n      moduleName: CORE\n    };\n    static i18nPostprocess = {\n      name: 'ÉµÉµi18nPostprocess',\n      moduleName: CORE\n    };\n    static pipe = {\n      name: 'ÉµÉµpipe',\n      moduleName: CORE\n    };\n    static projection = {\n      name: 'ÉµÉµprojection',\n      moduleName: CORE\n    };\n    static projectionDef = {\n      name: 'ÉµÉµprojectionDef',\n      moduleName: CORE\n    };\n    static reference = {\n      name: 'ÉµÉµreference',\n      moduleName: CORE\n    };\n    static inject = {\n      name: 'ÉµÉµinject',\n      moduleName: CORE\n    };\n    static injectAttribute = {\n      name: 'ÉµÉµinjectAttribute',\n      moduleName: CORE\n    };\n    static directiveInject = {\n      name: 'ÉµÉµdirectiveInject',\n      moduleName: CORE\n    };\n    static invalidFactory = {\n      name: 'ÉµÉµinvalidFactory',\n      moduleName: CORE\n    };\n    static invalidFactoryDep = {\n      name: 'ÉµÉµinvalidFactoryDep',\n      moduleName: CORE\n    };\n    static templateRefExtractor = {\n      name: 'ÉµÉµtemplateRefExtractor',\n      moduleName: CORE\n    };\n    static forwardRef = {\n      name: 'forwardRef',\n      moduleName: CORE\n    };\n    static resolveForwardRef = {\n      name: 'resolveForwardRef',\n      moduleName: CORE\n    };\n    static replaceMetadata = {\n      name: 'ÉµÉµreplaceMetadata',\n      moduleName: CORE\n    };\n    static getReplaceMetadataURL = {\n      name: 'ÉµÉµgetReplaceMetadataURL',\n      moduleName: CORE\n    };\n    static ÉµÉµdefineInjectable = {\n      name: 'ÉµÉµdefineInjectable',\n      moduleName: CORE\n    };\n    static declareInjectable = {\n      name: 'ÉµÉµngDeclareInjectable',\n      moduleName: CORE\n    };\n    static InjectableDeclaration = {\n      name: 'ÉµÉµInjectableDeclaration',\n      moduleName: CORE\n    };\n    static resolveWindow = {\n      name: 'ÉµÉµresolveWindow',\n      moduleName: CORE\n    };\n    static resolveDocument = {\n      name: 'ÉµÉµresolveDocument',\n      moduleName: CORE\n    };\n    static resolveBody = {\n      name: 'ÉµÉµresolveBody',\n      moduleName: CORE\n    };\n    static getComponentDepsFactory = {\n      name: 'ÉµÉµgetComponentDepsFactory',\n      moduleName: CORE\n    };\n    static defineComponent = {\n      name: 'ÉµÉµdefineComponent',\n      moduleName: CORE\n    };\n    static declareComponent = {\n      name: 'ÉµÉµngDeclareComponent',\n      moduleName: CORE\n    };\n    static setComponentScope = {\n      name: 'ÉµÉµsetComponentScope',\n      moduleName: CORE\n    };\n    static ChangeDetectionStrategy = {\n      name: 'ChangeDetectionStrategy',\n      moduleName: CORE\n    };\n    static ViewEncapsulation = {\n      name: 'ViewEncapsulation',\n      moduleName: CORE\n    };\n    static ComponentDeclaration = {\n      name: 'ÉµÉµComponentDeclaration',\n      moduleName: CORE\n    };\n    static FactoryDeclaration = {\n      name: 'ÉµÉµFactoryDeclaration',\n      moduleName: CORE\n    };\n    static declareFactory = {\n      name: 'ÉµÉµngDeclareFactory',\n      moduleName: CORE\n    };\n    static FactoryTarget = {\n      name: 'ÉµÉµFactoryTarget',\n      moduleName: CORE\n    };\n    static defineDirective = {\n      name: 'ÉµÉµdefineDirective',\n      moduleName: CORE\n    };\n    static declareDirective = {\n      name: 'ÉµÉµngDeclareDirective',\n      moduleName: CORE\n    };\n    static DirectiveDeclaration = {\n      name: 'ÉµÉµDirectiveDeclaration',\n      moduleName: CORE\n    };\n    static InjectorDef = {\n      name: 'ÉµÉµInjectorDef',\n      moduleName: CORE\n    };\n    static InjectorDeclaration = {\n      name: 'ÉµÉµInjectorDeclaration',\n      moduleName: CORE\n    };\n    static defineInjector = {\n      name: 'ÉµÉµdefineInjector',\n      moduleName: CORE\n    };\n    static declareInjector = {\n      name: 'ÉµÉµngDeclareInjector',\n      moduleName: CORE\n    };\n    static NgModuleDeclaration = {\n      name: 'ÉµÉµNgModuleDeclaration',\n      moduleName: CORE\n    };\n    static ModuleWithProviders = {\n      name: 'ModuleWithProviders',\n      moduleName: CORE\n    };\n    static defineNgModule = {\n      name: 'ÉµÉµdefineNgModule',\n      moduleName: CORE\n    };\n    static declareNgModule = {\n      name: 'ÉµÉµngDeclareNgModule',\n      moduleName: CORE\n    };\n    static setNgModuleScope = {\n      name: 'ÉµÉµsetNgModuleScope',\n      moduleName: CORE\n    };\n    static registerNgModuleType = {\n      name: 'ÉµÉµregisterNgModuleType',\n      moduleName: CORE\n    };\n    static PipeDeclaration = {\n      name: 'ÉµÉµPipeDeclaration',\n      moduleName: CORE\n    };\n    static definePipe = {\n      name: 'ÉµÉµdefinePipe',\n      moduleName: CORE\n    };\n    static declarePipe = {\n      name: 'ÉµÉµngDeclarePipe',\n      moduleName: CORE\n    };\n    static declareClassMetadata = {\n      name: 'ÉµÉµngDeclareClassMetadata',\n      moduleName: CORE\n    };\n    static declareClassMetadataAsync = {\n      name: 'ÉµÉµngDeclareClassMetadataAsync',\n      moduleName: CORE\n    };\n    static setClassMetadata = {\n      name: 'ÉµsetClassMetadata',\n      moduleName: CORE\n    };\n    static setClassMetadataAsync = {\n      name: 'ÉµsetClassMetadataAsync',\n      moduleName: CORE\n    };\n    static setClassDebugInfo = {\n      name: 'ÉµsetClassDebugInfo',\n      moduleName: CORE\n    };\n    static queryRefresh = {\n      name: 'ÉµÉµqueryRefresh',\n      moduleName: CORE\n    };\n    static viewQuery = {\n      name: 'ÉµÉµviewQuery',\n      moduleName: CORE\n    };\n    static loadQuery = {\n      name: 'ÉµÉµloadQuery',\n      moduleName: CORE\n    };\n    static contentQuery = {\n      name: 'ÉµÉµcontentQuery',\n      moduleName: CORE\n    };\n    static viewQuerySignal = {\n      name: 'ÉµÉµviewQuerySignal',\n      moduleName: CORE\n    };\n    static contentQuerySignal = {\n      name: 'ÉµÉµcontentQuerySignal',\n      moduleName: CORE\n    };\n    static queryAdvance = {\n      name: 'ÉµÉµqueryAdvance',\n      moduleName: CORE\n    };\n    static twoWayProperty = {\n      name: 'ÉµÉµtwoWayProperty',\n      moduleName: CORE\n    };\n    static twoWayBindingSet = {\n      name: 'ÉµÉµtwoWayBindingSet',\n      moduleName: CORE\n    };\n    static twoWayListener = {\n      name: 'ÉµÉµtwoWayListener',\n      moduleName: CORE\n    };\n    static declareLet = {\n      name: 'ÉµÉµdeclareLet',\n      moduleName: CORE\n    };\n    static storeLet = {\n      name: 'ÉµÉµstoreLet',\n      moduleName: CORE\n    };\n    static readContextLet = {\n      name: 'ÉµÉµreadContextLet',\n      moduleName: CORE\n    };\n    static attachSourceLocations = {\n      name: 'ÉµÉµattachSourceLocations',\n      moduleName: CORE\n    };\n    static NgOnChangesFeature = {\n      name: 'ÉµÉµNgOnChangesFeature',\n      moduleName: CORE\n    };\n    static InheritDefinitionFeature = {\n      name: 'ÉµÉµInheritDefinitionFeature',\n      moduleName: CORE\n    };\n    static ProvidersFeature = {\n      name: 'ÉµÉµProvidersFeature',\n      moduleName: CORE\n    };\n    static HostDirectivesFeature = {\n      name: 'ÉµÉµHostDirectivesFeature',\n      moduleName: CORE\n    };\n    static ExternalStylesFeature = {\n      name: 'ÉµÉµExternalStylesFeature',\n      moduleName: CORE\n    };\n    static listener = {\n      name: 'ÉµÉµlistener',\n      moduleName: CORE\n    };\n    static getInheritedFactory = {\n      name: 'ÉµÉµgetInheritedFactory',\n      moduleName: CORE\n    };\n    static sanitizeHtml = {\n      name: 'ÉµÉµsanitizeHtml',\n      moduleName: CORE\n    };\n    static sanitizeStyle = {\n      name: 'ÉµÉµsanitizeStyle',\n      moduleName: CORE\n    };\n    static validateAttribute = {\n      name: 'ÉµÉµvalidateAttribute',\n      moduleName: CORE\n    };\n    static sanitizeResourceUrl = {\n      name: 'ÉµÉµsanitizeResourceUrl',\n      moduleName: CORE\n    };\n    static sanitizeScript = {\n      name: 'ÉµÉµsanitizeScript',\n      moduleName: CORE\n    };\n    static sanitizeUrl = {\n      name: 'ÉµÉµsanitizeUrl',\n      moduleName: CORE\n    };\n    static sanitizeUrlOrResourceUrl = {\n      name: 'ÉµÉµsanitizeUrlOrResourceUrl',\n      moduleName: CORE\n    };\n    static trustConstantHtml = {\n      name: 'ÉµÉµtrustConstantHtml',\n      moduleName: CORE\n    };\n    static trustConstantResourceUrl = {\n      name: 'ÉµÉµtrustConstantResourceUrl',\n      moduleName: CORE\n    };\n    static inputDecorator = {\n      name: 'Input',\n      moduleName: CORE\n    };\n    static outputDecorator = {\n      name: 'Output',\n      moduleName: CORE\n    };\n    static viewChildDecorator = {\n      name: 'ViewChild',\n      moduleName: CORE\n    };\n    static viewChildrenDecorator = {\n      name: 'ViewChildren',\n      moduleName: CORE\n    };\n    static contentChildDecorator = {\n      name: 'ContentChild',\n      moduleName: CORE\n    };\n    static contentChildrenDecorator = {\n      name: 'ContentChildren',\n      moduleName: CORE\n    };\n    static InputSignalBrandWriteType = {\n      name: 'ÉµINPUT_SIGNAL_BRAND_WRITE_TYPE',\n      moduleName: CORE\n    };\n    static UnwrapDirectiveSignalInputs = {\n      name: 'ÉµUnwrapDirectiveSignalInputs',\n      moduleName: CORE\n    };\n    static unwrapWritableSignal = {\n      name: 'ÉµunwrapWritableSignal',\n      moduleName: CORE\n    };\n    static assertType = {\n      name: 'ÉµassertType',\n      moduleName: CORE\n    };\n  }\n  return Identifiers;\n})();\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n}\nfunction splitAtColon(input, defaultValues) {\n  return _splitAt(input, ':', defaultValues);\n}\nfunction splitAtPeriod(input, defaultValues) {\n  return _splitAt(input, '.', defaultValues);\n}\nfunction _splitAt(input, character, defaultValues) {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\nfunction noUndefined(val) {\n  return val === undefined ? null : val;\n}\nfunction escapeRegExp(s) {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nfunction utf8Encode(str) {\n  let encoded = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = (codePoint - 0xd800 << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(codePoint >> 6 & 0x1f | 0xc0, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(codePoint >> 12 | 0xe0, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(codePoint >> 18 & 0x07 | 0xf0, codePoint >> 12 & 0x3f | 0x80, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    }\n  }\n  return encoded;\n}\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n  if (Array.isArray(token)) {\n    return `[${token.map(stringify).join(', ')}]`;\n  }\n  if (token == null) {\n    return '' + token;\n  }\n  const name = token.overriddenName || token.name;\n  if (name) {\n    return `${name}`;\n  }\n  if (!token.toString) {\n    return 'object';\n  }\n  const result = token.toString();\n  if (result == null) {\n    return '' + result;\n  }\n  const newLineIndex = result.indexOf('\\n');\n  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\nclass Version {\n  full;\n  major;\n  minor;\n  patch;\n  constructor(full) {\n    this.full = full;\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\nconst _global = globalThis;\nconst V1_TO_18 = /^([1-9]|1[0-8])\\./;\nfunction getJitStandaloneDefaultForVersion(version) {\n  if (version.startsWith('0.')) {\n    return true;\n  }\n  if (V1_TO_18.test(version)) {\n    return false;\n  }\n  return true;\n}\nconst VERSION$1 = 3;\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nclass SourceMapGenerator {\n  file;\n  sourcesContent = new Map();\n  lines = [];\n  lastCol0 = 0;\n  hasMappings = false;\n  constructor(file = null) {\n    this.file = file;\n  }\n  addSource(url, content = null) {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n  addLine() {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n  addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({\n      col0,\n      sourceUrl,\n      sourceLine0,\n      sourceCol0\n    });\n    return this;\n  }\n  get currentLine() {\n    return this.lines.slice(-1)[0];\n  }\n  toJSON() {\n    if (!this.hasMappings) {\n      return null;\n    }\n    const sourcesIndex = new Map();\n    const sources = [];\n    const sourcesContent = [];\n    Array.from(this.sourcesContent.keys()).forEach((url, i) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n    let mappings = '';\n    let lastCol0 = 0;\n    let lastSourceIndex = 0;\n    let lastSourceLine0 = 0;\n    let lastSourceCol0 = 0;\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n      mappings += segments.map(segment => {\n        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n        lastCol0 = segment.col0;\n        if (segment.sourceUrl != null) {\n          segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n          lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n          segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n          lastSourceLine0 = segment.sourceLine0;\n          segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n          lastSourceCol0 = segment.sourceCol0;\n        }\n        return segAsStr;\n      }).join(',');\n      mappings += ';';\n    });\n    mappings = mappings.slice(0, -1);\n    return {\n      'file': this.file || '',\n      'version': VERSION$1,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings\n    };\n  }\n  toJsComment() {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';\n  }\n}\nfunction toBase64String(value) {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length;) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n  return b64;\n}\nfunction toBase64VLQ(value) {\n  value = value < 0 ? (-value << 1) + 1 : value << 1;\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n  return out;\n}\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction toBase64Digit(value) {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n  return B64_DIGITS[value];\n}\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nclass _EmittedLine {\n  indent;\n  partsLength = 0;\n  parts = [];\n  srcSpans = [];\n  constructor(indent) {\n    this.indent = indent;\n  }\n}\nconst BINARY_OPERATORS$1 = new Map([[BinaryOperator.And, '&&'], [BinaryOperator.Bigger, '>'], [BinaryOperator.BiggerEquals, '>='], [BinaryOperator.BitwiseOr, '|'], [BinaryOperator.BitwiseAnd, '&'], [BinaryOperator.Divide, '/'], [BinaryOperator.Assign, '='], [BinaryOperator.Equals, '=='], [BinaryOperator.Identical, '==='], [BinaryOperator.Lower, '<'], [BinaryOperator.LowerEquals, '<='], [BinaryOperator.Minus, '-'], [BinaryOperator.Modulo, '%'], [BinaryOperator.Exponentiation, '**'], [BinaryOperator.Multiply, '*'], [BinaryOperator.NotEquals, '!='], [BinaryOperator.NotIdentical, '!=='], [BinaryOperator.NullishCoalesce, '??'], [BinaryOperator.Or, '||'], [BinaryOperator.Plus, '+'], [BinaryOperator.In, 'in'], [BinaryOperator.AdditionAssignment, '+='], [BinaryOperator.SubtractionAssignment, '-='], [BinaryOperator.MultiplicationAssignment, '*='], [BinaryOperator.DivisionAssignment, '/='], [BinaryOperator.RemainderAssignment, '%='], [BinaryOperator.ExponentiationAssignment, '**='], [BinaryOperator.AndAssignment, '&&='], [BinaryOperator.OrAssignment, '||='], [BinaryOperator.NullishCoalesceAssignment, '??=']]);\nclass EmitterVisitorContext {\n  _indent;\n  static createRoot() {\n    return new EmitterVisitorContext(0);\n  }\n  _lines;\n  constructor(_indent) {\n    this._indent = _indent;\n    this._lines = [new _EmittedLine(_indent)];\n  }\n  get _currentLine() {\n    return this._lines[this._lines.length - 1];\n  }\n  println(from, lastPart = '') {\n    this.print(from || null, lastPart, true);\n  }\n  lineIsEmpty() {\n    return this._currentLine.parts.length === 0;\n  }\n  lineLength() {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n  print(from, part, newLine = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n  toSource() {\n    return this.sourceLines.map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '').join('\\n');\n  }\n  toSourceMapGenerator(genFilePath, startsAtLine = 0) {\n    const map = new SourceMapGenerator(genFilePath);\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx];\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n    return map;\n  }\n  spanOf(line, column) {\n    const emittedLine = this._lines[line];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n  get sourceLines() {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\nclass AbstractEmitterVisitor {\n  _escapeDollarInStrings;\n  lastIfCondition = null;\n  constructor(_escapeDollarInStrings) {\n    this._escapeDollarInStrings = _escapeDollarInStrings;\n  }\n  printLeadingComments(stmt, ctx) {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach(line => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n  visitExpressionStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n  visitReturnStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n  visitIfStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    this.lastIfCondition = stmt.condition;\n    stmt.condition.visitExpression(this, ctx);\n    this.lastIfCondition = null;\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  visitInvokeFunctionExpr(expr, ctx) {\n    const shouldParenthesize = expr.fn instanceof ArrowFunctionExpr;\n    if (shouldParenthesize) {\n      ctx.print(expr.fn, '(');\n    }\n    expr.fn.visitExpression(this, ctx);\n    if (shouldParenthesize) {\n      ctx.print(expr.fn, ')');\n    }\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateLiteralExpr(expr, ctx) {\n    expr.tag.visitExpression(this, ctx);\n    expr.template.visitExpression(this, ctx);\n    return null;\n  }\n  visitTemplateLiteralExpr(expr, ctx) {\n    ctx.print(expr, '`');\n    for (let i = 0; i < expr.elements.length; i++) {\n      expr.elements[i].visitExpression(this, ctx);\n      const expression = i < expr.expressions.length ? expr.expressions[i] : null;\n      if (expression !== null) {\n        ctx.print(expression, '${');\n        expression.visitExpression(this, ctx);\n        ctx.print(expression, '}');\n      }\n    }\n    ctx.print(expr, '`');\n  }\n  visitTemplateLiteralElementExpr(expr, ctx) {\n    ctx.print(expr, expr.rawText);\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr, ctx) {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitVoidExpr(expr, ctx) {\n    ctx.print(expr, 'void ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast, ctx) {\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitInstantiateExpr(ast, ctx) {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitLiteralExpr(ast, ctx) {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n  visitRegularExpressionLiteral(ast, ctx) {\n    ctx.print(ast, `/${ast.body}/${ast.flags || ''}`);\n    return null;\n  }\n  visitLocalizedString(ast, ctx) {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n  visitConditionalExpr(ast, ctx) {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitDynamicImportExpr(ast, ctx) {\n    ctx.print(ast, `import(${ast.url})`);\n  }\n  visitNotExpr(ast, ctx) {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitUnaryOperatorExpr(ast, ctx) {\n    let opStr;\n    switch (ast.operator) {\n      case UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    const parens = ast !== this.lastIfCondition;\n    if (parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (parens) ctx.print(ast, `)`);\n    return null;\n  }\n  visitBinaryOperatorExpr(ast, ctx) {\n    const operator = BINARY_OPERATORS$1.get(ast.operator);\n    if (!operator) {\n      throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    const parens = ast !== this.lastIfCondition;\n    if (parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${operator} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (parens) ctx.print(ast, `)`);\n    return null;\n  }\n  visitReadPropExpr(ast, ctx) {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast, ctx) {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast, ctx) {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast, ctx) {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast, ctx) {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitParenthesizedExpr(ast, ctx) {\n    ast.expr.visitExpression(this, ctx);\n  }\n  visitAllExpressions(expressions, ctx, separator) {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n  visitAllObjects(handler, expressions, ctx, separator) {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n  visitAllStatements(statements, ctx) {\n    statements.forEach(stmt => stmt.visitStatement(this, ctx));\n  }\n}\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote = true) {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\nfunction _createIndent(count) {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\nfunction typeWithParameters(type, numParams) {\n  if (numParams === 0) {\n    return expressionType(type);\n  }\n  const params = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(DYNAMIC_TYPE);\n  }\n  return expressionType(type, undefined, params);\n}\nfunction getSafePropertyAccessString(accessor, name) {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\nfunction jitOnlyGuardedExpression(expr) {\n  return guardedExpression('ngJitMode', expr);\n}\nfunction devOnlyGuardedExpression(expr) {\n  return guardedExpression('ngDevMode', expr);\n}\nfunction guardedExpression(guard, expr) {\n  const guardExpr = new ExternalExpr({\n    name: guard,\n    moduleName: null\n  });\n  const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));\n  const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, undefined, undefined);\n  return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\nfunction wrapReference(value) {\n  const wrapped = new WrappedNodeExpr(value);\n  return {\n    value: wrapped,\n    type: wrapped\n  };\n}\nfunction refsToArray(refs, shouldForwardDeclare) {\n  const values = literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? arrowFn([], values) : values;\n}\nfunction createMayBeForwardRefExpression(expression, forwardRef) {\n  return {\n    expression,\n    forwardRef\n  };\n}\nfunction convertFromMaybeForwardRefExpression({\n  expression,\n  forwardRef\n}) {\n  switch (forwardRef) {\n    case 0:\n    case 1:\n      return expression;\n    case 2:\n      return generateForwardRef(expression);\n  }\n}\nfunction generateForwardRef(expr) {\n  return importExpr(Identifiers.forwardRef).callFn([arrowFn([], expr)]);\n}\nvar R3FactoryDelegateType = /*#__PURE__*/function (R3FactoryDelegateType) {\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n  return R3FactoryDelegateType;\n}(R3FactoryDelegateType || {});\nfunction compileFactoryFunction(meta) {\n  const t = variable('__ngFactoryType__');\n  let baseFactoryVar = null;\n  const typeForCtor = !isDelegatedFactoryMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.type.value) : t;\n  let ctorExpr = null;\n  if (meta.deps !== null) {\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    baseFactoryVar = variable(`Éµ${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n  const body = [];\n  let retExpr = null;\n  function makeConditionalFactory(nonCtorExpr) {\n    const r = variable('__ngConditionalFactory__');\n    body.push(new DeclareVarStmt(r.name, NULL_EXPR, INFERRED_TYPE));\n    const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() : importExpr(Identifiers.invalidFactory).callFn([]).toStmt();\n    body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n  if (isDelegatedFactoryMetadata(meta)) {\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n  if (retExpr === null) {\n    body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.type.value]);\n    const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n    body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    body.push(new ReturnStatement(retExpr));\n  }\n  let factoryFn = fn([new FnParam(t.name, DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n  if (baseFactoryVar !== null) {\n    factoryFn = arrowFn([], [new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)]).callFn([], undefined, true);\n  }\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta)\n  };\n}\nfunction createFactoryType(meta) {\n  const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;\n  return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\nfunction injectDependencies(deps, target) {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\nfunction compileInjectDependency(dep, target, index) {\n  if (dep.token === null) {\n    return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    const flags = 0 | (dep.self ? 2 : 0) | (dep.skipSelf ? 4 : 0) | (dep.host ? 1 : 0) | (dep.optional ? 8 : 0) | (target === FactoryTarget.Pipe ? 16 : 0);\n    let flagsParam = flags !== 0 || dep.optional ? literal(flags) : null;\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return importExpr(injectFn).callFn(injectArgs);\n  } else {\n    return importExpr(Identifiers.injectAttribute).callFn([dep.token]);\n  }\n}\nfunction createCtorDepsType(deps) {\n  let hasTypes = false;\n  const attributeTypes = deps.map(dep => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return literal(null);\n    }\n  });\n  if (hasTypes) {\n    return expressionType(literalArr(attributeTypes));\n  } else {\n    return NONE_TYPE;\n  }\n}\nfunction createCtorDepType(dep) {\n  const entries = [];\n  if (dep.attributeNameType !== null) {\n    entries.push({\n      key: 'attribute',\n      value: dep.attributeNameType,\n      quoted: false\n    });\n  }\n  if (dep.optional) {\n    entries.push({\n      key: 'optional',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.host) {\n    entries.push({\n      key: 'host',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.self) {\n    entries.push({\n      key: 'self',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.skipSelf) {\n    entries.push({\n      key: 'skipSelf',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  return entries.length > 0 ? literalMap(entries) : null;\n}\nfunction isDelegatedFactoryMetadata(meta) {\n  return meta.delegateType !== undefined;\n}\nfunction isExpressionFactoryMetadata(meta) {\n  return meta.expression !== undefined;\n}\nfunction getInjectFn(target) {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return Identifiers.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return Identifiers.inject;\n  }\n}\nclass ParseSpan {\n  start;\n  end;\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  toAbsolute(absoluteOffset) {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\nclass AST {\n  span;\n  sourceSpan;\n  constructor(span, sourceSpan) {\n    this.span = span;\n    this.sourceSpan = sourceSpan;\n  }\n  toString() {\n    return 'AST';\n  }\n}\nclass ASTWithName extends AST {\n  nameSpan;\n  constructor(span, sourceSpan, nameSpan) {\n    super(span, sourceSpan);\n    this.nameSpan = nameSpan;\n  }\n}\nlet EmptyExpr$1 = class EmptyExpr extends AST {\n  visit(visitor, context = null) {}\n};\nclass ImplicitReceiver extends AST {\n  visit(visitor, context = null) {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\nclass ThisReceiver extends ImplicitReceiver {\n  visit(visitor, context = null) {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\nclass Chain extends AST {\n  expressions;\n  constructor(span, sourceSpan, expressions) {\n    super(span, sourceSpan);\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitChain(this, context);\n  }\n}\nclass Conditional extends AST {\n  condition;\n  trueExp;\n  falseExp;\n  constructor(span, sourceSpan, condition, trueExp, falseExp) {\n    super(span, sourceSpan);\n    this.condition = condition;\n    this.trueExp = trueExp;\n    this.falseExp = falseExp;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitConditional(this, context);\n  }\n}\nclass PropertyRead extends ASTWithName {\n  receiver;\n  name;\n  constructor(span, sourceSpan, nameSpan, receiver, name) {\n    super(span, sourceSpan, nameSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\nclass SafePropertyRead extends ASTWithName {\n  receiver;\n  name;\n  constructor(span, sourceSpan, nameSpan, receiver, name) {\n    super(span, sourceSpan, nameSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\nclass KeyedRead extends AST {\n  receiver;\n  key;\n  constructor(span, sourceSpan, receiver, key) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.key = key;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\nclass SafeKeyedRead extends AST {\n  receiver;\n  key;\n  constructor(span, sourceSpan, receiver, key) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.key = key;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\nvar BindingPipeType = /*#__PURE__*/function (BindingPipeType) {\n  BindingPipeType[BindingPipeType[\"ReferencedByName\"] = 0] = \"ReferencedByName\";\n  BindingPipeType[BindingPipeType[\"ReferencedDirectly\"] = 1] = \"ReferencedDirectly\";\n  return BindingPipeType;\n}(BindingPipeType || {});\nclass BindingPipe extends ASTWithName {\n  exp;\n  name;\n  args;\n  type;\n  constructor(span, sourceSpan, exp, name, args, type, nameSpan) {\n    super(span, sourceSpan, nameSpan);\n    this.exp = exp;\n    this.name = name;\n    this.args = args;\n    this.type = type;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPipe(this, context);\n  }\n}\nclass LiteralPrimitive extends AST {\n  value;\n  constructor(span, sourceSpan, value) {\n    super(span, sourceSpan);\n    this.value = value;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\nclass LiteralArray extends AST {\n  expressions;\n  constructor(span, sourceSpan, expressions) {\n    super(span, sourceSpan);\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\nclass LiteralMap extends AST {\n  keys;\n  values;\n  constructor(span, sourceSpan, keys, values) {\n    super(span, sourceSpan);\n    this.keys = keys;\n    this.values = values;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\nlet Interpolation$1 = class Interpolation extends AST {\n  strings;\n  expressions;\n  constructor(span, sourceSpan, strings, expressions) {\n    super(span, sourceSpan);\n    this.strings = strings;\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitInterpolation(this, context);\n  }\n};\nclass Binary extends AST {\n  operation;\n  left;\n  right;\n  constructor(span, sourceSpan, operation, left, right) {\n    super(span, sourceSpan);\n    this.operation = operation;\n    this.left = left;\n    this.right = right;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitBinary(this, context);\n  }\n  static isAssignmentOperation(op) {\n    return op === '=' || op === '+=' || op === '-=' || op === '*=' || op === '/=' || op === '%=' || op === '**=' || op === '&&=' || op === '||=' || op === '??=';\n  }\n}\nclass Unary extends Binary {\n  operator;\n  expr;\n  left = null;\n  right = null;\n  operation = null;\n  static createMinus(span, sourceSpan, expr) {\n    return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n  }\n  static createPlus(span, sourceSpan, expr) {\n    return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n  }\n  constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n    this.operator = operator;\n    this.expr = expr;\n  }\n  visit(visitor, context = null) {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\nclass PrefixNot extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\nclass TypeofExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitTypeofExpression(this, context);\n  }\n}\nclass VoidExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitVoidExpression(this, context);\n  }\n}\nclass NonNullAssert extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\nclass Call extends AST {\n  receiver;\n  args;\n  argumentSpan;\n  constructor(span, sourceSpan, receiver, args, argumentSpan) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.args = args;\n    this.argumentSpan = argumentSpan;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitCall(this, context);\n  }\n}\nclass SafeCall extends AST {\n  receiver;\n  args;\n  argumentSpan;\n  constructor(span, sourceSpan, receiver, args, argumentSpan) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.args = args;\n    this.argumentSpan = argumentSpan;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafeCall(this, context);\n  }\n}\nclass TaggedTemplateLiteral extends AST {\n  tag;\n  template;\n  constructor(span, sourceSpan, tag, template) {\n    super(span, sourceSpan);\n    this.tag = tag;\n    this.template = template;\n  }\n  visit(visitor, context) {\n    return visitor.visitTaggedTemplateLiteral(this, context);\n  }\n}\nclass TemplateLiteral extends AST {\n  elements;\n  expressions;\n  constructor(span, sourceSpan, elements, expressions) {\n    super(span, sourceSpan);\n    this.elements = elements;\n    this.expressions = expressions;\n  }\n  visit(visitor, context) {\n    return visitor.visitTemplateLiteral(this, context);\n  }\n}\nclass TemplateLiteralElement extends AST {\n  text;\n  constructor(span, sourceSpan, text) {\n    super(span, sourceSpan);\n    this.text = text;\n  }\n  visit(visitor, context) {\n    return visitor.visitTemplateLiteralElement(this, context);\n  }\n}\nclass ParenthesizedExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context) {\n    return visitor.visitParenthesizedExpression(this, context);\n  }\n}\nclass RegularExpressionLiteral extends AST {\n  body;\n  flags;\n  constructor(span, sourceSpan, body, flags) {\n    super(span, sourceSpan);\n    this.body = body;\n    this.flags = flags;\n  }\n  visit(visitor, context) {\n    return visitor.visitRegularExpressionLiteral(this, context);\n  }\n}\nclass AbsoluteSourceSpan {\n  start;\n  end;\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n}\nclass ASTWithSource extends AST {\n  ast;\n  source;\n  location;\n  errors;\n  constructor(ast, source, location, absoluteOffset, errors) {\n    super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n    this.ast = ast;\n    this.source = source;\n    this.location = location;\n    this.errors = errors;\n  }\n  visit(visitor, context = null) {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  toString() {\n    return `${this.source} in ${this.location}`;\n  }\n}\nclass VariableBinding {\n  sourceSpan;\n  key;\n  value;\n  constructor(sourceSpan, key, value) {\n    this.sourceSpan = sourceSpan;\n    this.key = key;\n    this.value = value;\n  }\n}\nclass ExpressionBinding {\n  sourceSpan;\n  key;\n  value;\n  constructor(sourceSpan, key, value) {\n    this.sourceSpan = sourceSpan;\n    this.key = key;\n    this.value = value;\n  }\n}\nclass RecursiveAstVisitor {\n  visit(ast, context) {\n    ast.visit(this, context);\n  }\n  visitUnary(ast, context) {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast, context) {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast, context) {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast, context) {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast, context) {}\n  visitThisReceiver(ast, context) {}\n  visitInterpolation(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitLiteralArray(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast, context) {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast, context) {}\n  visitPrefixNot(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitTypeofExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitVoidExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast, context) {\n    this.visit(ast.receiver, context);\n  }\n  visitSafePropertyRead(ast, context) {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitTemplateLiteral(ast, context) {\n    for (let i = 0; i < ast.elements.length; i++) {\n      this.visit(ast.elements[i], context);\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        this.visit(expression, context);\n      }\n    }\n  }\n  visitTemplateLiteralElement(ast, context) {}\n  visitTaggedTemplateLiteral(ast, context) {\n    this.visit(ast.tag, context);\n    this.visit(ast.template, context);\n  }\n  visitParenthesizedExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitRegularExpressionLiteral(ast, context) {}\n  visitAll(asts, context) {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\nclass ParsedProperty {\n  name;\n  expression;\n  type;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  isLiteral;\n  isLegacyAnimation;\n  isAnimation;\n  constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.expression = expression;\n    this.type = type;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isLegacyAnimation = this.type === ParsedPropertyType.LEGACY_ANIMATION;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\nvar ParsedPropertyType = /*#__PURE__*/function (ParsedPropertyType) {\n  ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n  ParsedPropertyType[ParsedPropertyType[\"LEGACY_ANIMATION\"] = 2] = \"LEGACY_ANIMATION\";\n  ParsedPropertyType[ParsedPropertyType[\"TWO_WAY\"] = 3] = \"TWO_WAY\";\n  ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 4] = \"ANIMATION\";\n  return ParsedPropertyType;\n}(ParsedPropertyType || {});\nvar ParsedEventType = /*#__PURE__*/function (ParsedEventType) {\n  ParsedEventType[ParsedEventType[\"Regular\"] = 0] = \"Regular\";\n  ParsedEventType[ParsedEventType[\"LegacyAnimation\"] = 1] = \"LegacyAnimation\";\n  ParsedEventType[ParsedEventType[\"TwoWay\"] = 2] = \"TwoWay\";\n  ParsedEventType[ParsedEventType[\"Animation\"] = 3] = \"Animation\";\n  return ParsedEventType;\n}(ParsedEventType || {});\nclass ParsedEvent {\n  name;\n  targetOrPhase;\n  type;\n  handler;\n  sourceSpan;\n  handlerSpan;\n  keySpan;\n  constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {\n    this.name = name;\n    this.targetOrPhase = targetOrPhase;\n    this.type = type;\n    this.handler = handler;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.keySpan = keySpan;\n  }\n}\nclass ParsedVariable {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n}\nvar BindingType = /*#__PURE__*/function (BindingType) {\n  BindingType[BindingType[\"Property\"] = 0] = \"Property\";\n  BindingType[BindingType[\"Attribute\"] = 1] = \"Attribute\";\n  BindingType[BindingType[\"Class\"] = 2] = \"Class\";\n  BindingType[BindingType[\"Style\"] = 3] = \"Style\";\n  BindingType[BindingType[\"LegacyAnimation\"] = 4] = \"LegacyAnimation\";\n  BindingType[BindingType[\"TwoWay\"] = 5] = \"TwoWay\";\n  BindingType[BindingType[\"Animation\"] = 6] = \"Animation\";\n  return BindingType;\n}(BindingType || {});\nclass BoundElementProperty {\n  name;\n  type;\n  securityContext;\n  value;\n  unit;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n}\nvar TagContentType = /*#__PURE__*/function (TagContentType) {\n  TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n  TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n  TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n  return TagContentType;\n}(TagContentType || {});\nfunction splitNsName(elementName, fatal = true) {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n  const colonIndex = elementName.indexOf(':', 1);\n  if (colonIndex === -1) {\n    if (fatal) {\n      throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n    } else {\n      return [null, elementName];\n    }\n  }\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\nfunction isNgContainer(tagName) {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\nfunction isNgContent(tagName) {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\nfunction isNgTemplate(tagName) {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\nfunction getNsPrefix(fullName) {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\nfunction mergeNsAndName(prefix, localName) {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\nlet Comment$1 = class Comment {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(_visitor) {\n    throw new Error('visit() not implemented for Comment');\n  }\n};\nlet Text$3 = class Text {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor) {\n    return visitor.visitText(this);\n  }\n};\nclass BoundText {\n  value;\n  sourceSpan;\n  i18n;\n  constructor(value, sourceSpan, i18n) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitBoundText(this);\n  }\n}\nclass TextAttribute {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  i18n;\n  constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitTextAttribute(this);\n  }\n}\nclass BoundAttribute {\n  name;\n  type;\n  securityContext;\n  value;\n  unit;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  i18n;\n  constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n  static fromBoundElementProperty(prop, i18n) {\n    if (prop.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);\n    }\n    return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);\n  }\n  visit(visitor) {\n    return visitor.visitBoundAttribute(this);\n  }\n}\nclass BoundEvent {\n  name;\n  type;\n  handler;\n  target;\n  phase;\n  sourceSpan;\n  handlerSpan;\n  keySpan;\n  constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {\n    this.name = name;\n    this.type = type;\n    this.handler = handler;\n    this.target = target;\n    this.phase = phase;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.keySpan = keySpan;\n  }\n  static fromParsedEvent(event) {\n    const target = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase = event.type === ParsedEventType.LegacyAnimation ? event.targetOrPhase : null;\n    if (event.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);\n    }\n    return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);\n  }\n  visit(visitor) {\n    return visitor.visitBoundEvent(this);\n  }\n}\nlet Element$1 = class Element {\n  name;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  children;\n  references;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  isVoid;\n  i18n;\n  constructor(name, attributes, inputs, outputs, directives, children, references, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, isVoid, i18n) {\n    this.name = name;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.children = children;\n    this.references = references;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.isVoid = isVoid;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitElement(this);\n  }\n};\nclass DeferredTrigger {\n  nameSpan;\n  sourceSpan;\n  prefetchSpan;\n  whenOrOnSourceSpan;\n  hydrateSpan;\n  constructor(nameSpan, sourceSpan, prefetchSpan, whenOrOnSourceSpan, hydrateSpan) {\n    this.nameSpan = nameSpan;\n    this.sourceSpan = sourceSpan;\n    this.prefetchSpan = prefetchSpan;\n    this.whenOrOnSourceSpan = whenOrOnSourceSpan;\n    this.hydrateSpan = hydrateSpan;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredTrigger(this);\n  }\n}\nclass BoundDeferredTrigger extends DeferredTrigger {\n  value;\n  constructor(value, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan) {\n    super(null, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan);\n    this.value = value;\n  }\n}\nclass NeverDeferredTrigger extends DeferredTrigger {}\nclass IdleDeferredTrigger extends DeferredTrigger {}\nclass ImmediateDeferredTrigger extends DeferredTrigger {}\nclass HoverDeferredTrigger extends DeferredTrigger {\n  reference;\n  constructor(reference, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n  }\n}\nclass TimerDeferredTrigger extends DeferredTrigger {\n  delay;\n  constructor(delay, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.delay = delay;\n  }\n}\nclass InteractionDeferredTrigger extends DeferredTrigger {\n  reference;\n  constructor(reference, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n  }\n}\nclass ViewportDeferredTrigger extends DeferredTrigger {\n  reference;\n  options;\n  constructor(reference, options, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n    this.options = options;\n  }\n}\nclass BlockNode {\n  nameSpan;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(nameSpan, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.nameSpan = nameSpan;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n}\nclass DeferredBlockPlaceholder extends BlockNode {\n  children;\n  minimumTime;\n  i18n;\n  constructor(children, minimumTime, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.minimumTime = minimumTime;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockPlaceholder(this);\n  }\n}\nclass DeferredBlockLoading extends BlockNode {\n  children;\n  afterTime;\n  minimumTime;\n  i18n;\n  constructor(children, afterTime, minimumTime, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.afterTime = afterTime;\n    this.minimumTime = minimumTime;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockLoading(this);\n  }\n}\nclass DeferredBlockError extends BlockNode {\n  children;\n  i18n;\n  constructor(children, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockError(this);\n  }\n}\nclass DeferredBlock extends BlockNode {\n  children;\n  placeholder;\n  loading;\n  error;\n  mainBlockSpan;\n  i18n;\n  triggers;\n  prefetchTriggers;\n  hydrateTriggers;\n  definedTriggers;\n  definedPrefetchTriggers;\n  definedHydrateTriggers;\n  constructor(children, triggers, prefetchTriggers, hydrateTriggers, placeholder, loading, error, nameSpan, sourceSpan, mainBlockSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.placeholder = placeholder;\n    this.loading = loading;\n    this.error = error;\n    this.mainBlockSpan = mainBlockSpan;\n    this.i18n = i18n;\n    this.triggers = triggers;\n    this.prefetchTriggers = prefetchTriggers;\n    this.hydrateTriggers = hydrateTriggers;\n    this.definedTriggers = Object.keys(triggers);\n    this.definedPrefetchTriggers = Object.keys(prefetchTriggers);\n    this.definedHydrateTriggers = Object.keys(hydrateTriggers);\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlock(this);\n  }\n  visitAll(visitor) {\n    this.visitTriggers(this.definedHydrateTriggers, this.hydrateTriggers, visitor);\n    this.visitTriggers(this.definedTriggers, this.triggers, visitor);\n    this.visitTriggers(this.definedPrefetchTriggers, this.prefetchTriggers, visitor);\n    visitAll$1(visitor, this.children);\n    const remainingBlocks = [this.placeholder, this.loading, this.error].filter(x => x !== null);\n    visitAll$1(visitor, remainingBlocks);\n  }\n  visitTriggers(keys, triggers, visitor) {\n    visitAll$1(visitor, keys.map(k => triggers[k]));\n  }\n}\nclass SwitchBlock extends BlockNode {\n  expression;\n  cases;\n  unknownBlocks;\n  constructor(expression, cases, unknownBlocks, sourceSpan, startSourceSpan, endSourceSpan, nameSpan) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.cases = cases;\n    this.unknownBlocks = unknownBlocks;\n  }\n  visit(visitor) {\n    return visitor.visitSwitchBlock(this);\n  }\n}\nclass SwitchBlockCase extends BlockNode {\n  expression;\n  children;\n  i18n;\n  constructor(expression, children, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitSwitchBlockCase(this);\n  }\n}\nclass ForLoopBlock extends BlockNode {\n  item;\n  expression;\n  trackBy;\n  trackKeywordSpan;\n  contextVariables;\n  children;\n  empty;\n  mainBlockSpan;\n  i18n;\n  constructor(item, expression, trackBy, trackKeywordSpan, contextVariables, children, empty, sourceSpan, mainBlockSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.item = item;\n    this.expression = expression;\n    this.trackBy = trackBy;\n    this.trackKeywordSpan = trackKeywordSpan;\n    this.contextVariables = contextVariables;\n    this.children = children;\n    this.empty = empty;\n    this.mainBlockSpan = mainBlockSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitForLoopBlock(this);\n  }\n}\nclass ForLoopBlockEmpty extends BlockNode {\n  children;\n  i18n;\n  constructor(children, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitForLoopBlockEmpty(this);\n  }\n}\nclass IfBlock extends BlockNode {\n  branches;\n  constructor(branches, sourceSpan, startSourceSpan, endSourceSpan, nameSpan) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.branches = branches;\n  }\n  visit(visitor) {\n    return visitor.visitIfBlock(this);\n  }\n}\nclass IfBlockBranch extends BlockNode {\n  expression;\n  children;\n  expressionAlias;\n  i18n;\n  constructor(expression, children, expressionAlias, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.children = children;\n    this.expressionAlias = expressionAlias;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitIfBlockBranch(this);\n  }\n}\nclass UnknownBlock {\n  name;\n  sourceSpan;\n  nameSpan;\n  constructor(name, sourceSpan, nameSpan) {\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n  }\n  visit(visitor) {\n    return visitor.visitUnknownBlock(this);\n  }\n}\nlet LetDeclaration$1 = class LetDeclaration {\n  name;\n  value;\n  sourceSpan;\n  nameSpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, nameSpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitLetDeclaration(this);\n  }\n};\nlet Component$1 = class Component {\n  componentName;\n  tagName;\n  fullName;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  children;\n  references;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(componentName, tagName, fullName, attributes, inputs, outputs, directives, children, references, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.componentName = componentName;\n    this.tagName = tagName;\n    this.fullName = fullName;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.children = children;\n    this.references = references;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitComponent(this);\n  }\n};\nlet Directive$1 = class Directive {\n  name;\n  attributes;\n  inputs;\n  outputs;\n  references;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(name, attributes, inputs, outputs, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.name = name;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.references = references;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDirective(this);\n  }\n};\nclass Template {\n  tagName;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  templateAttrs;\n  children;\n  references;\n  variables;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(tagName, attributes, inputs, outputs, directives, templateAttrs, children, references, variables, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.tagName = tagName;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.templateAttrs = templateAttrs;\n    this.children = children;\n    this.references = references;\n    this.variables = variables;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitTemplate(this);\n  }\n}\nclass Content {\n  selector;\n  attributes;\n  children;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  name = 'ng-content';\n  constructor(selector, attributes, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.selector = selector;\n    this.attributes = attributes;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitContent(this);\n  }\n}\nclass Variable {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitVariable(this);\n  }\n}\nclass Reference {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitReference(this);\n  }\n}\nlet Icu$1 = class Icu {\n  vars;\n  placeholders;\n  sourceSpan;\n  i18n;\n  constructor(vars, placeholders, sourceSpan, i18n) {\n    this.vars = vars;\n    this.placeholders = placeholders;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitIcu(this);\n  }\n};\nclass HostElement {\n  tagNames;\n  bindings;\n  listeners;\n  sourceSpan;\n  constructor(tagNames, bindings, listeners, sourceSpan) {\n    this.tagNames = tagNames;\n    this.bindings = bindings;\n    this.listeners = listeners;\n    this.sourceSpan = sourceSpan;\n    if (tagNames.length === 0) {\n      throw new Error('HostElement must have at least one tag name.');\n    }\n  }\n  visit() {\n    throw new Error(`HostElement cannot be visited`);\n  }\n}\nlet RecursiveVisitor$1 = class RecursiveVisitor {\n  visitElement(element) {\n    visitAll$1(this, element.attributes);\n    visitAll$1(this, element.inputs);\n    visitAll$1(this, element.outputs);\n    visitAll$1(this, element.directives);\n    visitAll$1(this, element.children);\n    visitAll$1(this, element.references);\n  }\n  visitTemplate(template) {\n    visitAll$1(this, template.attributes);\n    visitAll$1(this, template.inputs);\n    visitAll$1(this, template.outputs);\n    visitAll$1(this, template.directives);\n    visitAll$1(this, template.children);\n    visitAll$1(this, template.references);\n    visitAll$1(this, template.variables);\n  }\n  visitDeferredBlock(deferred) {\n    deferred.visitAll(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    visitAll$1(this, block.children);\n  }\n  visitDeferredBlockError(block) {\n    visitAll$1(this, block.children);\n  }\n  visitDeferredBlockLoading(block) {\n    visitAll$1(this, block.children);\n  }\n  visitSwitchBlock(block) {\n    visitAll$1(this, block.cases);\n  }\n  visitSwitchBlockCase(block) {\n    visitAll$1(this, block.children);\n  }\n  visitForLoopBlock(block) {\n    const blockItems = [block.item, ...block.contextVariables, ...block.children];\n    block.empty && blockItems.push(block.empty);\n    visitAll$1(this, blockItems);\n  }\n  visitForLoopBlockEmpty(block) {\n    visitAll$1(this, block.children);\n  }\n  visitIfBlock(block) {\n    visitAll$1(this, block.branches);\n  }\n  visitIfBlockBranch(block) {\n    const blockItems = block.children;\n    block.expressionAlias && blockItems.push(block.expressionAlias);\n    visitAll$1(this, blockItems);\n  }\n  visitContent(content) {\n    visitAll$1(this, content.children);\n  }\n  visitComponent(component) {\n    visitAll$1(this, component.attributes);\n    visitAll$1(this, component.inputs);\n    visitAll$1(this, component.outputs);\n    visitAll$1(this, component.directives);\n    visitAll$1(this, component.children);\n    visitAll$1(this, component.references);\n  }\n  visitDirective(directive) {\n    visitAll$1(this, directive.attributes);\n    visitAll$1(this, directive.inputs);\n    visitAll$1(this, directive.outputs);\n    visitAll$1(this, directive.references);\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitBoundAttribute(attribute) {}\n  visitBoundEvent(attribute) {}\n  visitText(text) {}\n  visitBoundText(text) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitLetDeclaration(decl) {}\n};\nfunction visitAll$1(visitor, nodes) {\n  const result = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      visitor.visit(node);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\nclass Message {\n  nodes;\n  placeholders;\n  placeholderToMessage;\n  meaning;\n  description;\n  customId;\n  sources;\n  id;\n  legacyIds = [];\n  messageString;\n  constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n    this.nodes = nodes;\n    this.placeholders = placeholders;\n    this.placeholderToMessage = placeholderToMessage;\n    this.meaning = meaning;\n    this.description = description;\n    this.customId = customId;\n    this.id = this.customId;\n    this.messageString = serializeMessage(this.nodes);\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\nlet Text$2 = class Text {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitText(this, context);\n  }\n};\nclass Container {\n  children;\n  sourceSpan;\n  constructor(children, sourceSpan) {\n    this.children = children;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitContainer(this, context);\n  }\n}\nclass Icu {\n  expression;\n  type;\n  cases;\n  sourceSpan;\n  expressionPlaceholder;\n  constructor(expression, type, cases, sourceSpan, expressionPlaceholder) {\n    this.expression = expression;\n    this.type = type;\n    this.cases = cases;\n    this.sourceSpan = sourceSpan;\n    this.expressionPlaceholder = expressionPlaceholder;\n  }\n  visit(visitor, context) {\n    return visitor.visitIcu(this, context);\n  }\n}\nclass TagPlaceholder {\n  tag;\n  attrs;\n  startName;\n  closeName;\n  children;\n  isVoid;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.tag = tag;\n    this.attrs = attrs;\n    this.startName = startName;\n    this.closeName = closeName;\n    this.children = children;\n    this.isVoid = isVoid;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\nclass Placeholder {\n  value;\n  name;\n  sourceSpan;\n  constructor(value, name, sourceSpan) {\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\nclass IcuPlaceholder {\n  value;\n  name;\n  sourceSpan;\n  previousMessage;\n  constructor(value, name, sourceSpan) {\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\nclass BlockPlaceholder {\n  name;\n  parameters;\n  startName;\n  closeName;\n  children;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, parameters, startName, closeName, children, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.name = name;\n    this.parameters = parameters;\n    this.startName = startName;\n    this.closeName = closeName;\n    this.children = children;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlockPlaceholder(this, context);\n  }\n}\nclass CloneVisitor {\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitContainer(container, context) {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n  visitIcu(icu, context) {\n    const cases = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan, icu.expressionPlaceholder);\n    return msg;\n  }\n  visitTagPlaceholder(ph, context) {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitPlaceholder(ph, context) {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n  visitIcuPlaceholder(ph, context) {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n  visitBlockPlaceholder(ph, context) {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new BlockPlaceholder(ph.name, ph.parameters, ph.startName, ph.closeName, children, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n}\nclass RecurseVisitor {\n  visitText(text, context) {}\n  visitContainer(container, context) {\n    container.children.forEach(child => child.visit(this));\n  }\n  visitIcu(icu, context) {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n  visitTagPlaceholder(ph, context) {\n    ph.children.forEach(child => child.visit(this));\n  }\n  visitPlaceholder(ph, context) {}\n  visitIcuPlaceholder(ph, context) {}\n  visitBlockPlaceholder(ph, context) {\n    ph.children.forEach(child => child.visit(this));\n  }\n}\nfunction serializeMessage(messageNodes) {\n  const visitor = new LocalizeMessageStringVisitor();\n  const str = messageNodes.map(n => n.visit(visitor)).join('');\n  return str;\n}\nclass LocalizeMessageStringVisitor {\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n  }\n  visitTagPlaceholder(ph) {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n  visitPlaceholder(ph) {\n    return `{$${ph.name}}`;\n  }\n  visitIcuPlaceholder(ph) {\n    return `{$${ph.name}}`;\n  }\n  visitBlockPlaceholder(ph) {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n}\nclass Serializer {\n  createNameMapper(message) {\n    return null;\n  }\n}\nclass SimplePlaceholderMapper extends RecurseVisitor {\n  mapName;\n  internalToPublic = {};\n  publicToNextId = {};\n  publicToInternal = {};\n  constructor(message, mapName) {\n    super();\n    this.mapName = mapName;\n    message.nodes.forEach(node => node.visit(this));\n  }\n  toPublicName(internalName) {\n    return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n  }\n  toInternalName(publicName) {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n  }\n  visitText(text, context) {\n    return null;\n  }\n  visitTagPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n  visitPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.name);\n  }\n  visitBlockPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.startName);\n    super.visitBlockPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n  visitIcuPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.name);\n  }\n  visitPlaceholderName(internalName) {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n    let publicName = this.mapName(internalName);\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\nlet _Visitor$2 = class _Visitor {\n  visitTag(tag) {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n    const strChildren = tag.children.map(node => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n  visitText(text) {\n    return text.value;\n  }\n  visitDeclaration(decl) {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n  _serializeAttributes(attrs) {\n    const strAttrs = Object.keys(attrs).map(name => `${name}=\"${attrs[name]}\"`).join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n  visitDoctype(doctype) {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n};\nconst _visitor = new _Visitor$2();\nfunction serialize$1(nodes) {\n  return nodes.map(node => node.visit(_visitor)).join('');\n}\nclass Declaration {\n  attrs = {};\n  constructor(unescapedAttrs) {\n    Object.keys(unescapedAttrs).forEach(k => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n  visit(visitor) {\n    return visitor.visitDeclaration(this);\n  }\n}\nclass Doctype {\n  rootTag;\n  dtd;\n  constructor(rootTag, dtd) {\n    this.rootTag = rootTag;\n    this.dtd = dtd;\n  }\n  visit(visitor) {\n    return visitor.visitDoctype(this);\n  }\n}\nclass Tag {\n  name;\n  children;\n  attrs = {};\n  constructor(name, unescapedAttrs = {}, children = []) {\n    this.name = name;\n    this.children = children;\n    Object.keys(unescapedAttrs).forEach(k => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n  visit(visitor) {\n    return visitor.visitTag(this);\n  }\n}\nlet Text$1 = class Text {\n  value;\n  constructor(unescapedValue) {\n    this.value = escapeXml(unescapedValue);\n  }\n  visit(visitor) {\n    return visitor.visitText(this);\n  }\n};\nclass CR extends Text$1 {\n  constructor(ws = 0) {\n    super(`\\n${new Array(ws + 1).join(' ')}`);\n  }\n}\nconst _ESCAPED_CHARS = [[/&/g, '&amp;'], [/\"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']];\nfunction escapeXml(text) {\n  return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);\n}\nconst _XMB_HANDLER = 'angular';\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG$3 = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG$2 = 'source';\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\nclass Xmb extends Serializer {\n  write(messages, locale) {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor$1();\n    const rootNode = new Tag(_MESSAGES_TAG);\n    rootNode.attrs['handler'] = _XMB_HANDLER;\n    messages.forEach(message => {\n      const attrs = {\n        id: message.id\n      };\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n      let sourceTags = [];\n      message.sources.forEach(source => {\n        sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n      rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n    });\n    rootNode.children.push(new CR());\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), new Doctype(_MESSAGES_TAG, _DOCTYPE), new CR(), exampleVisitor.addDefaultExamples(rootNode), new CR()]);\n  }\n  load(content, url) {\n    throw new Error('Unsupported');\n  }\n  digest(message) {\n    return digest(message);\n  }\n  createNameMapper(message) {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\nlet _Visitor$1 = class _Visitor {\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const startTagAsText = new Text$1(`<${ph.tag}>`);\n    const startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.startName\n    }, [startEx, startTagAsText]);\n    if (ph.isVoid) {\n      return [startTagPh];\n    }\n    const closeTagAsText = new Text$1(`</${ph.tag}>`);\n    const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.closeName\n    }, [closeEx, closeTagAsText]);\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitPlaceholder(ph, context) {\n    const interpolationAsText = new Text$1(`{{${ph.value}}}`);\n    const exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.name\n    }, [exTag, interpolationAsText])];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const startAsText = new Text$1(`@${ph.name}`);\n    const startEx = new Tag(_EXAMPLE_TAG, {}, [startAsText]);\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.startName\n    }, [startEx, startAsText]);\n    const closeAsText = new Text$1(`}`);\n    const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeAsText]);\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.closeName\n    }, [closeEx, closeAsText]);\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ');\n    const icuAsText = new Text$1(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.name\n    }, [exTag, icuAsText])];\n  }\n  serialize(nodes) {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n};\nfunction digest(message) {\n  return decimalDigest(message);\n}\nclass ExampleVisitor {\n  addDefaultExamples(node) {\n    node.visit(this);\n    return node;\n  }\n  visitTag(tag) {\n    if (tag.name === _PLACEHOLDER_TAG$3) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new Text$1(tag.attrs['name'] || '...');\n        tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n  visitText(text) {}\n  visitDeclaration(decl) {}\n  visitDoctype(doctype) {}\n}\nfunction toPublicName(internalName) {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\nconst I18N_ATTR = 'i18n';\nconst I18N_ATTR_PREFIX = 'i18n-';\nconst I18N_ICU_VAR_PREFIX = 'VAR_';\nfunction isI18nAttribute(name) {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\nfunction hasI18nAttrs(node) {\n  return node.attrs.some(attr => isI18nAttribute(attr.name));\n}\nfunction icuFromI18nMessage(message) {\n  return message.nodes[0];\n}\nfunction formatI18nPlaceholderNamesInMap(params = {}, useCamelCase) {\n  const _params = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\nfunction formatI18nPlaceholderName(name, useCamelCase = true) {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    return name.toLowerCase();\n  }\n  let postfix;\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift().toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\nconst TEMPORARY_NAME = '_t';\nconst CONTEXT_NAME = 'ctx';\nconst RENDER_FLAGS = 'rf';\nfunction temporaryAllocator(pushStatement, name) {\n  let temp = null;\n  return () => {\n    if (!temp) {\n      pushStatement(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n      temp = variable(name);\n    }\n    return temp;\n  };\n}\nfunction asLiteral(value) {\n  if (Array.isArray(value)) {\n    return literalArr(value.map(asLiteral));\n  }\n  return literal(value, INFERRED_TYPE);\n}\nfunction conditionallyCreateDirectiveBindingLiteral(map, forInputs) {\n  const keys = Object.getOwnPropertyNames(map);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(key => {\n    const value = map[key];\n    let declaredName;\n    let publicName;\n    let minifiedName;\n    let expressionValue;\n    if (typeof value === 'string') {\n      declaredName = key;\n      minifiedName = key;\n      publicName = value;\n      expressionValue = asLiteral(publicName);\n    } else {\n      minifiedName = key;\n      declaredName = value.classPropertyName;\n      publicName = value.bindingPropertyName;\n      const differentDeclaringName = publicName !== declaredName;\n      const hasDecoratorInputTransform = value.transformFunction !== null;\n      let flags = InputFlags.None;\n      if (value.isSignal) {\n        flags |= InputFlags.SignalBased;\n      }\n      if (hasDecoratorInputTransform) {\n        flags |= InputFlags.HasDecoratorInputTransform;\n      }\n      if (forInputs && (differentDeclaringName || hasDecoratorInputTransform || flags !== InputFlags.None)) {\n        const result = [literal(flags), asLiteral(publicName)];\n        if (differentDeclaringName || hasDecoratorInputTransform) {\n          result.push(asLiteral(declaredName));\n          if (hasDecoratorInputTransform) {\n            result.push(value.transformFunction);\n          }\n        }\n        expressionValue = literalArr(result);\n      } else {\n        expressionValue = asLiteral(publicName);\n      }\n    }\n    return {\n      key: minifiedName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: expressionValue\n    };\n  }));\n}\nclass DefinitionMap {\n  values = [];\n  set(key, value) {\n    if (value) {\n      const existing = this.values.find(value => value.key === key);\n      if (existing) {\n        existing.value = value;\n      } else {\n        this.values.push({\n          key: key,\n          value,\n          quoted: false\n        });\n      }\n    }\n  }\n  toLiteralMap() {\n    return literalMap(this.values);\n  }\n}\nfunction createCssSelectorFromNode(node) {\n  const elementName = node instanceof Element$1 ? node.name : 'ng-template';\n  const attributes = getAttrsForDirectiveMatching(node);\n  const cssSelector = new CssSelector();\n  const elementNameNoNs = splitNsName(elementName)[1];\n  cssSelector.setElement(elementNameNoNs);\n  Object.getOwnPropertyNames(attributes).forEach(name => {\n    const nameNoNs = splitNsName(name)[1];\n    const value = attributes[name];\n    cssSelector.addAttribute(nameNoNs, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  });\n  return cssSelector;\n}\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n  const attributesMap = {};\n  if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n    elOrTpl.inputs.forEach(i => {\n      if (i.type === BindingType.Property || i.type === BindingType.TwoWay) {\n        attributesMap[i.name] = '';\n      }\n    });\n    elOrTpl.outputs.forEach(o => {\n      attributesMap[o.name] = '';\n    });\n  }\n  return attributesMap;\n}\nfunction compileInjectable(meta, resolveForwardRefs) {\n  let result = null;\n  const factoryMeta = {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable\n  };\n  if (meta.useClass !== undefined) {\n    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.type.value);\n    let deps = undefined;\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n    if (deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function\n      });\n    } else {\n      result = {\n        statements: [],\n        expression: arrowFn([], meta.useFactory.callFn([]))\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue.expression\n    });\n  } else if (meta.useExisting !== undefined) {\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression])\n    });\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(meta.type.value, meta.type.value, resolveForwardRefs)\n    };\n  }\n  const token = meta.type.value;\n  const injectableProps = new DefinitionMap();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression);\n  if (meta.providedIn.expression.value !== null) {\n    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n  }\n  const expression = importExpr(Identifiers.ÉµÉµdefineInjectable).callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression,\n    type: createInjectableType(meta),\n    statements: result.statements\n  };\n}\nfunction createInjectableType(meta) {\n  return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\nfunction delegateToFactory(type, useType, unwrapForwardRefs) {\n  if (type.node === useType.node) {\n    return useType.prop('Éµfac');\n  }\n  if (!unwrapForwardRefs) {\n    return createFactoryFunction(useType);\n  }\n  const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([useType]);\n  return createFactoryFunction(unwrappedType);\n}\nfunction createFactoryFunction(type) {\n  const t = new FnParam('__ngFactoryType__', DYNAMIC_TYPE);\n  return arrowFn([t], type.prop('Éµfac').callFn([variable(t.name)]));\n}\nconst $EOF = 0;\nconst $BSPACE = 8;\nconst $TAB = 9;\nconst $LF = 10;\nconst $VTAB = 11;\nconst $FF = 12;\nconst $CR = 13;\nconst $SPACE = 32;\nconst $BANG = 33;\nconst $DQ = 34;\nconst $HASH = 35;\nconst $$ = 36;\nconst $PERCENT = 37;\nconst $AMPERSAND = 38;\nconst $SQ = 39;\nconst $LPAREN = 40;\nconst $RPAREN = 41;\nconst $STAR = 42;\nconst $PLUS = 43;\nconst $COMMA = 44;\nconst $MINUS = 45;\nconst $PERIOD = 46;\nconst $SLASH = 47;\nconst $COLON = 58;\nconst $SEMICOLON = 59;\nconst $LT = 60;\nconst $EQ = 61;\nconst $GT = 62;\nconst $QUESTION = 63;\nconst $0 = 48;\nconst $7 = 55;\nconst $9 = 57;\nconst $A = 65;\nconst $E = 69;\nconst $F = 70;\nconst $X = 88;\nconst $Z = 90;\nconst $LBRACKET = 91;\nconst $BACKSLASH = 92;\nconst $RBRACKET = 93;\nconst $CARET = 94;\nconst $_ = 95;\nconst $a = 97;\nconst $b = 98;\nconst $e = 101;\nconst $f = 102;\nconst $n = 110;\nconst $r = 114;\nconst $t = 116;\nconst $u = 117;\nconst $v = 118;\nconst $x = 120;\nconst $z = 122;\nconst $LBRACE = 123;\nconst $BAR = 124;\nconst $RBRACE = 125;\nconst $NBSP = 160;\nconst $AT = 64;\nconst $BT = 96;\nfunction isWhitespace(code) {\n  return code >= $TAB && code <= $SPACE || code == $NBSP;\n}\nfunction isDigit(code) {\n  return $0 <= code && code <= $9;\n}\nfunction isAsciiLetter(code) {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\nfunction isAsciiHexDigit(code) {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\nfunction isNewLine(code) {\n  return code === $LF || code === $CR;\n}\nfunction isOctalDigit(code) {\n  return $0 <= code && code <= $7;\n}\nfunction isQuote(code) {\n  return code === $SQ || code === $DQ || code === $BT;\n}\nclass ParseLocation {\n  file;\n  offset;\n  line;\n  col;\n  constructor(file, offset, line, col) {\n    this.file = file;\n    this.offset = offset;\n    this.line = line;\n    this.col = col;\n  }\n  toString() {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n  moveBy(delta) {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == $LF) {\n        line--;\n        const priorLine = source.substring(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == $LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n  getContext(maxChars, maxLines) {\n    const content = this.file.content;\n    let startOffset = this.offset;\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1)\n      };\n    }\n    return null;\n  }\n}\nclass ParseSourceFile {\n  content;\n  url;\n  constructor(content, url) {\n    this.content = content;\n    this.url = url;\n  }\n}\nclass ParseSourceSpan {\n  start;\n  end;\n  fullStart;\n  details;\n  constructor(start, end, fullStart = start, details = null) {\n    this.start = start;\n    this.end = end;\n    this.fullStart = fullStart;\n    this.details = details;\n  }\n  toString() {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\nvar ParseErrorLevel = /*#__PURE__*/function (ParseErrorLevel) {\n  ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n  ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n  return ParseErrorLevel;\n}(ParseErrorLevel || {});\nclass ParseError extends Error {\n  span;\n  msg;\n  level;\n  relatedError;\n  constructor(span, msg, level = ParseErrorLevel.ERROR, relatedError) {\n    super(msg);\n    this.span = span;\n    this.msg = msg;\n    this.level = level;\n    this.relatedError = relatedError;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n  contextualMessage() {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` : this.msg;\n  }\n  toString() {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\nlet _anonymousTypeIndex = 0;\nfunction identifierName(compileIdentifier) {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\nfunction sanitizeIdentifier(name) {\n  return name.replace(/\\W/g, '_');\n}\nconst makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\nclass AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() {\n    super(false);\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n  visitDeclareVarStmt(stmt, ctx) {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitTaggedTemplateLiteralExpr(ast, ctx) {\n    const elements = ast.template.elements;\n    ast.tag.visitExpression(this, ctx);\n    ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n    ast.template.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitTemplateLiteralExpr(expr, ctx) {\n    ctx.print(expr, '`');\n    for (let i = 0; i < expr.elements.length; i++) {\n      expr.elements[i].visitExpression(this, ctx);\n      const expression = i < expr.expressions.length ? expr.expressions[i] : null;\n      if (expression !== null) {\n        ctx.print(expression, '${');\n        expression.visitExpression(this, ctx);\n        ctx.print(expression, '}');\n      }\n    }\n    ctx.print(expr, '`');\n  }\n  visitTemplateLiteralElementExpr(expr, ctx) {\n    ctx.print(expr, expr.rawText);\n    return null;\n  }\n  visitFunctionExpr(ast, ctx) {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitArrowFunctionExpr(ast, ctx) {\n    ctx.print(ast, '(');\n    this._visitParams(ast.params, ctx);\n    ctx.print(ast, ') =>');\n    if (Array.isArray(ast.body)) {\n      ctx.println(ast, `{`);\n      ctx.incIndent();\n      this.visitAllStatements(ast.body, ctx);\n      ctx.decIndent();\n      ctx.print(ast, `}`);\n    } else {\n      const isObjectLiteral = ast.body instanceof LiteralMapExpr;\n      if (isObjectLiteral) {\n        ctx.print(ast, '(');\n      }\n      ast.body.visitExpression(this, ctx);\n      if (isObjectLiteral) {\n        ctx.print(ast, ')');\n      }\n    }\n    return null;\n  }\n  visitDeclareFunctionStmt(stmt, ctx) {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  visitLocalizedString(ast, ctx) {\n    ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  _visitParams(params, ctx) {\n    this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n  }\n}\nlet policy;\nfunction getPolicy() {\n  if (policy === undefined) {\n    const trustedTypes = _global['trustedTypes'];\n    policy = null;\n    if (trustedTypes) {\n      try {\n        policy = trustedTypes.createPolicy('angular#unsafe-jit', {\n          createScript: s => s\n        });\n      } catch {}\n    }\n  }\n  return policy;\n}\nfunction trustedScriptFromString(script) {\n  return getPolicy()?.createScript(script) || script;\n}\nfunction newTrustedFunctionForJIT(...args) {\n  if (!_global['trustedTypes']) {\n    return new Function(...args);\n  }\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n  const fn = _global['eval'](trustedScriptFromString(body));\n  if (fn.bind === undefined) {\n    return new Function(...args);\n  }\n  fn.toString = () => body;\n  return fn.bind(_global);\n}\nclass JitEvaluator {\n  evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {\n    const converter = new JitEmitterVisitor(refResolver);\n    const ctx = EmitterVisitorContext.createRoot();\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [literal('use strict').toStmt(), ...statements];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n  evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames = [];\n    const fnArgValues = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n  executeFunction(fn, args) {\n    return fn(...args);\n  }\n}\nclass JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  refResolver;\n  _evalArgNames = [];\n  _evalArgValues = [];\n  _evalExportedVars = [];\n  constructor(refResolver) {\n    super();\n    this.refResolver = refResolver;\n  }\n  createReturnStmt(ctx) {\n    const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n  getArgs() {\n    const result = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n  visitExternalExpr(ast, ctx) {\n    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n  visitDeclareVarStmt(stmt, ctx) {\n    if (stmt.hasModifier(StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n  visitDeclareFunctionStmt(stmt, ctx) {\n    if (stmt.hasModifier(StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n  _emitReferenceToExternal(ast, value, ctx) {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({\n        reference: value\n      }) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\nfunction isUseStrictStatement(statement) {\n  return statement.isEquivalent(literal('use strict').toStmt());\n}\nfunction compileInjector(meta) {\n  const definitionMap = new DefinitionMap();\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', literalArr(meta.imports));\n  }\n  const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createInjectorType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectorType(meta) {\n  return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));\n}\nclass R3JitReflector {\n  context;\n  constructor(context) {\n    this.context = context;\n  }\n  resolveExternalReference(ref) {\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);\n    }\n    if (!this.context.hasOwnProperty(ref.name)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);\n    }\n    return this.context[ref.name];\n  }\n}\nvar R3SelectorScopeMode = /*#__PURE__*/function (R3SelectorScopeMode) {\n  R3SelectorScopeMode[R3SelectorScopeMode[\"Inline\"] = 0] = \"Inline\";\n  R3SelectorScopeMode[R3SelectorScopeMode[\"SideEffect\"] = 1] = \"SideEffect\";\n  R3SelectorScopeMode[R3SelectorScopeMode[\"Omit\"] = 2] = \"Omit\";\n  return R3SelectorScopeMode;\n}(R3SelectorScopeMode || {});\nvar R3NgModuleMetadataKind = /*#__PURE__*/function (R3NgModuleMetadataKind) {\n  R3NgModuleMetadataKind[R3NgModuleMetadataKind[\"Global\"] = 0] = \"Global\";\n  R3NgModuleMetadataKind[R3NgModuleMetadataKind[\"Local\"] = 1] = \"Local\";\n  return R3NgModuleMetadataKind;\n}(R3NgModuleMetadataKind || {});\nfunction compileNgModule(meta) {\n  const statements = [];\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('type', meta.type.value);\n  if (meta.kind === R3NgModuleMetadataKind.Global && meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n  if (meta.selectorScopeMode === R3SelectorScopeMode.Inline) {\n    if (meta.declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n    if (meta.imports.length > 0) {\n      definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n    if (meta.exports.length > 0) {\n      definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else if (meta.selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else ;\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n  }\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n    statements.push(importExpr(Identifiers.registerNgModuleType).callFn([meta.type.value, meta.id]).toStmt());\n  }\n  const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n  return {\n    expression,\n    type,\n    statements\n  };\n}\nfunction compileNgModuleDeclarationExpression(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('type', new WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new WrappedNodeExpr(meta.id));\n  }\n  return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\nfunction createNgModuleType(meta) {\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    return new ExpressionType(meta.type.value);\n  }\n  const {\n    type: moduleType,\n    declarations,\n    exports,\n    imports,\n    includeImportTypes,\n    publicDeclarationTypes\n  } = meta;\n  return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [new ExpressionType(moduleType.type), publicDeclarationTypes === null ? tupleTypeOf(declarations) : tupleOfTypes(publicDeclarationTypes), includeImportTypes ? tupleTypeOf(imports) : NONE_TYPE, tupleTypeOf(exports)]));\n}\nfunction generateSetNgModuleScopeCall(meta) {\n  const scopeMap = new DefinitionMap();\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.declarations.length > 0) {\n      scopeMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.declarationsExpression) {\n      scopeMap.set('declarations', meta.declarationsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.imports.length > 0) {\n      scopeMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.importsExpression) {\n      scopeMap.set('imports', meta.importsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.exports.length > 0) {\n      scopeMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.exportsExpression) {\n      scopeMap.set('exports', meta.exportsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Local && meta.bootstrapExpression) {\n    scopeMap.set('bootstrap', meta.bootstrapExpression);\n  }\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n  const fnCall = new InvokeFunctionExpr(importExpr(Identifiers.setNgModuleScope), [meta.type.value, scopeMap.toLiteralMap()]);\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n  const iife = new FunctionExpr([], [guardedCall.toStmt()]);\n  const iifeCall = new InvokeFunctionExpr(iife, []);\n  return iifeCall.toStmt();\n}\nfunction tupleTypeOf(exp) {\n  const types = exp.map(ref => typeofExpr(ref.type));\n  return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\nfunction tupleOfTypes(types) {\n  const typeofTypes = types.map(type => typeofExpr(type));\n  return types.length > 0 ? expressionType(literalArr(typeofTypes)) : NONE_TYPE;\n}\nfunction compilePipeFromMetadata(metadata) {\n  const definitionMapValues = [];\n  definitionMapValues.push({\n    key: 'name',\n    value: literal(metadata.pipeName ?? metadata.name),\n    quoted: false\n  });\n  definitionMapValues.push({\n    key: 'type',\n    value: metadata.type.value,\n    quoted: false\n  });\n  definitionMapValues.push({\n    key: 'pure',\n    value: literal(metadata.pure),\n    quoted: false\n  });\n  if (metadata.isStandalone === false) {\n    definitionMapValues.push({\n      key: 'standalone',\n      value: literal(false),\n      quoted: false\n    });\n  }\n  const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);\n  const type = createPipeType(metadata);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createPipeType(metadata) {\n  return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [typeWithParameters(metadata.type.type, metadata.typeArgumentCount), new ExpressionType(new LiteralExpr(metadata.pipeName)), new ExpressionType(new LiteralExpr(metadata.isStandalone))]));\n}\nvar R3TemplateDependencyKind = /*#__PURE__*/function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n  return R3TemplateDependencyKind;\n}(R3TemplateDependencyKind || {});\nconst animationKeywords = new Set(['inherit', 'initial', 'revert', 'unset', 'alternate', 'alternate-reverse', 'normal', 'reverse', 'backwards', 'both', 'forwards', 'none', 'paused', 'running', 'ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-start', 'step-end', 'end', 'jump-both', 'jump-end', 'jump-none', 'jump-start', 'start']);\nconst scopedAtRuleIdentifiers = ['@media', '@supports', '@document', '@layer', '@container', '@scope', '@starting-style'];\nclass ShadowCss {\n  shimCssText(cssText, selector, hostSelector = '') {\n    const comments = [];\n    cssText = cssText.replace(_commentRe, m => {\n      if (m.match(_commentWithHashRe)) {\n        comments.push(m);\n      } else {\n        const newLinesMatches = m.match(_newLinesRe);\n        comments.push((newLinesMatches?.join('') ?? '') + '\\n');\n      }\n      return COMMENT_PLACEHOLDER;\n    });\n    cssText = this._insertDirectives(cssText);\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    let commentIdx = 0;\n    return scopedCssText.replace(_commentWithHashPlaceHolderRe, () => comments[commentIdx++]);\n  }\n  _insertDirectives(cssText) {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n  _scopeKeyframesRelatedCss(cssText, scopeSelector) {\n    const unscopedKeyframesSet = new Set();\n    const scopedKeyframesCssText = processRules(cssText, rule => this._scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet));\n    return processRules(scopedKeyframesCssText, rule => this._scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet));\n  }\n  _scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet) {\n    return {\n      ...rule,\n      selector: rule.selector.replace(/(^@(?:-webkit-)?keyframes(?:\\s+))(['\"]?)(.+)\\2(\\s*)$/, (_, start, quote, keyframeName, endSpaces) => {\n        unscopedKeyframesSet.add(unescapeQuotes(keyframeName, quote));\n        return `${start}${quote}${scopeSelector}_${keyframeName}${quote}${endSpaces}`;\n      })\n    };\n  }\n  _scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet) {\n    return keyframe.replace(/^(\\s*)(['\"]?)(.+?)\\2(\\s*)$/, (_, spaces1, quote, name, spaces2) => {\n      name = `${unscopedKeyframesSet.has(unescapeQuotes(name, quote)) ? scopeSelector + '_' : ''}${name}`;\n      return `${spaces1}${quote}${name}${quote}${spaces2}`;\n    });\n  }\n  _animationDeclarationKeyframesRe = /(^|\\s+|,)(?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))(?=[,\\s]|$)/g;\n  _scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet) {\n    let content = rule.content.replace(/((?:^|\\s+|;)(?:-webkit-)?animation\\s*:\\s*),*([^;]+)/g, (_, start, animationDeclarations) => start + animationDeclarations.replace(this._animationDeclarationKeyframesRe, (original, leadingSpaces, quote = '', quotedName, nonQuotedName) => {\n      if (quotedName) {\n        return `${leadingSpaces}${this._scopeAnimationKeyframe(`${quote}${quotedName}${quote}`, scopeSelector, unscopedKeyframesSet)}`;\n      } else {\n        return animationKeywords.has(nonQuotedName) ? original : `${leadingSpaces}${this._scopeAnimationKeyframe(nonQuotedName, scopeSelector, unscopedKeyframesSet)}`;\n      }\n    }));\n    content = content.replace(/((?:^|\\s+|;)(?:-webkit-)?animation-name(?:\\s*):(?:\\s*))([^;]+)/g, (_match, start, commaSeparatedKeyframes) => `${start}${commaSeparatedKeyframes.split(',').map(keyframe => this._scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet)).join(',')}`);\n    return {\n      ...rule,\n      content\n    };\n  }\n  _insertPolyfillDirectivesInCssText(cssText) {\n    return cssText.replace(_cssContentNextSelectorRe, function (...m) {\n      return m[2] + '{';\n    });\n  }\n  _insertPolyfillRulesInCssText(cssText) {\n    return cssText.replace(_cssContentRuleRe, (...m) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n  _scopeCssText(cssText, scopeSelector, hostSelector) {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeKeyframesRelatedCss(cssText, scopeSelector);\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n  _extractUnscopedRulesFromCssText(cssText) {\n    let r = '';\n    let m;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n  _convertColonHost(cssText) {\n    return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {\n      if (hostSelectors) {\n        const convertedSelectors = [];\n        for (const hostSelector of this._splitOnTopLevelCommas(hostSelectors, true)) {\n          const trimmedHostSelector = hostSelector.trim();\n          if (!trimmedHostSelector) break;\n          const convertedSelector = _polyfillHostNoCombinator + trimmedHostSelector.replace(_polyfillHost, '') + otherSelectors;\n          convertedSelectors.push(convertedSelector);\n        }\n        return convertedSelectors.join(',');\n      } else {\n        return _polyfillHostNoCombinator + otherSelectors;\n      }\n    });\n  }\n  *_splitOnTopLevelCommas(text, returnOnClosingParen) {\n    const length = text.length;\n    let parens = 0;\n    let prev = 0;\n    for (let i = 0; i < length; i++) {\n      const charCode = text.charCodeAt(i);\n      if (charCode === $LPAREN) {\n        parens++;\n      } else if (charCode === $RPAREN) {\n        parens--;\n        if (parens < 0 && returnOnClosingParen) {\n          yield text.slice(prev, i);\n          return;\n        }\n      } else if (charCode === $COMMA && parens === 0) {\n        yield text.slice(prev, i);\n        prev = i + 1;\n      }\n    }\n    yield text.slice(prev);\n  }\n  _convertColonHostContext(cssText) {\n    const results = [];\n    for (const part of this._splitOnTopLevelCommas(cssText, false)) {\n      results.push(this._convertColonHostContextInSelectorPart(part));\n    }\n    return results.join(',');\n  }\n  _convertColonHostContextInSelectorPart(cssText) {\n    return cssText.replace(_cssColonHostContextReGlobal, (selectorText, pseudoPrefix) => {\n      const contextSelectorGroups = [[]];\n      let startIndex = selectorText.indexOf(_polyfillHostContext);\n      while (startIndex !== -1) {\n        const afterPrefix = selectorText.substring(startIndex + _polyfillHostContext.length);\n        if (!afterPrefix || afterPrefix[0] !== '(') {\n          selectorText = afterPrefix;\n          startIndex = selectorText.indexOf(_polyfillHostContext);\n          continue;\n        }\n        const newContextSelectors = [];\n        let endIndex = 0;\n        for (const selector of this._splitOnTopLevelCommas(afterPrefix.substring(1), true)) {\n          endIndex = endIndex + selector.length + 1;\n          const trimmed = selector.trim();\n          if (trimmed) {\n            newContextSelectors.push(trimmed);\n          }\n        }\n        const contextSelectorGroupsLength = contextSelectorGroups.length;\n        repeatGroups(contextSelectorGroups, newContextSelectors.length);\n        for (let i = 0; i < newContextSelectors.length; i++) {\n          for (let j = 0; j < contextSelectorGroupsLength; j++) {\n            contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);\n          }\n        }\n        selectorText = afterPrefix.substring(endIndex + 1);\n        startIndex = selectorText.indexOf(_polyfillHostContext);\n      }\n      return contextSelectorGroups.map(contextSelectors => _combineHostContextSelectors(contextSelectors, selectorText, pseudoPrefix)).join(', ');\n    });\n  }\n  _convertShadowDOMSelectors(cssText) {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n  _scopeSelectors(cssText, scopeSelector, hostSelector) {\n    return processRules(cssText, rule => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] !== '@') {\n        selector = this._scopeSelector({\n          selector,\n          scopeSelector,\n          hostSelector,\n          isParentSelector: true\n        });\n      } else if (scopedAtRuleIdentifiers.some(atRule => rule.selector.startsWith(atRule))) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n        content = this._stripScopingSelectors(rule.content);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n  _stripScopingSelectors(cssText) {\n    return processRules(cssText, rule => {\n      const selector = rule.selector.replace(_shadowDeepSelectors, ' ').replace(_polyfillHostNoCombinatorRe, ' ');\n      return new CssRule(selector, rule.content);\n    });\n  }\n  _safeSelector;\n  _shouldScopeIndicator;\n  _scopeSelector({\n    selector,\n    scopeSelector,\n    hostSelector,\n    isParentSelector = false\n  }) {\n    const selectorSplitRe = / ?,(?!(?:[^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))) ?/;\n    return selector.split(selectorSplitRe).map(part => part.split(_shadowDeepSelectors)).map(deepParts => {\n      const [shallowPart, ...otherParts] = deepParts;\n      const applyScope = shallowPart => {\n        if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n          return this._applySelectorScope({\n            selector: shallowPart,\n            scopeSelector,\n            hostSelector,\n            isParentSelector\n          });\n        } else {\n          return shallowPart;\n        }\n      };\n      return [applyScope(shallowPart), ...otherParts].join(' ');\n    }).join(', ');\n  }\n  _selectorNeedsScoping(selector, scopeSelector) {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n  _makeScopeMatcher(scopeSelector) {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n  _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = `[${hostSelector}]`;\n      let result = selector;\n      while (result.match(_polyfillHostNoCombinatorRe)) {\n        result = result.replace(_polyfillHostNoCombinatorRe, (_hnc, selector) => {\n          return selector.replace(/([^:\\)]*)(:*)(.*)/, (_, before, colon, after) => {\n            return before + replaceBy + colon + after;\n          });\n        });\n      }\n      return result.replace(_polyfillHostRe, replaceBy);\n    }\n    return scopeSelector + ' ' + selector;\n  }\n  _applySelectorScope({\n    selector,\n    scopeSelector,\n    hostSelector,\n    isParentSelector\n  }) {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);\n    const attrName = `[${scopeSelector}]`;\n    const _scopeSelectorPart = p => {\n      let scopedP = p.trim();\n      if (!scopedP) {\n        return p;\n      }\n      if (p.includes(_polyfillHostNoCombinator)) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n        if (!p.match(_polyfillHostNoCombinatorOutsidePseudoFunction)) {\n          const [_, before, colon, after] = scopedP.match(/([^:]*)(:*)([\\s\\S]*)/);\n          scopedP = before + attrName + colon + after;\n        }\n      } else {\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)([\\s\\S]*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n      return scopedP;\n    };\n    const _pseudoFunctionAwareScopeSelectorPart = selectorPart => {\n      let scopedPart = '';\n      const pseudoSelectorParts = [];\n      let pseudoSelectorMatch;\n      while ((pseudoSelectorMatch = _cssPrefixWithPseudoSelectorFunction.exec(selectorPart)) !== null) {\n        let openedBrackets = 1;\n        let index = _cssPrefixWithPseudoSelectorFunction.lastIndex;\n        while (index < selectorPart.length) {\n          const currentSymbol = selectorPart[index];\n          index++;\n          if (currentSymbol === '(') {\n            openedBrackets++;\n            continue;\n          }\n          if (currentSymbol === ')') {\n            openedBrackets--;\n            if (openedBrackets === 0) {\n              break;\n            }\n            continue;\n          }\n        }\n        pseudoSelectorParts.push(`${pseudoSelectorMatch[0]}${selectorPart.slice(_cssPrefixWithPseudoSelectorFunction.lastIndex, index)}`);\n        _cssPrefixWithPseudoSelectorFunction.lastIndex = index;\n      }\n      if (pseudoSelectorParts.join('') === selectorPart) {\n        scopedPart = pseudoSelectorParts.map(selectorPart => {\n          const [cssPseudoSelectorFunction] = selectorPart.match(_cssPrefixWithPseudoSelectorFunction) ?? [];\n          const selectorToScope = selectorPart.slice(cssPseudoSelectorFunction?.length, -1);\n          if (selectorToScope.includes(_polyfillHostNoCombinator)) {\n            this._shouldScopeIndicator = true;\n          }\n          const scopedInnerPart = this._scopeSelector({\n            selector: selectorToScope,\n            scopeSelector,\n            hostSelector\n          });\n          return `${cssPseudoSelectorFunction}${scopedInnerPart})`;\n        }).join('');\n      } else {\n        this._shouldScopeIndicator = this._shouldScopeIndicator || selectorPart.includes(_polyfillHostNoCombinator);\n        scopedPart = this._shouldScopeIndicator ? _scopeSelectorPart(selectorPart) : selectorPart;\n      }\n      return scopedPart;\n    };\n    if (isParentSelector) {\n      this._safeSelector = new SafeSelector(selector);\n      selector = this._safeSelector.content();\n    }\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res;\n    const sep = /( |>|\\+|~(?!=))(?!([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)))\\s*/g;\n    const hasHost = selector.includes(_polyfillHostNoCombinator);\n    if (isParentSelector || this._shouldScopeIndicator) {\n      this._shouldScopeIndicator = !hasHost;\n    }\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      const part = selector.slice(startIndex, res.index);\n      if (part.match(/__esc-ph-(\\d+)__/) && selector[res.index + 1]?.match(/[a-fA-F\\d]/)) {\n        continue;\n      }\n      const scopedPart = _pseudoFunctionAwareScopeSelectorPart(part);\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n    const part = selector.substring(startIndex);\n    scopedSelector += _pseudoFunctionAwareScopeSelectorPart(part);\n    return this._safeSelector.restore(scopedSelector);\n  }\n  _insertPolyfillHostInCssText(selector) {\n    return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);\n  }\n}\nclass SafeSelector {\n  placeholders = [];\n  index = 0;\n  _content;\n  constructor(selector) {\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n    selector = selector.replace(/(\\\\.)/g, (_, keep) => {\n      const replaceBy = `__esc-ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n    this._content = selector.replace(nthRegex, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(`(${exp})`);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n  restore(content) {\n    return content.replace(/__(?:ph|esc-ph)-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\n  }\n  content() {\n    return this._content;\n  }\n  _escapeRegexMatches(content, pattern) {\n    return content.replace(pattern, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n  }\n}\nconst _cssScopedPseudoFunctionPrefix = '(:(where|is)\\\\()?';\nconst _cssPrefixWithPseudoSelectorFunction = /:(where|is)\\(/gi;\nconst _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _noParens = '[^)(]*';\nconst _level1Parens = String.raw`(?:\\(${_noParens}\\)|${_noParens})+?`;\nconst _level2Parens = String.raw`(?:\\(${_level1Parens}\\)|${_noParens})+?`;\nconst _parenSuffix = String.raw`(?:\\((${_level2Parens})\\))`;\nconst nthRegex = new RegExp(String.raw`(:nth-[-\\w]+)` + _parenSuffix, 'g');\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix + '?([^,{]*)', 'gim');\nconst _hostContextPattern = _polyfillHostContext + _parenSuffix + '?([^{]*)';\nconst _cssColonHostContextReGlobal = new RegExp(`${_cssScopedPseudoFunctionPrefix}(${_hostContextPattern})`, 'gim');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorOutsidePseudoFunction = new RegExp(`${_polyfillHostNoCombinator}(?![^(]*\\\\))`, 'g');\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s,]*)/;\nconst _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, /\\/shadow-deep\\//g, /\\/shadow\\//g];\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\nconst _newLinesRe = /\\r?\\n/g;\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=/g;\nconst COMMENT_PLACEHOLDER = '%COMMENT%';\nconst _commentWithHashPlaceHolderRe = new RegExp(COMMENT_PLACEHOLDER, 'g');\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst _ruleRe = new RegExp(`(\\\\s*(?:${COMMENT_PLACEHOLDER}\\\\s*)*)([^;\\\\{\\\\}]+?)(\\\\s*)((?:{%BLOCK%}?\\\\s*;?)|(?:\\\\s*;))`, 'g');\nconst CONTENT_PAIRS = new Map([['{', '}']]);\nconst COMMA_IN_PLACEHOLDER = '%COMMA_IN_PLACEHOLDER%';\nconst SEMI_IN_PLACEHOLDER = '%SEMI_IN_PLACEHOLDER%';\nconst COLON_IN_PLACEHOLDER = '%COLON_IN_PLACEHOLDER%';\nconst _cssCommaInPlaceholderReGlobal = new RegExp(COMMA_IN_PLACEHOLDER, 'g');\nconst _cssSemiInPlaceholderReGlobal = new RegExp(SEMI_IN_PLACEHOLDER, 'g');\nconst _cssColonInPlaceholderReGlobal = new RegExp(COLON_IN_PLACEHOLDER, 'g');\nclass CssRule {\n  selector;\n  content;\n  constructor(selector, content) {\n    this.selector = selector;\n    this.content = content;\n  }\n}\nfunction processRules(input, ruleCallback) {\n  const escaped = escapeInStrings(input);\n  const inputWithEscapedBlocks = escapeBlocks(escaped, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  let nextBlockIndex = 0;\n  const escapedResult = inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {\n    const selector = m[2];\n    let content = '';\n    let suffix = m[4];\n    let contentPrefix = '';\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n    const rule = ruleCallback(new CssRule(selector, content));\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n  return unescapeInStrings(escapedResult);\n}\nclass StringWithEscapedBlocks {\n  escapedString;\n  blocks;\n  constructor(escapedString, blocks) {\n    this.escapedString = escapedString;\n    this.blocks = blocks;\n  }\n}\nfunction escapeBlocks(input, charPairs, placeholder) {\n  const resultParts = [];\n  const escapedBlocks = [];\n  let openCharCount = 0;\n  let nonBlockStartIndex = 0;\n  let blockStartIndex = -1;\n  let openChar;\n  let closeChar;\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\nconst ESCAPE_IN_STRING_MAP = {\n  ';': SEMI_IN_PLACEHOLDER,\n  ',': COMMA_IN_PLACEHOLDER,\n  ':': COLON_IN_PLACEHOLDER\n};\nfunction escapeInStrings(input) {\n  let result = input;\n  let currentQuoteChar = null;\n  for (let i = 0; i < result.length; i++) {\n    const char = result[i];\n    if (char === '\\\\') {\n      i++;\n    } else {\n      if (currentQuoteChar !== null) {\n        if (char === currentQuoteChar) {\n          currentQuoteChar = null;\n        } else {\n          const placeholder = ESCAPE_IN_STRING_MAP[char];\n          if (placeholder) {\n            result = `${result.substr(0, i)}${placeholder}${result.substr(i + 1)}`;\n            i += placeholder.length - 1;\n          }\n        }\n      } else if (char === \"'\" || char === '\"') {\n        currentQuoteChar = char;\n      }\n    }\n  }\n  return result;\n}\nfunction unescapeInStrings(input) {\n  let result = input.replace(_cssCommaInPlaceholderReGlobal, ',');\n  result = result.replace(_cssSemiInPlaceholderReGlobal, ';');\n  result = result.replace(_cssColonInPlaceholderReGlobal, ':');\n  return result;\n}\nfunction unescapeQuotes(str, isQuoted) {\n  return !isQuoted ? str : str.replace(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?=['\"])/g, '$1');\n}\nfunction _combineHostContextSelectors(contextSelectors, otherSelectors, pseudoPrefix = '') {\n  const hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0;\n  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n  const combined = [contextSelectors.pop() || ''];\n  while (contextSelectors.length > 0) {\n    const length = combined.length;\n    const contextSelector = contextSelectors.pop();\n    for (let i = 0; i < length; i++) {\n      const previousSelectors = combined[i];\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n      combined[length + i] = contextSelector + ' ' + previousSelectors;\n      combined[i] = contextSelector + previousSelectors;\n    }\n  }\n  return combined.map(s => otherSelectorsHasHost ? `${pseudoPrefix}${s}${otherSelectors}` : `${pseudoPrefix}${s}${hostMarker}${otherSelectors}, ${pseudoPrefix}${s} ${hostMarker}${otherSelectors}`).join(',');\n}\nfunction repeatGroups(groups, multiples) {\n  const length = groups.length;\n  for (let i = 1; i < multiples; i++) {\n    for (let j = 0; j < length; j++) {\n      groups[j + i * length] = groups[j].slice(0);\n    }\n  }\n}\nvar OpKind = /*#__PURE__*/function (OpKind) {\n  OpKind[OpKind[\"ListEnd\"] = 0] = \"ListEnd\";\n  OpKind[OpKind[\"Statement\"] = 1] = \"Statement\";\n  OpKind[OpKind[\"Variable\"] = 2] = \"Variable\";\n  OpKind[OpKind[\"ElementStart\"] = 3] = \"ElementStart\";\n  OpKind[OpKind[\"Element\"] = 4] = \"Element\";\n  OpKind[OpKind[\"Template\"] = 5] = \"Template\";\n  OpKind[OpKind[\"ElementEnd\"] = 6] = \"ElementEnd\";\n  OpKind[OpKind[\"ContainerStart\"] = 7] = \"ContainerStart\";\n  OpKind[OpKind[\"Container\"] = 8] = \"Container\";\n  OpKind[OpKind[\"ContainerEnd\"] = 9] = \"ContainerEnd\";\n  OpKind[OpKind[\"DisableBindings\"] = 10] = \"DisableBindings\";\n  OpKind[OpKind[\"ConditionalCreate\"] = 11] = \"ConditionalCreate\";\n  OpKind[OpKind[\"ConditionalBranchCreate\"] = 12] = \"ConditionalBranchCreate\";\n  OpKind[OpKind[\"Conditional\"] = 13] = \"Conditional\";\n  OpKind[OpKind[\"EnableBindings\"] = 14] = \"EnableBindings\";\n  OpKind[OpKind[\"Text\"] = 15] = \"Text\";\n  OpKind[OpKind[\"Listener\"] = 16] = \"Listener\";\n  OpKind[OpKind[\"InterpolateText\"] = 17] = \"InterpolateText\";\n  OpKind[OpKind[\"Binding\"] = 18] = \"Binding\";\n  OpKind[OpKind[\"Property\"] = 19] = \"Property\";\n  OpKind[OpKind[\"StyleProp\"] = 20] = \"StyleProp\";\n  OpKind[OpKind[\"ClassProp\"] = 21] = \"ClassProp\";\n  OpKind[OpKind[\"StyleMap\"] = 22] = \"StyleMap\";\n  OpKind[OpKind[\"ClassMap\"] = 23] = \"ClassMap\";\n  OpKind[OpKind[\"Advance\"] = 24] = \"Advance\";\n  OpKind[OpKind[\"Pipe\"] = 25] = \"Pipe\";\n  OpKind[OpKind[\"Attribute\"] = 26] = \"Attribute\";\n  OpKind[OpKind[\"ExtractedAttribute\"] = 27] = \"ExtractedAttribute\";\n  OpKind[OpKind[\"Defer\"] = 28] = \"Defer\";\n  OpKind[OpKind[\"DeferOn\"] = 29] = \"DeferOn\";\n  OpKind[OpKind[\"DeferWhen\"] = 30] = \"DeferWhen\";\n  OpKind[OpKind[\"I18nMessage\"] = 31] = \"I18nMessage\";\n  OpKind[OpKind[\"DomProperty\"] = 32] = \"DomProperty\";\n  OpKind[OpKind[\"Namespace\"] = 33] = \"Namespace\";\n  OpKind[OpKind[\"ProjectionDef\"] = 34] = \"ProjectionDef\";\n  OpKind[OpKind[\"Projection\"] = 35] = \"Projection\";\n  OpKind[OpKind[\"RepeaterCreate\"] = 36] = \"RepeaterCreate\";\n  OpKind[OpKind[\"Repeater\"] = 37] = \"Repeater\";\n  OpKind[OpKind[\"TwoWayProperty\"] = 38] = \"TwoWayProperty\";\n  OpKind[OpKind[\"TwoWayListener\"] = 39] = \"TwoWayListener\";\n  OpKind[OpKind[\"DeclareLet\"] = 40] = \"DeclareLet\";\n  OpKind[OpKind[\"StoreLet\"] = 41] = \"StoreLet\";\n  OpKind[OpKind[\"I18nStart\"] = 42] = \"I18nStart\";\n  OpKind[OpKind[\"I18n\"] = 43] = \"I18n\";\n  OpKind[OpKind[\"I18nEnd\"] = 44] = \"I18nEnd\";\n  OpKind[OpKind[\"I18nExpression\"] = 45] = \"I18nExpression\";\n  OpKind[OpKind[\"I18nApply\"] = 46] = \"I18nApply\";\n  OpKind[OpKind[\"IcuStart\"] = 47] = \"IcuStart\";\n  OpKind[OpKind[\"IcuEnd\"] = 48] = \"IcuEnd\";\n  OpKind[OpKind[\"IcuPlaceholder\"] = 49] = \"IcuPlaceholder\";\n  OpKind[OpKind[\"I18nContext\"] = 50] = \"I18nContext\";\n  OpKind[OpKind[\"I18nAttributes\"] = 51] = \"I18nAttributes\";\n  OpKind[OpKind[\"SourceLocation\"] = 52] = \"SourceLocation\";\n  OpKind[OpKind[\"Animation\"] = 53] = \"Animation\";\n  OpKind[OpKind[\"AnimationString\"] = 54] = \"AnimationString\";\n  OpKind[OpKind[\"AnimationBinding\"] = 55] = \"AnimationBinding\";\n  OpKind[OpKind[\"AnimationListener\"] = 56] = \"AnimationListener\";\n  OpKind[OpKind[\"Control\"] = 57] = \"Control\";\n  OpKind[OpKind[\"ControlCreate\"] = 58] = \"ControlCreate\";\n  return OpKind;\n}(OpKind || {});\nvar ExpressionKind = /*#__PURE__*/function (ExpressionKind) {\n  ExpressionKind[ExpressionKind[\"LexicalRead\"] = 0] = \"LexicalRead\";\n  ExpressionKind[ExpressionKind[\"Context\"] = 1] = \"Context\";\n  ExpressionKind[ExpressionKind[\"TrackContext\"] = 2] = \"TrackContext\";\n  ExpressionKind[ExpressionKind[\"ReadVariable\"] = 3] = \"ReadVariable\";\n  ExpressionKind[ExpressionKind[\"NextContext\"] = 4] = \"NextContext\";\n  ExpressionKind[ExpressionKind[\"Reference\"] = 5] = \"Reference\";\n  ExpressionKind[ExpressionKind[\"StoreLet\"] = 6] = \"StoreLet\";\n  ExpressionKind[ExpressionKind[\"ContextLetReference\"] = 7] = \"ContextLetReference\";\n  ExpressionKind[ExpressionKind[\"GetCurrentView\"] = 8] = \"GetCurrentView\";\n  ExpressionKind[ExpressionKind[\"RestoreView\"] = 9] = \"RestoreView\";\n  ExpressionKind[ExpressionKind[\"ResetView\"] = 10] = \"ResetView\";\n  ExpressionKind[ExpressionKind[\"PureFunctionExpr\"] = 11] = \"PureFunctionExpr\";\n  ExpressionKind[ExpressionKind[\"PureFunctionParameterExpr\"] = 12] = \"PureFunctionParameterExpr\";\n  ExpressionKind[ExpressionKind[\"PipeBinding\"] = 13] = \"PipeBinding\";\n  ExpressionKind[ExpressionKind[\"PipeBindingVariadic\"] = 14] = \"PipeBindingVariadic\";\n  ExpressionKind[ExpressionKind[\"SafePropertyRead\"] = 15] = \"SafePropertyRead\";\n  ExpressionKind[ExpressionKind[\"SafeKeyedRead\"] = 16] = \"SafeKeyedRead\";\n  ExpressionKind[ExpressionKind[\"SafeInvokeFunction\"] = 17] = \"SafeInvokeFunction\";\n  ExpressionKind[ExpressionKind[\"SafeTernaryExpr\"] = 18] = \"SafeTernaryExpr\";\n  ExpressionKind[ExpressionKind[\"EmptyExpr\"] = 19] = \"EmptyExpr\";\n  ExpressionKind[ExpressionKind[\"AssignTemporaryExpr\"] = 20] = \"AssignTemporaryExpr\";\n  ExpressionKind[ExpressionKind[\"ReadTemporaryExpr\"] = 21] = \"ReadTemporaryExpr\";\n  ExpressionKind[ExpressionKind[\"SlotLiteralExpr\"] = 22] = \"SlotLiteralExpr\";\n  ExpressionKind[ExpressionKind[\"ConditionalCase\"] = 23] = \"ConditionalCase\";\n  ExpressionKind[ExpressionKind[\"ConstCollected\"] = 24] = \"ConstCollected\";\n  ExpressionKind[ExpressionKind[\"TwoWayBindingSet\"] = 25] = \"TwoWayBindingSet\";\n  return ExpressionKind;\n}(ExpressionKind || {});\nvar VariableFlags = /*#__PURE__*/function (VariableFlags) {\n  VariableFlags[VariableFlags[\"None\"] = 0] = \"None\";\n  VariableFlags[VariableFlags[\"AlwaysInline\"] = 1] = \"AlwaysInline\";\n  return VariableFlags;\n}(VariableFlags || {});\nvar SemanticVariableKind = /*#__PURE__*/function (SemanticVariableKind) {\n  SemanticVariableKind[SemanticVariableKind[\"Context\"] = 0] = \"Context\";\n  SemanticVariableKind[SemanticVariableKind[\"Identifier\"] = 1] = \"Identifier\";\n  SemanticVariableKind[SemanticVariableKind[\"SavedView\"] = 2] = \"SavedView\";\n  SemanticVariableKind[SemanticVariableKind[\"Alias\"] = 3] = \"Alias\";\n  return SemanticVariableKind;\n}(SemanticVariableKind || {});\nvar CompatibilityMode = /*#__PURE__*/function (CompatibilityMode) {\n  CompatibilityMode[CompatibilityMode[\"Normal\"] = 0] = \"Normal\";\n  CompatibilityMode[CompatibilityMode[\"TemplateDefinitionBuilder\"] = 1] = \"TemplateDefinitionBuilder\";\n  return CompatibilityMode;\n}(CompatibilityMode || {});\nvar BindingKind = /*#__PURE__*/function (BindingKind) {\n  BindingKind[BindingKind[\"Attribute\"] = 0] = \"Attribute\";\n  BindingKind[BindingKind[\"ClassName\"] = 1] = \"ClassName\";\n  BindingKind[BindingKind[\"StyleProperty\"] = 2] = \"StyleProperty\";\n  BindingKind[BindingKind[\"Property\"] = 3] = \"Property\";\n  BindingKind[BindingKind[\"Template\"] = 4] = \"Template\";\n  BindingKind[BindingKind[\"I18n\"] = 5] = \"I18n\";\n  BindingKind[BindingKind[\"LegacyAnimation\"] = 6] = \"LegacyAnimation\";\n  BindingKind[BindingKind[\"TwoWayProperty\"] = 7] = \"TwoWayProperty\";\n  BindingKind[BindingKind[\"Animation\"] = 8] = \"Animation\";\n  return BindingKind;\n}(BindingKind || {});\nvar I18nParamResolutionTime = /*#__PURE__*/function (I18nParamResolutionTime) {\n  I18nParamResolutionTime[I18nParamResolutionTime[\"Creation\"] = 0] = \"Creation\";\n  I18nParamResolutionTime[I18nParamResolutionTime[\"Postproccessing\"] = 1] = \"Postproccessing\";\n  return I18nParamResolutionTime;\n}(I18nParamResolutionTime || {});\nvar I18nExpressionFor = /*#__PURE__*/function (I18nExpressionFor) {\n  I18nExpressionFor[I18nExpressionFor[\"I18nText\"] = 0] = \"I18nText\";\n  I18nExpressionFor[I18nExpressionFor[\"I18nAttribute\"] = 1] = \"I18nAttribute\";\n  return I18nExpressionFor;\n}(I18nExpressionFor || {});\nvar I18nParamValueFlags = /*#__PURE__*/function (I18nParamValueFlags) {\n  I18nParamValueFlags[I18nParamValueFlags[\"None\"] = 0] = \"None\";\n  I18nParamValueFlags[I18nParamValueFlags[\"ElementTag\"] = 1] = \"ElementTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"TemplateTag\"] = 2] = \"TemplateTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"OpenTag\"] = 4] = \"OpenTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"CloseTag\"] = 8] = \"CloseTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"ExpressionIndex\"] = 16] = \"ExpressionIndex\";\n  return I18nParamValueFlags;\n}(I18nParamValueFlags || {});\nvar Namespace = /*#__PURE__*/function (Namespace) {\n  Namespace[Namespace[\"HTML\"] = 0] = \"HTML\";\n  Namespace[Namespace[\"SVG\"] = 1] = \"SVG\";\n  Namespace[Namespace[\"Math\"] = 2] = \"Math\";\n  return Namespace;\n}(Namespace || {});\nvar DeferTriggerKind = /*#__PURE__*/function (DeferTriggerKind) {\n  DeferTriggerKind[DeferTriggerKind[\"Idle\"] = 0] = \"Idle\";\n  DeferTriggerKind[DeferTriggerKind[\"Immediate\"] = 1] = \"Immediate\";\n  DeferTriggerKind[DeferTriggerKind[\"Timer\"] = 2] = \"Timer\";\n  DeferTriggerKind[DeferTriggerKind[\"Hover\"] = 3] = \"Hover\";\n  DeferTriggerKind[DeferTriggerKind[\"Interaction\"] = 4] = \"Interaction\";\n  DeferTriggerKind[DeferTriggerKind[\"Viewport\"] = 5] = \"Viewport\";\n  DeferTriggerKind[DeferTriggerKind[\"Never\"] = 6] = \"Never\";\n  return DeferTriggerKind;\n}(DeferTriggerKind || {});\nvar I18nContextKind = /*#__PURE__*/function (I18nContextKind) {\n  I18nContextKind[I18nContextKind[\"RootI18n\"] = 0] = \"RootI18n\";\n  I18nContextKind[I18nContextKind[\"Icu\"] = 1] = \"Icu\";\n  I18nContextKind[I18nContextKind[\"Attr\"] = 2] = \"Attr\";\n  return I18nContextKind;\n}(I18nContextKind || {});\nvar TemplateKind = /*#__PURE__*/function (TemplateKind) {\n  TemplateKind[TemplateKind[\"NgTemplate\"] = 0] = \"NgTemplate\";\n  TemplateKind[TemplateKind[\"Structural\"] = 1] = \"Structural\";\n  TemplateKind[TemplateKind[\"Block\"] = 2] = \"Block\";\n  return TemplateKind;\n}(TemplateKind || {});\nconst ConsumesSlot = Symbol('ConsumesSlot');\nconst DependsOnSlotContext = Symbol('DependsOnSlotContext');\nconst ConsumesVarsTrait = Symbol('ConsumesVars');\nconst UsesVarOffset = Symbol('UsesVarOffset');\nconst TRAIT_CONSUMES_SLOT = {\n  [ConsumesSlot]: true,\n  numSlotsUsed: 1\n};\nconst TRAIT_DEPENDS_ON_SLOT_CONTEXT = {\n  [DependsOnSlotContext]: true\n};\nconst TRAIT_CONSUMES_VARS = {\n  [ConsumesVarsTrait]: true\n};\nfunction hasConsumesSlotTrait(op) {\n  return op[ConsumesSlot] === true;\n}\nfunction hasDependsOnSlotContextTrait(value) {\n  return value[DependsOnSlotContext] === true;\n}\nfunction hasConsumesVarsTrait(value) {\n  return value[ConsumesVarsTrait] === true;\n}\nfunction hasUsesVarOffsetTrait(expr) {\n  return expr[UsesVarOffset] === true;\n}\nfunction createStatementOp(statement) {\n  return {\n    kind: OpKind.Statement,\n    statement,\n    ...NEW_OP\n  };\n}\nfunction createVariableOp(xref, variable, initializer, flags) {\n  return {\n    kind: OpKind.Variable,\n    xref,\n    variable,\n    initializer,\n    flags,\n    ...NEW_OP\n  };\n}\nconst NEW_OP = {\n  debugListId: null,\n  prev: null,\n  next: null\n};\nfunction createInterpolateTextOp(xref, interpolation, sourceSpan) {\n  return {\n    kind: OpKind.InterpolateText,\n    target: xref,\n    interpolation,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nclass Interpolation {\n  strings;\n  expressions;\n  i18nPlaceholders;\n  constructor(strings, expressions, i18nPlaceholders) {\n    this.strings = strings;\n    this.expressions = expressions;\n    this.i18nPlaceholders = i18nPlaceholders;\n    if (i18nPlaceholders.length !== 0 && i18nPlaceholders.length !== expressions.length) {\n      throw new Error(`Expected ${expressions.length} placeholders to match interpolation expression count, but got ${i18nPlaceholders.length}`);\n    }\n  }\n}\nfunction createBindingOp(target, kind, name, expression, unit, securityContext, isTextAttribute, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Binding,\n    bindingKind: kind,\n    target,\n    name,\n    expression,\n    unit,\n    securityContext,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createPropertyOp(target, name, expression, bindingKind, securityContext, isStructuralTemplateAttribute, templateKind, i18nContext, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Property,\n    target,\n    name,\n    expression,\n    bindingKind,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createTwoWayPropertyOp(target, name, expression, securityContext, isStructuralTemplateAttribute, templateKind, i18nContext, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.TwoWayProperty,\n    target,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createStylePropOp(xref, name, expression, unit, sourceSpan) {\n  return {\n    kind: OpKind.StyleProp,\n    target: xref,\n    name,\n    expression,\n    unit,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createClassPropOp(xref, name, expression, sourceSpan) {\n  return {\n    kind: OpKind.ClassProp,\n    target: xref,\n    name,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createStyleMapOp(xref, expression, sourceSpan) {\n  return {\n    kind: OpKind.StyleMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createClassMapOp(xref, expression, sourceSpan) {\n  return {\n    kind: OpKind.ClassMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createAttributeOp(target, namespace, name, expression, securityContext, isTextAttribute, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Attribute,\n    target,\n    namespace,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createAdvanceOp(delta, sourceSpan) {\n  return {\n    kind: OpKind.Advance,\n    delta,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createConditionalOp(target, test, conditions, sourceSpan) {\n  return {\n    kind: OpKind.Conditional,\n    target,\n    test,\n    conditions,\n    processed: null,\n    sourceSpan,\n    contextValue: null,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS\n  };\n}\nfunction createRepeaterOp(repeaterCreate, targetSlot, collection, sourceSpan) {\n  return {\n    kind: OpKind.Repeater,\n    target: repeaterCreate,\n    targetSlot,\n    collection,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT\n  };\n}\nfunction createAnimationBindingOp(name, target, animationKind, expression, securityContext, sourceSpan, animationBindingKind) {\n  return {\n    kind: OpKind.AnimationBinding,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    animationBindingKind,\n    ...NEW_OP\n  };\n}\nfunction createDeferWhenOp(target, expr, modifier, sourceSpan) {\n  return {\n    kind: OpKind.DeferWhen,\n    target,\n    expr,\n    modifier,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS\n  };\n}\nfunction createI18nExpressionOp(context, target, i18nOwner, handle, expression, icuPlaceholder, i18nPlaceholder, resolutionTime, usage, name, sourceSpan) {\n  return {\n    kind: OpKind.I18nExpression,\n    context,\n    target,\n    i18nOwner,\n    handle,\n    expression,\n    icuPlaceholder,\n    i18nPlaceholder,\n    resolutionTime,\n    usage,\n    name,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT\n  };\n}\nfunction createI18nApplyOp(owner, handle, sourceSpan) {\n  return {\n    kind: OpKind.I18nApply,\n    owner,\n    handle,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createStoreLetOp(target, declaredName, value, sourceSpan) {\n  return {\n    kind: OpKind.StoreLet,\n    target,\n    declaredName,\n    value,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createControlOp(op) {\n  return {\n    kind: OpKind.Control,\n    target: op.target,\n    expression: op.expression,\n    bindingKind: op.bindingKind,\n    securityContext: op.securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute: op.isStructuralTemplateAttribute,\n    templateKind: op.templateKind,\n    i18nContext: op.i18nContext,\n    i18nMessage: op.i18nMessage,\n    sourceSpan: op.sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction isIrExpression(expr) {\n  return expr instanceof ExpressionBase;\n}\nclass ExpressionBase extends Expression {\n  constructor(sourceSpan = null) {\n    super(null, sourceSpan);\n  }\n}\nclass LexicalReadExpr extends ExpressionBase {\n  name;\n  kind = ExpressionKind.LexicalRead;\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent(other) {\n    return this.name === other.name;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new LexicalReadExpr(this.name);\n  }\n}\nclass ReferenceExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  offset;\n  kind = ExpressionKind.Reference;\n  constructor(target, targetSlot, offset) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.offset = offset;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ReferenceExpr && e.target === this.target;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ReferenceExpr(this.target, this.targetSlot, this.offset);\n  }\n}\nclass StoreLetExpr extends ExpressionBase {\n  target;\n  value;\n  sourceSpan;\n  kind = ExpressionKind.StoreLet;\n  [ConsumesVarsTrait] = true;\n  [DependsOnSlotContext] = true;\n  constructor(target, value, sourceSpan) {\n    super();\n    this.target = target;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof StoreLetExpr && e.target === this.target && e.value.isEquivalent(this.value);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n  clone() {\n    return new StoreLetExpr(this.target, this.value, this.sourceSpan);\n  }\n}\nclass ContextLetReferenceExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  kind = ExpressionKind.ContextLetReference;\n  constructor(target, targetSlot) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ContextLetReferenceExpr && e.target === this.target;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ContextLetReferenceExpr(this.target, this.targetSlot);\n  }\n}\nclass ContextExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.Context;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ContextExpr && e.view === this.view;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ContextExpr(this.view);\n  }\n}\nclass TrackContextExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.TrackContext;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof TrackContextExpr && e.view === this.view;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new TrackContextExpr(this.view);\n  }\n}\nclass NextContextExpr extends ExpressionBase {\n  kind = ExpressionKind.NextContext;\n  steps = 1;\n  constructor() {\n    super();\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof NextContextExpr && e.steps === this.steps;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    const expr = new NextContextExpr();\n    expr.steps = this.steps;\n    return expr;\n  }\n}\nclass GetCurrentViewExpr extends ExpressionBase {\n  kind = ExpressionKind.GetCurrentView;\n  constructor() {\n    super();\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof GetCurrentViewExpr;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new GetCurrentViewExpr();\n  }\n}\nclass RestoreViewExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.RestoreView;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression(visitor, context) {\n    if (typeof this.view !== 'number') {\n      this.view.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    if (!(e instanceof RestoreViewExpr) || typeof e.view !== typeof this.view) {\n      return false;\n    }\n    if (typeof this.view === 'number') {\n      return this.view === e.view;\n    } else {\n      return this.view.isEquivalent(e.view);\n    }\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    if (typeof this.view !== 'number') {\n      this.view = transformExpressionsInExpression(this.view, transform, flags);\n    }\n  }\n  clone() {\n    return new RestoreViewExpr(this.view instanceof Expression ? this.view.clone() : this.view);\n  }\n}\nclass ResetViewExpr extends ExpressionBase {\n  expr;\n  kind = ExpressionKind.ResetView;\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent(e) {\n    return e instanceof ResetViewExpr && this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    return new ResetViewExpr(this.expr.clone());\n  }\n}\nclass TwoWayBindingSetExpr extends ExpressionBase {\n  target;\n  value;\n  kind = ExpressionKind.TwoWayBindingSet;\n  constructor(target, value) {\n    super();\n    this.target = target;\n    this.value = value;\n  }\n  visitExpression(visitor, context) {\n    this.target.visitExpression(visitor, context);\n    this.value.visitExpression(visitor, context);\n  }\n  isEquivalent(other) {\n    return this.target.isEquivalent(other.target) && this.value.isEquivalent(other.value);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.target = transformExpressionsInExpression(this.target, transform, flags);\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n  clone() {\n    return new TwoWayBindingSetExpr(this.target, this.value);\n  }\n}\nclass ReadVariableExpr extends ExpressionBase {\n  xref;\n  kind = ExpressionKind.ReadVariable;\n  name = null;\n  constructor(xref) {\n    super();\n    this.xref = xref;\n  }\n  visitExpression() {}\n  isEquivalent(other) {\n    return other instanceof ReadVariableExpr && other.xref === this.xref;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    const expr = new ReadVariableExpr(this.xref);\n    expr.name = this.name;\n    return expr;\n  }\n}\nclass PureFunctionExpr extends ExpressionBase {\n  kind = ExpressionKind.PureFunctionExpr;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  body;\n  args;\n  fn = null;\n  constructor(expression, args) {\n    super();\n    this.body = expression;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    this.body?.visitExpression(visitor, context);\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(other) {\n    if (!(other instanceof PureFunctionExpr) || other.args.length !== this.args.length) {\n      return false;\n    }\n    return other.body !== null && this.body !== null && other.body.isEquivalent(this.body) && other.args.every((arg, idx) => arg.isEquivalent(this.args[idx]));\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    if (this.body !== null) {\n      this.body = transformExpressionsInExpression(this.body, transform, flags | VisitorContextFlag.InChildOperation);\n    } else if (this.fn !== null) {\n      this.fn = transformExpressionsInExpression(this.fn, transform, flags);\n    }\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n  clone() {\n    const expr = new PureFunctionExpr(this.body?.clone() ?? null, this.args.map(arg => arg.clone()));\n    expr.fn = this.fn?.clone() ?? null;\n    expr.varOffset = this.varOffset;\n    return expr;\n  }\n}\nclass PureFunctionParameterExpr extends ExpressionBase {\n  index;\n  kind = ExpressionKind.PureFunctionParameterExpr;\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n  visitExpression() {}\n  isEquivalent(other) {\n    return other instanceof PureFunctionParameterExpr && other.index === this.index;\n  }\n  isConstant() {\n    return true;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new PureFunctionParameterExpr(this.index);\n  }\n}\nclass PipeBindingExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  name;\n  args;\n  kind = ExpressionKind.PipeBinding;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  constructor(target, targetSlot, name, args) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.name = name;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    for (let idx = 0; idx < this.args.length; idx++) {\n      this.args[idx] = transformExpressionsInExpression(this.args[idx], transform, flags);\n    }\n  }\n  clone() {\n    const r = new PipeBindingExpr(this.target, this.targetSlot, this.name, this.args.map(a => a.clone()));\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\nclass PipeBindingVariadicExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  name;\n  args;\n  numArgs;\n  kind = ExpressionKind.PipeBindingVariadic;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  constructor(target, targetSlot, name, args, numArgs) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.name = name;\n    this.args = args;\n    this.numArgs = numArgs;\n  }\n  visitExpression(visitor, context) {\n    this.args.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.args = transformExpressionsInExpression(this.args, transform, flags);\n  }\n  clone() {\n    const r = new PipeBindingVariadicExpr(this.target, this.targetSlot, this.name, this.args.clone(), this.numArgs);\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\nclass SafePropertyReadExpr extends ExpressionBase {\n  receiver;\n  name;\n  kind = ExpressionKind.SafePropertyRead;\n  constructor(receiver, name) {\n    super();\n    this.receiver = receiver;\n    this.name = name;\n  }\n  get index() {\n    return this.name;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n  }\n  clone() {\n    return new SafePropertyReadExpr(this.receiver.clone(), this.name);\n  }\n}\nclass SafeKeyedReadExpr extends ExpressionBase {\n  receiver;\n  index;\n  kind = ExpressionKind.SafeKeyedRead;\n  constructor(receiver, index, sourceSpan) {\n    super(sourceSpan);\n    this.receiver = receiver;\n    this.index = index;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n    this.index.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    this.index = transformExpressionsInExpression(this.index, transform, flags);\n  }\n  clone() {\n    return new SafeKeyedReadExpr(this.receiver.clone(), this.index.clone(), this.sourceSpan);\n  }\n}\nclass SafeInvokeFunctionExpr extends ExpressionBase {\n  receiver;\n  args;\n  kind = ExpressionKind.SafeInvokeFunction;\n  constructor(receiver, args) {\n    super();\n    this.receiver = receiver;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n    for (const a of this.args) {\n      a.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n  clone() {\n    return new SafeInvokeFunctionExpr(this.receiver.clone(), this.args.map(a => a.clone()));\n  }\n}\nclass SafeTernaryExpr extends ExpressionBase {\n  guard;\n  expr;\n  kind = ExpressionKind.SafeTernaryExpr;\n  constructor(guard, expr) {\n    super();\n    this.guard = guard;\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    this.guard.visitExpression(visitor, context);\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.guard = transformExpressionsInExpression(this.guard, transform, flags);\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    return new SafeTernaryExpr(this.guard.clone(), this.expr.clone());\n  }\n}\nclass EmptyExpr extends ExpressionBase {\n  kind = ExpressionKind.EmptyExpr;\n  visitExpression(visitor, context) {}\n  isEquivalent(e) {\n    return e instanceof EmptyExpr;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new EmptyExpr();\n  }\n  transformInternalExpressions() {}\n}\nclass AssignTemporaryExpr extends ExpressionBase {\n  expr;\n  xref;\n  kind = ExpressionKind.AssignTemporaryExpr;\n  name = null;\n  constructor(expr, xref) {\n    super();\n    this.expr = expr;\n    this.xref = xref;\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    const a = new AssignTemporaryExpr(this.expr.clone(), this.xref);\n    a.name = this.name;\n    return a;\n  }\n}\nclass ReadTemporaryExpr extends ExpressionBase {\n  xref;\n  kind = ExpressionKind.ReadTemporaryExpr;\n  name = null;\n  constructor(xref) {\n    super();\n    this.xref = xref;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent() {\n    return this.xref === this.xref;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {}\n  clone() {\n    const r = new ReadTemporaryExpr(this.xref);\n    r.name = this.name;\n    return r;\n  }\n}\nclass SlotLiteralExpr extends ExpressionBase {\n  slot;\n  kind = ExpressionKind.SlotLiteralExpr;\n  constructor(slot) {\n    super();\n    this.slot = slot;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent(e) {\n    return e instanceof SlotLiteralExpr && e.slot === this.slot;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new SlotLiteralExpr(this.slot);\n  }\n  transformInternalExpressions() {}\n}\nclass ConditionalCaseExpr extends ExpressionBase {\n  expr;\n  target;\n  targetSlot;\n  alias;\n  kind = ExpressionKind.ConditionalCase;\n  constructor(expr, target, targetSlot, alias = null) {\n    super();\n    this.expr = expr;\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.alias = alias;\n  }\n  visitExpression(visitor, context) {\n    if (this.expr !== null) {\n      this.expr.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof ConditionalCaseExpr && e.expr === this.expr;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new ConditionalCaseExpr(this.expr, this.target, this.targetSlot);\n  }\n  transformInternalExpressions(transform, flags) {\n    if (this.expr !== null) {\n      this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n    }\n  }\n}\nclass ConstCollectedExpr extends ExpressionBase {\n  expr;\n  kind = ExpressionKind.ConstCollected;\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transform(this.expr, flags);\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent(e) {\n    if (!(e instanceof ConstCollectedExpr)) {\n      return false;\n    }\n    return this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new ConstCollectedExpr(this.expr);\n  }\n}\nfunction visitExpressionsInOp(op, visitor) {\n  transformExpressionsInOp(op, (expr, flags) => {\n    visitor(expr, flags);\n    return expr;\n  }, VisitorContextFlag.None);\n}\nvar VisitorContextFlag = /*#__PURE__*/function (VisitorContextFlag) {\n  VisitorContextFlag[VisitorContextFlag[\"None\"] = 0] = \"None\";\n  VisitorContextFlag[VisitorContextFlag[\"InChildOperation\"] = 1] = \"InChildOperation\";\n  return VisitorContextFlag;\n}(VisitorContextFlag || {});\nfunction transformExpressionsInInterpolation(interpolation, transform, flags) {\n  for (let i = 0; i < interpolation.expressions.length; i++) {\n    interpolation.expressions[i] = transformExpressionsInExpression(interpolation.expressions[i], transform, flags);\n  }\n}\nfunction transformExpressionsInOp(op, transform, flags) {\n  switch (op.kind) {\n    case OpKind.StyleProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassProp:\n    case OpKind.ClassMap:\n    case OpKind.AnimationString:\n    case OpKind.AnimationBinding:\n    case OpKind.Binding:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      break;\n    case OpKind.Property:\n    case OpKind.DomProperty:\n    case OpKind.Attribute:\n    case OpKind.Control:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      op.sanitizer = op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.TwoWayProperty:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      op.sanitizer = op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.I18nExpression:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      break;\n    case OpKind.InterpolateText:\n      transformExpressionsInInterpolation(op.interpolation, transform, flags);\n      break;\n    case OpKind.Statement:\n      transformExpressionsInStatement(op.statement, transform, flags);\n      break;\n    case OpKind.Variable:\n      op.initializer = transformExpressionsInExpression(op.initializer, transform, flags);\n      break;\n    case OpKind.Conditional:\n      for (const condition of op.conditions) {\n        if (condition.expr === null) {\n          continue;\n        }\n        condition.expr = transformExpressionsInExpression(condition.expr, transform, flags);\n      }\n      if (op.processed !== null) {\n        op.processed = transformExpressionsInExpression(op.processed, transform, flags);\n      }\n      if (op.contextValue !== null) {\n        op.contextValue = transformExpressionsInExpression(op.contextValue, transform, flags);\n      }\n      break;\n    case OpKind.Animation:\n    case OpKind.AnimationListener:\n    case OpKind.Listener:\n    case OpKind.TwoWayListener:\n      for (const innerOp of op.handlerOps) {\n        transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n      }\n      break;\n    case OpKind.ExtractedAttribute:\n      op.expression = op.expression && transformExpressionsInExpression(op.expression, transform, flags);\n      op.trustedValueFn = op.trustedValueFn && transformExpressionsInExpression(op.trustedValueFn, transform, flags);\n      break;\n    case OpKind.RepeaterCreate:\n      if (op.trackByOps === null) {\n        op.track = transformExpressionsInExpression(op.track, transform, flags);\n      } else {\n        for (const innerOp of op.trackByOps) {\n          transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n        }\n      }\n      if (op.trackByFn !== null) {\n        op.trackByFn = transformExpressionsInExpression(op.trackByFn, transform, flags);\n      }\n      break;\n    case OpKind.Repeater:\n      op.collection = transformExpressionsInExpression(op.collection, transform, flags);\n      break;\n    case OpKind.Defer:\n      if (op.loadingConfig !== null) {\n        op.loadingConfig = transformExpressionsInExpression(op.loadingConfig, transform, flags);\n      }\n      if (op.placeholderConfig !== null) {\n        op.placeholderConfig = transformExpressionsInExpression(op.placeholderConfig, transform, flags);\n      }\n      if (op.resolverFn !== null) {\n        op.resolverFn = transformExpressionsInExpression(op.resolverFn, transform, flags);\n      }\n      break;\n    case OpKind.I18nMessage:\n      for (const [placeholder, expr] of op.params) {\n        op.params.set(placeholder, transformExpressionsInExpression(expr, transform, flags));\n      }\n      for (const [placeholder, expr] of op.postprocessingParams) {\n        op.postprocessingParams.set(placeholder, transformExpressionsInExpression(expr, transform, flags));\n      }\n      break;\n    case OpKind.DeferWhen:\n      op.expr = transformExpressionsInExpression(op.expr, transform, flags);\n      break;\n    case OpKind.StoreLet:\n      op.value = transformExpressionsInExpression(op.value, transform, flags);\n      break;\n    case OpKind.Advance:\n    case OpKind.Container:\n    case OpKind.ContainerEnd:\n    case OpKind.ContainerStart:\n    case OpKind.DeferOn:\n    case OpKind.DisableBindings:\n    case OpKind.Element:\n    case OpKind.ElementEnd:\n    case OpKind.ElementStart:\n    case OpKind.EnableBindings:\n    case OpKind.I18n:\n    case OpKind.I18nApply:\n    case OpKind.I18nContext:\n    case OpKind.I18nEnd:\n    case OpKind.I18nStart:\n    case OpKind.IcuEnd:\n    case OpKind.IcuStart:\n    case OpKind.Namespace:\n    case OpKind.Pipe:\n    case OpKind.Projection:\n    case OpKind.ProjectionDef:\n    case OpKind.Template:\n    case OpKind.Text:\n    case OpKind.I18nAttributes:\n    case OpKind.IcuPlaceholder:\n    case OpKind.DeclareLet:\n    case OpKind.SourceLocation:\n    case OpKind.ConditionalCreate:\n    case OpKind.ConditionalBranchCreate:\n    case OpKind.ControlCreate:\n      break;\n    default:\n      throw new Error(`AssertionError: transformExpressionsInOp doesn't handle ${OpKind[op.kind]}`);\n  }\n}\nfunction transformExpressionsInExpression(expr, transform, flags) {\n  if (expr instanceof ExpressionBase) {\n    expr.transformInternalExpressions(transform, flags);\n  } else if (expr instanceof BinaryOperatorExpr) {\n    expr.lhs = transformExpressionsInExpression(expr.lhs, transform, flags);\n    expr.rhs = transformExpressionsInExpression(expr.rhs, transform, flags);\n  } else if (expr instanceof UnaryOperatorExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof ReadPropExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n  } else if (expr instanceof ReadKeyExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n    expr.index = transformExpressionsInExpression(expr.index, transform, flags);\n  } else if (expr instanceof InvokeFunctionExpr) {\n    expr.fn = transformExpressionsInExpression(expr.fn, transform, flags);\n    for (let i = 0; i < expr.args.length; i++) {\n      expr.args[i] = transformExpressionsInExpression(expr.args[i], transform, flags);\n    }\n  } else if (expr instanceof LiteralArrayExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i] = transformExpressionsInExpression(expr.entries[i], transform, flags);\n    }\n  } else if (expr instanceof LiteralMapExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i].value = transformExpressionsInExpression(expr.entries[i].value, transform, flags);\n    }\n  } else if (expr instanceof ConditionalExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n    expr.trueCase = transformExpressionsInExpression(expr.trueCase, transform, flags);\n    if (expr.falseCase !== null) {\n      expr.falseCase = transformExpressionsInExpression(expr.falseCase, transform, flags);\n    }\n  } else if (expr instanceof TypeofExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof VoidExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof LocalizedString) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof NotExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n  } else if (expr instanceof TaggedTemplateLiteralExpr) {\n    expr.tag = transformExpressionsInExpression(expr.tag, transform, flags);\n    expr.template.expressions = expr.template.expressions.map(e => transformExpressionsInExpression(e, transform, flags));\n  } else if (expr instanceof ArrowFunctionExpr) {\n    if (Array.isArray(expr.body)) {\n      for (let i = 0; i < expr.body.length; i++) {\n        transformExpressionsInStatement(expr.body[i], transform, flags);\n      }\n    } else {\n      expr.body = transformExpressionsInExpression(expr.body, transform, flags);\n    }\n  } else if (expr instanceof WrappedNodeExpr) ;else if (expr instanceof TemplateLiteralExpr) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof ParenthesizedExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof ReadVarExpr || expr instanceof ExternalExpr || expr instanceof LiteralExpr || expr instanceof RegularExpressionLiteralExpr) ;else {\n    throw new Error(`Unhandled expression kind: ${expr.constructor.name}`);\n  }\n  return transform(expr, flags);\n}\nfunction transformExpressionsInStatement(stmt, transform, flags) {\n  if (stmt instanceof ExpressionStatement) {\n    stmt.expr = transformExpressionsInExpression(stmt.expr, transform, flags);\n  } else if (stmt instanceof ReturnStatement) {\n    stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n  } else if (stmt instanceof DeclareVarStmt) {\n    if (stmt.value !== undefined) {\n      stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n    }\n  } else if (stmt instanceof IfStmt) {\n    stmt.condition = transformExpressionsInExpression(stmt.condition, transform, flags);\n    for (const caseStatement of stmt.trueCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n    for (const caseStatement of stmt.falseCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n  } else {\n    throw new Error(`Unhandled statement kind: ${stmt.constructor.name}`);\n  }\n}\nfunction isStringLiteral(expr) {\n  return expr instanceof LiteralExpr && typeof expr.value === 'string';\n}\nlet OpList = /*#__PURE__*/(() => {\n  class OpList {\n    static nextListId = 0;\n    debugListId = OpList.nextListId++;\n    head = {\n      kind: OpKind.ListEnd,\n      next: null,\n      prev: null,\n      debugListId: this.debugListId\n    };\n    tail = {\n      kind: OpKind.ListEnd,\n      next: null,\n      prev: null,\n      debugListId: this.debugListId\n    };\n    constructor() {\n      this.head.next = this.tail;\n      this.tail.prev = this.head;\n    }\n    push(op) {\n      if (Array.isArray(op)) {\n        for (const o of op) {\n          this.push(o);\n        }\n        return;\n      }\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n      op.debugListId = this.debugListId;\n      const oldLast = this.tail.prev;\n      op.prev = oldLast;\n      oldLast.next = op;\n      op.next = this.tail;\n      this.tail.prev = op;\n    }\n    prepend(ops) {\n      if (ops.length === 0) {\n        return;\n      }\n      for (const op of ops) {\n        OpList.assertIsNotEnd(op);\n        OpList.assertIsUnowned(op);\n        op.debugListId = this.debugListId;\n      }\n      const first = this.head.next;\n      let prev = this.head;\n      for (const op of ops) {\n        prev.next = op;\n        op.prev = prev;\n        prev = op;\n      }\n      prev.next = first;\n      first.prev = prev;\n    }\n    *[Symbol.iterator]() {\n      let current = this.head.next;\n      while (current !== this.tail) {\n        OpList.assertIsOwned(current, this.debugListId);\n        const next = current.next;\n        yield current;\n        current = next;\n      }\n    }\n    *reversed() {\n      let current = this.tail.prev;\n      while (current !== this.head) {\n        OpList.assertIsOwned(current, this.debugListId);\n        const prev = current.prev;\n        yield current;\n        current = prev;\n      }\n    }\n    static replace(oldOp, newOp) {\n      OpList.assertIsNotEnd(oldOp);\n      OpList.assertIsNotEnd(newOp);\n      OpList.assertIsOwned(oldOp);\n      OpList.assertIsUnowned(newOp);\n      newOp.debugListId = oldOp.debugListId;\n      if (oldOp.prev !== null) {\n        oldOp.prev.next = newOp;\n        newOp.prev = oldOp.prev;\n      }\n      if (oldOp.next !== null) {\n        oldOp.next.prev = newOp;\n        newOp.next = oldOp.next;\n      }\n      oldOp.debugListId = null;\n      oldOp.prev = null;\n      oldOp.next = null;\n    }\n    static replaceWithMany(oldOp, newOps) {\n      if (newOps.length === 0) {\n        OpList.remove(oldOp);\n        return;\n      }\n      OpList.assertIsNotEnd(oldOp);\n      OpList.assertIsOwned(oldOp);\n      const listId = oldOp.debugListId;\n      oldOp.debugListId = null;\n      for (const newOp of newOps) {\n        OpList.assertIsNotEnd(newOp);\n        OpList.assertIsUnowned(newOp);\n      }\n      const {\n        prev: oldPrev,\n        next: oldNext\n      } = oldOp;\n      oldOp.prev = null;\n      oldOp.next = null;\n      let prev = oldPrev;\n      for (const newOp of newOps) {\n        OpList.assertIsUnowned(newOp);\n        newOp.debugListId = listId;\n        prev.next = newOp;\n        newOp.prev = prev;\n        newOp.next = null;\n        prev = newOp;\n      }\n      const first = newOps[0];\n      const last = prev;\n      if (oldPrev !== null) {\n        oldPrev.next = first;\n        first.prev = oldPrev;\n      }\n      if (oldNext !== null) {\n        oldNext.prev = last;\n        last.next = oldNext;\n      }\n    }\n    static remove(op) {\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsOwned(op);\n      op.prev.next = op.next;\n      op.next.prev = op.prev;\n      op.debugListId = null;\n      op.prev = null;\n      op.next = null;\n    }\n    static insertBefore(op, target) {\n      if (Array.isArray(op)) {\n        for (const o of op) {\n          OpList.insertBefore(o, target);\n        }\n        return;\n      }\n      OpList.assertIsOwned(target);\n      if (target.prev === null) {\n        throw new Error(`AssertionError: illegal operation on list start`);\n      }\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n      op.debugListId = target.debugListId;\n      op.prev = null;\n      target.prev.next = op;\n      op.prev = target.prev;\n      op.next = target;\n      target.prev = op;\n    }\n    static insertAfter(op, target) {\n      OpList.assertIsOwned(target);\n      if (target.next === null) {\n        throw new Error(`AssertionError: illegal operation on list end`);\n      }\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n      op.debugListId = target.debugListId;\n      target.next.prev = op;\n      op.next = target.next;\n      op.prev = target;\n      target.next = op;\n    }\n    static assertIsUnowned(op) {\n      if (op.debugListId !== null) {\n        throw new Error(`AssertionError: illegal operation on owned node: ${OpKind[op.kind]}`);\n      }\n    }\n    static assertIsOwned(op, byList) {\n      if (op.debugListId === null) {\n        throw new Error(`AssertionError: illegal operation on unowned node: ${OpKind[op.kind]}`);\n      } else if (byList !== undefined && op.debugListId !== byList) {\n        throw new Error(`AssertionError: node belongs to the wrong list (expected ${byList}, actual ${op.debugListId})`);\n      }\n    }\n    static assertIsNotEnd(op) {\n      if (op.kind === OpKind.ListEnd) {\n        throw new Error(`AssertionError: illegal operation on list head or tail`);\n      }\n    }\n  }\n  return OpList;\n})();\nclass SlotHandle {\n  slot = null;\n}\nconst elementContainerOpKinds = new Set([OpKind.Element, OpKind.ElementStart, OpKind.Container, OpKind.ContainerStart, OpKind.Template, OpKind.RepeaterCreate, OpKind.ConditionalCreate, OpKind.ConditionalBranchCreate]);\nfunction isElementOrContainerOp(op) {\n  return elementContainerOpKinds.has(op.kind);\n}\nfunction createElementStartOp(tag, xref, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ElementStart,\n    xref,\n    tag,\n    handle: new SlotHandle(),\n    attributes: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createTemplateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.Template,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createConditionalCreateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ConditionalCreate,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createConditionalBranchCreateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ConditionalBranchCreate,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createRepeaterCreateOp(primaryView, emptyView, tag, track, varNames, emptyTag, i18nPlaceholder, emptyI18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.RepeaterCreate,\n    attributes: null,\n    xref: primaryView,\n    handle: new SlotHandle(),\n    emptyView,\n    track,\n    trackByFn: null,\n    trackByOps: null,\n    tag,\n    emptyTag,\n    emptyAttributes: null,\n    functionNameSuffix: 'For',\n    namespace: Namespace.HTML,\n    nonBindable: false,\n    localRefs: [],\n    decls: null,\n    vars: null,\n    varNames,\n    usesComponentInstance: false,\n    i18nPlaceholder,\n    emptyI18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    numSlotsUsed: emptyView === null ? 2 : 3\n  };\n}\nfunction createElementEndOp(xref, sourceSpan) {\n  return {\n    kind: OpKind.ElementEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createDisableBindingsOp(xref) {\n  return {\n    kind: OpKind.DisableBindings,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createEnableBindingsOp(xref) {\n  return {\n    kind: OpKind.EnableBindings,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createTextOp(xref, initialValue, icuPlaceholder, sourceSpan) {\n  return {\n    kind: OpKind.Text,\n    xref,\n    handle: new SlotHandle(),\n    initialValue,\n    icuPlaceholder,\n    sourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createAnimationStringOp(name, target, animationKind, expression, securityContext, sourceSpan) {\n  return {\n    kind: OpKind.AnimationString,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createAnimationOp(name, target, animationKind, callbackOps, securityContext, sourceSpan) {\n  const handlerOps = new OpList();\n  handlerOps.push(callbackOps);\n  return {\n    kind: OpKind.Animation,\n    name,\n    target,\n    animationKind,\n    handlerOps,\n    handlerFnName: null,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createListenerOp(target, targetSlot, name, tag, handlerOps, legacyAnimationPhase, eventTarget, hostListener, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.Listener,\n    target,\n    targetSlot,\n    tag,\n    hostListener,\n    name,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    isLegacyAnimationListener: legacyAnimationPhase !== null,\n    legacyAnimationPhase: legacyAnimationPhase,\n    eventTarget,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createAnimationListenerOp(target, targetSlot, name, tag, handlerOps, animationKind, eventTarget, hostListener, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.AnimationListener,\n    target,\n    targetSlot,\n    tag,\n    hostListener,\n    name,\n    animationKind,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    eventTarget,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createTwoWayListenerOp(target, targetSlot, name, tag, handlerOps, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.TwoWayListener,\n    target,\n    targetSlot,\n    tag,\n    name,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createPipeOp(xref, slot, name) {\n  return {\n    kind: OpKind.Pipe,\n    xref,\n    handle: slot,\n    name,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createNamespaceOp(namespace) {\n  return {\n    kind: OpKind.Namespace,\n    active: namespace,\n    ...NEW_OP\n  };\n}\nfunction createProjectionDefOp(def) {\n  return {\n    kind: OpKind.ProjectionDef,\n    def,\n    ...NEW_OP\n  };\n}\nfunction createProjectionOp(xref, selector, i18nPlaceholder, fallbackView, sourceSpan) {\n  return {\n    kind: OpKind.Projection,\n    xref,\n    handle: new SlotHandle(),\n    selector,\n    i18nPlaceholder,\n    fallbackView,\n    projectionSlotIndex: 0,\n    attributes: null,\n    localRefs: [],\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n    numSlotsUsed: fallbackView === null ? 1 : 2\n  };\n}\nfunction createExtractedAttributeOp(target, bindingKind, namespace, name, expression, i18nContext, i18nMessage, securityContext) {\n  return {\n    kind: OpKind.ExtractedAttribute,\n    target,\n    bindingKind,\n    namespace,\n    name,\n    expression,\n    i18nContext,\n    i18nMessage,\n    securityContext,\n    trustedValueFn: null,\n    ...NEW_OP\n  };\n}\nfunction createDeferOp(xref, main, mainSlot, ownResolverFn, resolverFn, sourceSpan) {\n  return {\n    kind: OpKind.Defer,\n    xref,\n    handle: new SlotHandle(),\n    mainView: main,\n    mainSlot,\n    loadingView: null,\n    loadingSlot: null,\n    loadingConfig: null,\n    loadingMinimumTime: null,\n    loadingAfterTime: null,\n    placeholderView: null,\n    placeholderSlot: null,\n    placeholderConfig: null,\n    placeholderMinimumTime: null,\n    errorView: null,\n    errorSlot: null,\n    ownResolverFn,\n    resolverFn,\n    flags: null,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n    numSlotsUsed: 2\n  };\n}\nfunction createDeferOnOp(defer, trigger, modifier, sourceSpan) {\n  return {\n    kind: OpKind.DeferOn,\n    defer,\n    trigger,\n    modifier,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createDeclareLetOp(xref, declaredName, sourceSpan) {\n  return {\n    kind: OpKind.DeclareLet,\n    xref,\n    declaredName,\n    sourceSpan,\n    handle: new SlotHandle(),\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createI18nMessageOp(xref, i18nContext, i18nBlock, message, messagePlaceholder, params, postprocessingParams, needsPostprocessing) {\n  return {\n    kind: OpKind.I18nMessage,\n    xref,\n    i18nContext,\n    i18nBlock,\n    message,\n    messagePlaceholder,\n    params,\n    postprocessingParams,\n    needsPostprocessing,\n    subMessages: [],\n    ...NEW_OP\n  };\n}\nfunction createI18nStartOp(xref, message, root, sourceSpan) {\n  return {\n    kind: OpKind.I18nStart,\n    xref,\n    handle: new SlotHandle(),\n    root: root ?? xref,\n    message,\n    messageIndex: null,\n    subTemplateIndex: null,\n    context: null,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createI18nEndOp(xref, sourceSpan) {\n  return {\n    kind: OpKind.I18nEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createIcuStartOp(xref, message, messagePlaceholder, sourceSpan) {\n  return {\n    kind: OpKind.IcuStart,\n    xref,\n    message,\n    messagePlaceholder,\n    context: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createIcuEndOp(xref) {\n  return {\n    kind: OpKind.IcuEnd,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createIcuPlaceholderOp(xref, name, strings) {\n  return {\n    kind: OpKind.IcuPlaceholder,\n    xref,\n    name,\n    strings,\n    expressionPlaceholders: [],\n    ...NEW_OP\n  };\n}\nfunction createI18nContextOp(contextKind, xref, i18nBlock, message, sourceSpan) {\n  if (i18nBlock === null && contextKind !== I18nContextKind.Attr) {\n    throw new Error('AssertionError: i18nBlock must be provided for non-attribute contexts.');\n  }\n  return {\n    kind: OpKind.I18nContext,\n    contextKind,\n    xref,\n    i18nBlock,\n    message,\n    sourceSpan,\n    params: new Map(),\n    postprocessingParams: new Map(),\n    ...NEW_OP\n  };\n}\nfunction createI18nAttributesOp(xref, handle, target) {\n  return {\n    kind: OpKind.I18nAttributes,\n    xref,\n    handle,\n    target,\n    i18nAttributesConfig: null,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createSourceLocationOp(templatePath, locations) {\n  return {\n    kind: OpKind.SourceLocation,\n    templatePath,\n    locations,\n    ...NEW_OP\n  };\n}\nfunction createControlCreateOp(sourceSpan) {\n  return {\n    kind: OpKind.ControlCreate,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createDomPropertyOp(name, expression, bindingKind, i18nContext, securityContext, sourceSpan) {\n  return {\n    kind: OpKind.DomProperty,\n    name,\n    expression,\n    bindingKind,\n    i18nContext,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nconst CTX_REF = 'CTX_REF_MARKER';\nvar CompilationJobKind = /*#__PURE__*/function (CompilationJobKind) {\n  CompilationJobKind[CompilationJobKind[\"Tmpl\"] = 0] = \"Tmpl\";\n  CompilationJobKind[CompilationJobKind[\"Host\"] = 1] = \"Host\";\n  CompilationJobKind[CompilationJobKind[\"Both\"] = 2] = \"Both\";\n  return CompilationJobKind;\n}(CompilationJobKind || {});\nvar TemplateCompilationMode = /*#__PURE__*/function (TemplateCompilationMode) {\n  TemplateCompilationMode[TemplateCompilationMode[\"Full\"] = 0] = \"Full\";\n  TemplateCompilationMode[TemplateCompilationMode[\"DomOnly\"] = 1] = \"DomOnly\";\n  return TemplateCompilationMode;\n}(TemplateCompilationMode || {});\nclass CompilationJob {\n  componentName;\n  pool;\n  compatibility;\n  mode;\n  constructor(componentName, pool, compatibility, mode) {\n    this.componentName = componentName;\n    this.pool = pool;\n    this.compatibility = compatibility;\n    this.mode = mode;\n  }\n  kind = CompilationJobKind.Both;\n  allocateXrefId() {\n    return this.nextXrefId++;\n  }\n  nextXrefId = 0;\n}\nclass ComponentCompilationJob extends CompilationJob {\n  relativeContextFilePath;\n  i18nUseExternalIds;\n  deferMeta;\n  allDeferrableDepsFn;\n  relativeTemplatePath;\n  enableDebugLocations;\n  constructor(componentName, pool, compatibility, mode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations) {\n    super(componentName, pool, compatibility, mode);\n    this.relativeContextFilePath = relativeContextFilePath;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this.deferMeta = deferMeta;\n    this.allDeferrableDepsFn = allDeferrableDepsFn;\n    this.relativeTemplatePath = relativeTemplatePath;\n    this.enableDebugLocations = enableDebugLocations;\n    this.root = new ViewCompilationUnit(this, this.allocateXrefId(), null);\n    this.views.set(this.root.xref, this.root);\n  }\n  kind = CompilationJobKind.Tmpl;\n  fnSuffix = 'Template';\n  root;\n  views = new Map();\n  contentSelectors = null;\n  allocateView(parent) {\n    const view = new ViewCompilationUnit(this, this.allocateXrefId(), parent);\n    this.views.set(view.xref, view);\n    return view;\n  }\n  get units() {\n    return this.views.values();\n  }\n  addConst(newConst, initializers) {\n    for (let idx = 0; idx < this.consts.length; idx++) {\n      if (this.consts[idx].isEquivalent(newConst)) {\n        return idx;\n      }\n    }\n    const idx = this.consts.length;\n    this.consts.push(newConst);\n    if (initializers) {\n      this.constsInitializers.push(...initializers);\n    }\n    return idx;\n  }\n  consts = [];\n  constsInitializers = [];\n}\nclass CompilationUnit {\n  xref;\n  constructor(xref) {\n    this.xref = xref;\n  }\n  create = new OpList();\n  update = new OpList();\n  fnName = null;\n  vars = null;\n  *ops() {\n    for (const op of this.create) {\n      yield op;\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        for (const listenerOp of op.handlerOps) {\n          yield listenerOp;\n        }\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        for (const trackOp of op.trackByOps) {\n          yield trackOp;\n        }\n      }\n    }\n    for (const op of this.update) {\n      yield op;\n    }\n  }\n}\nclass ViewCompilationUnit extends CompilationUnit {\n  job;\n  parent;\n  constructor(job, xref, parent) {\n    super(xref);\n    this.job = job;\n    this.parent = parent;\n  }\n  contextVariables = new Map();\n  aliases = new Set();\n  decls = null;\n}\nclass HostBindingCompilationJob extends CompilationJob {\n  constructor(componentName, pool, compatibility, mode) {\n    super(componentName, pool, compatibility, mode);\n    this.root = new HostBindingCompilationUnit(this);\n  }\n  kind = CompilationJobKind.Host;\n  fnSuffix = 'HostBindings';\n  root;\n  get units() {\n    return [this.root];\n  }\n}\nclass HostBindingCompilationUnit extends CompilationUnit {\n  job;\n  constructor(job) {\n    super(0);\n    this.job = job;\n  }\n  attributes = null;\n}\nfunction deleteAnyCasts(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, removeAnys, VisitorContextFlag.None);\n    }\n  }\n}\nfunction removeAnys(e) {\n  if (e instanceof InvokeFunctionExpr && e.fn instanceof LexicalReadExpr && e.fn.name === '$any') {\n    if (e.args.length !== 1) {\n      throw new Error('The $any builtin function expects exactly one argument.');\n    }\n    return e.args[0];\n  }\n  return e;\n}\nfunction applyI18nExpressions(job) {\n  const i18nContexts = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nContext) {\n        i18nContexts.set(op.xref, op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind === OpKind.I18nExpression && needsApplication(i18nContexts, op)) {\n        OpList.insertAfter(createI18nApplyOp(op.i18nOwner, op.handle, null), op);\n      }\n    }\n  }\n}\nfunction needsApplication(i18nContexts, op) {\n  if (op.next?.kind !== OpKind.I18nExpression) {\n    return true;\n  }\n  const context = i18nContexts.get(op.context);\n  const nextContext = i18nContexts.get(op.next.context);\n  if (context === undefined) {\n    throw new Error(\"AssertionError: expected an I18nContextOp to exist for the I18nExpressionOp's context\");\n  }\n  if (nextContext === undefined) {\n    throw new Error(\"AssertionError: expected an I18nContextOp to exist for the next I18nExpressionOp's context\");\n  }\n  if (context.i18nBlock !== null) {\n    if (context.i18nBlock !== nextContext.i18nBlock) {\n      return true;\n    }\n    return false;\n  }\n  if (op.i18nOwner !== op.next.i18nOwner) {\n    return true;\n  }\n  return false;\n}\nfunction assignI18nSlotDependencies(job) {\n  for (const unit of job.units) {\n    let updateOp = unit.update.head;\n    let i18nExpressionsInProgress = [];\n    let state = null;\n    for (const createOp of unit.create) {\n      if (createOp.kind === OpKind.I18nStart) {\n        state = {\n          blockXref: createOp.xref,\n          lastSlotConsumer: createOp.xref\n        };\n      } else if (createOp.kind === OpKind.I18nEnd) {\n        for (const op of i18nExpressionsInProgress) {\n          op.target = state.lastSlotConsumer;\n          OpList.insertBefore(op, updateOp);\n        }\n        i18nExpressionsInProgress.length = 0;\n        state = null;\n      }\n      if (hasConsumesSlotTrait(createOp)) {\n        if (state !== null) {\n          state.lastSlotConsumer = createOp.xref;\n        }\n        while (true) {\n          if (updateOp.next === null) {\n            break;\n          }\n          if (state !== null && updateOp.kind === OpKind.I18nExpression && updateOp.usage === I18nExpressionFor.I18nText && updateOp.i18nOwner === state.blockXref) {\n            const opToRemove = updateOp;\n            updateOp = updateOp.next;\n            OpList.remove(opToRemove);\n            i18nExpressionsInProgress.push(opToRemove);\n            continue;\n          }\n          let hasDifferentTarget = false;\n          if (hasDependsOnSlotContextTrait(updateOp) && updateOp.target !== createOp.xref) {\n            hasDifferentTarget = true;\n          } else if (updateOp.kind === OpKind.Statement || updateOp.kind === OpKind.Variable) {\n            visitExpressionsInOp(updateOp, expr => {\n              if (!hasDifferentTarget && hasDependsOnSlotContextTrait(expr) && expr.target !== createOp.xref) {\n                hasDifferentTarget = true;\n              }\n            });\n          }\n          if (hasDifferentTarget) {\n            break;\n          }\n          updateOp = updateOp.next;\n        }\n      }\n    }\n  }\n}\nfunction attachSourceLocations(job) {\n  if (!job.enableDebugLocations || job.relativeTemplatePath === null) {\n    return;\n  }\n  for (const unit of job.units) {\n    const locations = [];\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ElementStart || op.kind === OpKind.Element) {\n        const start = op.startSourceSpan.start;\n        locations.push({\n          targetSlot: op.handle,\n          offset: start.offset,\n          line: start.line,\n          column: start.col\n        });\n      }\n    }\n    if (locations.length > 0) {\n      unit.create.push(createSourceLocationOp(job.relativeTemplatePath, locations));\n    }\n  }\n}\nfunction createOpXrefMap(unit) {\n  const map = new Map();\n  for (const op of unit.create) {\n    if (!hasConsumesSlotTrait(op)) {\n      continue;\n    }\n    map.set(op.xref, op);\n    if (op.kind === OpKind.RepeaterCreate && op.emptyView !== null) {\n      map.set(op.emptyView, op);\n    }\n  }\n  return map;\n}\nfunction extractAttributes(job) {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Attribute:\n          extractAttributeOp(unit, op, elements);\n          break;\n        case OpKind.Property:\n          if (op.bindingKind !== BindingKind.LegacyAnimation && op.bindingKind !== BindingKind.Animation) {\n            let bindingKind;\n            if (op.i18nMessage !== null && op.templateKind === null) {\n              bindingKind = BindingKind.I18n;\n            } else if (op.isStructuralTemplateAttribute) {\n              bindingKind = BindingKind.Template;\n            } else {\n              bindingKind = BindingKind.Property;\n            }\n            OpList.insertBefore(createExtractedAttributeOp(op.target, bindingKind, null, op.name, null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          }\n          break;\n        case OpKind.Control:\n          OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.Property, null, 'field', null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          break;\n        case OpKind.TwoWayProperty:\n          OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.TwoWayProperty, null, op.name, null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          break;\n        case OpKind.StyleProp:\n        case OpKind.ClassProp:\n          if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder && op.expression instanceof EmptyExpr) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.STYLE), lookupElement$3(elements, op.target));\n          }\n          break;\n        case OpKind.Listener:\n          if (!op.isLegacyAnimationListener) {\n            const extractedAttributeOp = createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.NONE);\n            if (job.kind === CompilationJobKind.Host) {\n              if (job.compatibility) {\n                break;\n              }\n              unit.create.push(extractedAttributeOp);\n            } else {\n              OpList.insertBefore(extractedAttributeOp, lookupElement$3(elements, op.target));\n            }\n          }\n          break;\n        case OpKind.TwoWayListener:\n          if (job.kind !== CompilationJobKind.Host) {\n            const extractedAttributeOp = createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.NONE);\n            OpList.insertBefore(extractedAttributeOp, lookupElement$3(elements, op.target));\n          }\n          break;\n      }\n    }\n  }\n}\nfunction lookupElement$3(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction extractAttributeOp(unit, op, elements) {\n  if (op.expression instanceof Interpolation) {\n    return;\n  }\n  let extractable = op.isTextAttribute || op.expression.isConstant();\n  if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n    extractable &&= op.isTextAttribute;\n  }\n  if (extractable) {\n    const extractedAttributeOp = createExtractedAttributeOp(op.target, op.isStructuralTemplateAttribute ? BindingKind.Template : BindingKind.Attribute, op.namespace, op.name, op.expression, op.i18nContext, op.i18nMessage, op.securityContext);\n    if (unit.job.kind === CompilationJobKind.Host) {\n      unit.create.push(extractedAttributeOp);\n    } else {\n      const ownerOp = lookupElement$3(elements, op.target);\n      OpList.insertBefore(extractedAttributeOp, ownerOp);\n    }\n    OpList.remove(op);\n  }\n}\nconst ARIA_PREFIX = 'aria-';\nfunction isAriaAttribute(name) {\n  return name.startsWith(ARIA_PREFIX) && name.length > ARIA_PREFIX.length;\n}\nfunction lookupElement$2(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction specializeBindings(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== OpKind.Binding) {\n        continue;\n      }\n      switch (op.bindingKind) {\n        case BindingKind.Attribute:\n          if (op.name === 'ngNonBindable') {\n            OpList.remove(op);\n            const target = lookupElement$2(elements, op.target);\n            target.nonBindable = true;\n          } else if (op.name.startsWith('animate.')) {\n            OpList.replace(op, createAnimationBindingOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan, 0));\n          } else {\n            const [namespace, name] = splitNsName(op.name);\n            OpList.replace(op, createAttributeOp(op.target, namespace, name, op.expression, op.securityContext, op.isTextAttribute, op.isStructuralTemplateAttribute, op.templateKind, op.i18nMessage, op.sourceSpan));\n          }\n          break;\n        case BindingKind.Animation:\n          OpList.replace(op, createAnimationBindingOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan, 1));\n          break;\n        case BindingKind.Property:\n        case BindingKind.LegacyAnimation:\n          if (job.mode === TemplateCompilationMode.DomOnly && isAriaAttribute(op.name)) {\n            OpList.replace(op, createAttributeOp(op.target, null, op.name, op.expression, op.securityContext, false, op.isStructuralTemplateAttribute, op.templateKind, op.i18nMessage, op.sourceSpan));\n          } else if (job.kind === CompilationJobKind.Host) {\n            OpList.replace(op, createDomPropertyOp(op.name, op.expression, op.bindingKind, op.i18nContext, op.securityContext, op.sourceSpan));\n          } else if (op.name === 'field') {\n            OpList.replace(op, createControlOp(op));\n          } else {\n            OpList.replace(op, createPropertyOp(op.target, op.name, op.expression, op.bindingKind, op.securityContext, op.isStructuralTemplateAttribute, op.templateKind, op.i18nContext, op.i18nMessage, op.sourceSpan));\n          }\n          break;\n        case BindingKind.TwoWayProperty:\n          if (!(op.expression instanceof Expression)) {\n            throw new Error(`Expected value of two-way property binding \"${op.name}\" to be an expression`);\n          }\n          OpList.replace(op, createTwoWayPropertyOp(op.target, op.name, op.expression, op.securityContext, op.isStructuralTemplateAttribute, op.templateKind, op.i18nContext, op.i18nMessage, op.sourceSpan));\n          break;\n        case BindingKind.I18n:\n        case BindingKind.ClassName:\n        case BindingKind.StyleProperty:\n          throw new Error(`Unhandled binding of kind ${BindingKind[op.bindingKind]}`);\n      }\n    }\n  }\n}\nconst CHAIN_COMPATIBILITY = new Map([[Identifiers.ariaProperty, Identifiers.ariaProperty], [Identifiers.attribute, Identifiers.attribute], [Identifiers.classProp, Identifiers.classProp], [Identifiers.element, Identifiers.element], [Identifiers.elementContainer, Identifiers.elementContainer], [Identifiers.elementContainerEnd, Identifiers.elementContainerEnd], [Identifiers.elementContainerStart, Identifiers.elementContainerStart], [Identifiers.elementEnd, Identifiers.elementEnd], [Identifiers.elementStart, Identifiers.elementStart], [Identifiers.domProperty, Identifiers.domProperty], [Identifiers.i18nExp, Identifiers.i18nExp], [Identifiers.listener, Identifiers.listener], [Identifiers.listener, Identifiers.listener], [Identifiers.property, Identifiers.property], [Identifiers.styleProp, Identifiers.styleProp], [Identifiers.syntheticHostListener, Identifiers.syntheticHostListener], [Identifiers.syntheticHostProperty, Identifiers.syntheticHostProperty], [Identifiers.templateCreate, Identifiers.templateCreate], [Identifiers.twoWayProperty, Identifiers.twoWayProperty], [Identifiers.twoWayListener, Identifiers.twoWayListener], [Identifiers.declareLet, Identifiers.declareLet], [Identifiers.conditionalCreate, Identifiers.conditionalBranchCreate], [Identifiers.conditionalBranchCreate, Identifiers.conditionalBranchCreate], [Identifiers.domElement, Identifiers.domElement], [Identifiers.domElementStart, Identifiers.domElementStart], [Identifiers.domElementEnd, Identifiers.domElementEnd], [Identifiers.domElementContainer, Identifiers.domElementContainer], [Identifiers.domElementContainerStart, Identifiers.domElementContainerStart], [Identifiers.domElementContainerEnd, Identifiers.domElementContainerEnd], [Identifiers.domListener, Identifiers.domListener], [Identifiers.domTemplate, Identifiers.domTemplate], [Identifiers.animationEnter, Identifiers.animationEnter], [Identifiers.animationLeave, Identifiers.animationLeave], [Identifiers.animationEnterListener, Identifiers.animationEnterListener], [Identifiers.animationLeaveListener, Identifiers.animationLeaveListener]]);\nconst MAX_CHAIN_LENGTH = 256;\nfunction chain(job) {\n  for (const unit of job.units) {\n    chainOperationsInList(unit.create);\n    chainOperationsInList(unit.update);\n  }\n}\nfunction chainOperationsInList(opList) {\n  let chain = null;\n  for (const op of opList) {\n    if (op.kind !== OpKind.Statement || !(op.statement instanceof ExpressionStatement)) {\n      chain = null;\n      continue;\n    }\n    if (!(op.statement.expr instanceof InvokeFunctionExpr) || !(op.statement.expr.fn instanceof ExternalExpr)) {\n      chain = null;\n      continue;\n    }\n    const instruction = op.statement.expr.fn.value;\n    if (!CHAIN_COMPATIBILITY.has(instruction)) {\n      chain = null;\n      continue;\n    }\n    if (chain !== null && CHAIN_COMPATIBILITY.get(chain.instruction) === instruction && chain.length < MAX_CHAIN_LENGTH) {\n      const expression = chain.expression.callFn(op.statement.expr.args, op.statement.expr.sourceSpan, op.statement.expr.pure);\n      chain.expression = expression;\n      chain.op.statement = expression.toStmt();\n      chain.length++;\n      OpList.remove(op);\n    } else {\n      chain = {\n        op,\n        instruction,\n        expression: op.statement.expr,\n        length: 1\n      };\n    }\n  }\n}\nfunction collapseSingletonInterpolations(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      const eligibleOpKind = op.kind === OpKind.Attribute || op.kind === OpKind.StyleProp || op.kind == OpKind.StyleMap || op.kind === OpKind.ClassMap;\n      if (eligibleOpKind && op.expression instanceof Interpolation && op.expression.strings.length === 2 && op.expression.strings.every(s => s === '')) {\n        op.expression = op.expression.expressions[0];\n      }\n    }\n  }\n}\nfunction generateConditionalExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== OpKind.Conditional) {\n        continue;\n      }\n      let test;\n      const defaultCase = op.conditions.findIndex(cond => cond.expr === null);\n      if (defaultCase >= 0) {\n        const slot = op.conditions.splice(defaultCase, 1)[0].targetSlot;\n        test = new SlotLiteralExpr(slot);\n      } else {\n        test = literal(-1);\n      }\n      let tmp = op.test == null ? null : new AssignTemporaryExpr(op.test, job.allocateXrefId());\n      let caseExpressionTemporaryXref = null;\n      for (let i = op.conditions.length - 1; i >= 0; i--) {\n        let conditionalCase = op.conditions[i];\n        if (conditionalCase.expr === null) {\n          continue;\n        }\n        if (tmp !== null) {\n          const useTmp = i === 0 ? tmp : new ReadTemporaryExpr(tmp.xref);\n          conditionalCase.expr = new BinaryOperatorExpr(BinaryOperator.Identical, useTmp, conditionalCase.expr);\n        } else if (conditionalCase.alias !== null) {\n          caseExpressionTemporaryXref ??= job.allocateXrefId();\n          conditionalCase.expr = new AssignTemporaryExpr(conditionalCase.expr, caseExpressionTemporaryXref);\n          op.contextValue = new ReadTemporaryExpr(caseExpressionTemporaryXref);\n        }\n        test = new ConditionalExpr(conditionalCase.expr, new SlotLiteralExpr(conditionalCase.targetSlot), test);\n      }\n      op.processed = test;\n      op.conditions = [];\n    }\n  }\n}\nconst BINARY_OPERATORS = new Map([['&&', BinaryOperator.And], ['>', BinaryOperator.Bigger], ['>=', BinaryOperator.BiggerEquals], ['|', BinaryOperator.BitwiseOr], ['&', BinaryOperator.BitwiseAnd], ['/', BinaryOperator.Divide], ['=', BinaryOperator.Assign], ['==', BinaryOperator.Equals], ['===', BinaryOperator.Identical], ['<', BinaryOperator.Lower], ['<=', BinaryOperator.LowerEquals], ['-', BinaryOperator.Minus], ['%', BinaryOperator.Modulo], ['**', BinaryOperator.Exponentiation], ['*', BinaryOperator.Multiply], ['!=', BinaryOperator.NotEquals], ['!==', BinaryOperator.NotIdentical], ['??', BinaryOperator.NullishCoalesce], ['||', BinaryOperator.Or], ['+', BinaryOperator.Plus], ['in', BinaryOperator.In], ['+=', BinaryOperator.AdditionAssignment], ['-=', BinaryOperator.SubtractionAssignment], ['*=', BinaryOperator.MultiplicationAssignment], ['/=', BinaryOperator.DivisionAssignment], ['%=', BinaryOperator.RemainderAssignment], ['**=', BinaryOperator.ExponentiationAssignment], ['&&=', BinaryOperator.AndAssignment], ['||=', BinaryOperator.OrAssignment], ['??=', BinaryOperator.NullishCoalesceAssignment]]);\nfunction namespaceForKey(namespacePrefixKey) {\n  const NAMESPACES = new Map([['svg', Namespace.SVG], ['math', Namespace.Math]]);\n  if (namespacePrefixKey === null) {\n    return Namespace.HTML;\n  }\n  return NAMESPACES.get(namespacePrefixKey) ?? Namespace.HTML;\n}\nfunction keyForNamespace(namespace) {\n  const NAMESPACES = new Map([['svg', Namespace.SVG], ['math', Namespace.Math]]);\n  for (const [k, n] of NAMESPACES.entries()) {\n    if (n === namespace) {\n      return k;\n    }\n  }\n  return null;\n}\nfunction prefixWithNamespace(strippedTag, namespace) {\n  if (namespace === Namespace.HTML) {\n    return strippedTag;\n  }\n  return `:${keyForNamespace(namespace)}:${strippedTag}`;\n}\nfunction literalOrArrayLiteral(value) {\n  if (Array.isArray(value)) {\n    return literalArr(value.map(literalOrArrayLiteral));\n  }\n  return literal(value);\n}\nfunction collectElementConsts(job) {\n  const allElementAttributes = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ExtractedAttribute) {\n        const attributes = allElementAttributes.get(op.target) || new ElementAttributes(job.compatibility);\n        allElementAttributes.set(op.target, attributes);\n        attributes.add(op.bindingKind, op.name, op.expression, op.namespace, op.trustedValueFn);\n        OpList.remove(op);\n      }\n    }\n  }\n  if (job instanceof ComponentCompilationJob) {\n    for (const unit of job.units) {\n      for (const op of unit.create) {\n        if (op.kind == OpKind.Projection) {\n          const attributes = allElementAttributes.get(op.xref);\n          if (attributes !== undefined) {\n            const attrArray = serializeAttributes(attributes);\n            if (attrArray.entries.length > 0) {\n              op.attributes = attrArray;\n            }\n          }\n        } else if (isElementOrContainerOp(op)) {\n          op.attributes = getConstIndex(job, allElementAttributes, op.xref);\n          if (op.kind === OpKind.RepeaterCreate && op.emptyView !== null) {\n            op.emptyAttributes = getConstIndex(job, allElementAttributes, op.emptyView);\n          }\n        }\n      }\n    }\n  } else if (job instanceof HostBindingCompilationJob) {\n    for (const [xref, attributes] of allElementAttributes.entries()) {\n      if (xref !== job.root.xref) {\n        throw new Error(`An attribute would be const collected into the host binding's template function, but is not associated with the root xref.`);\n      }\n      const attrArray = serializeAttributes(attributes);\n      if (attrArray.entries.length > 0) {\n        job.root.attributes = attrArray;\n      }\n    }\n  }\n}\nfunction getConstIndex(job, allElementAttributes, xref) {\n  const attributes = allElementAttributes.get(xref);\n  if (attributes !== undefined) {\n    const attrArray = serializeAttributes(attributes);\n    if (attrArray.entries.length > 0) {\n      return job.addConst(attrArray);\n    }\n  }\n  return null;\n}\nconst FLYWEIGHT_ARRAY = Object.freeze([]);\nclass ElementAttributes {\n  compatibility;\n  known = new Map();\n  byKind = new Map();\n  propertyBindings = null;\n  projectAs = null;\n  get attributes() {\n    return this.byKind.get(BindingKind.Attribute) ?? FLYWEIGHT_ARRAY;\n  }\n  get classes() {\n    return this.byKind.get(BindingKind.ClassName) ?? FLYWEIGHT_ARRAY;\n  }\n  get styles() {\n    return this.byKind.get(BindingKind.StyleProperty) ?? FLYWEIGHT_ARRAY;\n  }\n  get bindings() {\n    return this.propertyBindings ?? FLYWEIGHT_ARRAY;\n  }\n  get template() {\n    return this.byKind.get(BindingKind.Template) ?? FLYWEIGHT_ARRAY;\n  }\n  get i18n() {\n    return this.byKind.get(BindingKind.I18n) ?? FLYWEIGHT_ARRAY;\n  }\n  constructor(compatibility) {\n    this.compatibility = compatibility;\n  }\n  isKnown(kind, name) {\n    const nameToValue = this.known.get(kind) ?? new Set();\n    this.known.set(kind, nameToValue);\n    if (nameToValue.has(name)) {\n      return true;\n    }\n    nameToValue.add(name);\n    return false;\n  }\n  add(kind, name, value, namespace, trustedValueFn) {\n    const allowDuplicates = this.compatibility === CompatibilityMode.TemplateDefinitionBuilder && (kind === BindingKind.Attribute || kind === BindingKind.ClassName || kind === BindingKind.StyleProperty);\n    if (!allowDuplicates && this.isKnown(kind, name)) {\n      return;\n    }\n    if (name === 'ngProjectAs') {\n      if (value === null || !(value instanceof LiteralExpr) || value.value == null || typeof value.value?.toString() !== 'string') {\n        throw Error('ngProjectAs must have a string literal value');\n      }\n      this.projectAs = value.value.toString();\n    }\n    const array = this.arrayFor(kind);\n    array.push(...getAttributeNameLiterals(namespace, name));\n    if (kind === BindingKind.Attribute || kind === BindingKind.StyleProperty) {\n      if (value === null) {\n        throw Error('Attribute, i18n attribute, & style element attributes must have a value');\n      }\n      if (trustedValueFn !== null) {\n        if (!isStringLiteral(value)) {\n          throw Error('AssertionError: extracted attribute value should be string literal');\n        }\n        array.push(taggedTemplate(trustedValueFn, new TemplateLiteralExpr([new TemplateLiteralElementExpr(value.value)], []), undefined, value.sourceSpan));\n      } else {\n        array.push(value);\n      }\n    }\n  }\n  arrayFor(kind) {\n    if (kind === BindingKind.Property || kind === BindingKind.TwoWayProperty) {\n      this.propertyBindings ??= [];\n      return this.propertyBindings;\n    } else {\n      if (!this.byKind.has(kind)) {\n        this.byKind.set(kind, []);\n      }\n      return this.byKind.get(kind);\n    }\n  }\n}\nfunction getAttributeNameLiterals(namespace, name) {\n  const nameLiteral = literal(name);\n  if (namespace) {\n    return [literal(0), literal(namespace), nameLiteral];\n  }\n  return [nameLiteral];\n}\nfunction serializeAttributes({\n  attributes,\n  bindings,\n  classes,\n  i18n,\n  projectAs,\n  styles,\n  template\n}) {\n  const attrArray = [...attributes];\n  if (projectAs !== null) {\n    const parsedR3Selector = parseSelectorToR3Selector(projectAs)[0];\n    attrArray.push(literal(5), literalOrArrayLiteral(parsedR3Selector));\n  }\n  if (classes.length > 0) {\n    attrArray.push(literal(1), ...classes);\n  }\n  if (styles.length > 0) {\n    attrArray.push(literal(2), ...styles);\n  }\n  if (bindings.length > 0) {\n    attrArray.push(literal(3), ...bindings);\n  }\n  if (template.length > 0) {\n    attrArray.push(literal(4), ...template);\n  }\n  if (i18n.length > 0) {\n    attrArray.push(literal(6), ...i18n);\n  }\n  return literalArr(attrArray);\n}\nfunction lookupElement$1(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction convertAnimations(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.AnimationBinding) {\n        const createAnimationOp = getAnimationOp(op);\n        if (job.kind === CompilationJobKind.Host) {\n          unit.create.push(createAnimationOp);\n        } else {\n          OpList.insertAfter(createAnimationOp, lookupElement$1(elements, op.target));\n        }\n        OpList.remove(op);\n      }\n    }\n  }\n}\nfunction getAnimationOp(op) {\n  if (op.animationBindingKind === 0) {\n    return createAnimationStringOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan);\n  } else {\n    const expression = op.expression;\n    return createAnimationOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", [createStatementOp(new ReturnStatement(expression, expression.sourceSpan))], op.securityContext, op.sourceSpan);\n  }\n}\nfunction convertI18nBindings(job) {\n  const i18nAttributesByElem = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nAttributes) {\n        i18nAttributesByElem.set(op.target, op);\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Property:\n        case OpKind.Attribute:\n          if (op.i18nContext === null) {\n            continue;\n          }\n          if (!(op.expression instanceof Interpolation)) {\n            continue;\n          }\n          const i18nAttributesForElem = i18nAttributesByElem.get(op.target);\n          if (i18nAttributesForElem === undefined) {\n            throw new Error('AssertionError: An i18n attribute binding instruction requires the owning element to have an I18nAttributes create instruction');\n          }\n          if (i18nAttributesForElem.target !== op.target) {\n            throw new Error('AssertionError: Expected i18nAttributes target element to match binding target element');\n          }\n          const ops = [];\n          for (let i = 0; i < op.expression.expressions.length; i++) {\n            const expr = op.expression.expressions[i];\n            if (op.expression.i18nPlaceholders.length !== op.expression.expressions.length) {\n              throw new Error(`AssertionError: An i18n attribute binding instruction requires the same number of expressions and placeholders, but found ${op.expression.i18nPlaceholders.length} placeholders and ${op.expression.expressions.length} expressions`);\n            }\n            ops.push(createI18nExpressionOp(op.i18nContext, i18nAttributesForElem.target, i18nAttributesForElem.xref, i18nAttributesForElem.handle, expr, null, op.expression.i18nPlaceholders[i], I18nParamResolutionTime.Creation, I18nExpressionFor.I18nAttribute, op.name, op.sourceSpan));\n          }\n          OpList.replaceWithMany(op, ops);\n          break;\n      }\n    }\n  }\n}\nfunction createI18nContexts(job) {\n  const attrContextByMessage = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Binding:\n        case OpKind.Property:\n        case OpKind.Attribute:\n        case OpKind.ExtractedAttribute:\n          if (op.i18nMessage === null) {\n            continue;\n          }\n          if (!attrContextByMessage.has(op.i18nMessage)) {\n            const i18nContext = createI18nContextOp(I18nContextKind.Attr, job.allocateXrefId(), null, op.i18nMessage, null);\n            unit.create.push(i18nContext);\n            attrContextByMessage.set(op.i18nMessage, i18nContext.xref);\n          }\n          op.i18nContext = attrContextByMessage.get(op.i18nMessage);\n          break;\n      }\n    }\n  }\n  const blockContextByI18nBlock = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          if (op.xref === op.root) {\n            const contextOp = createI18nContextOp(I18nContextKind.RootI18n, job.allocateXrefId(), op.xref, op.message, null);\n            unit.create.push(contextOp);\n            op.context = contextOp.xref;\n            blockContextByI18nBlock.set(op.xref, contextOp);\n          }\n          break;\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nStart && op.xref !== op.root) {\n        const rootContext = blockContextByI18nBlock.get(op.root);\n        if (rootContext === undefined) {\n          throw Error('AssertionError: Root i18n block i18n context should have been created.');\n        }\n        op.context = rootContext.xref;\n        blockContextByI18nBlock.set(op.xref, rootContext);\n      }\n    }\n  }\n  let currentI18nOp = null;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          currentI18nOp = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18nOp = null;\n          break;\n        case OpKind.IcuStart:\n          if (currentI18nOp === null) {\n            throw Error('AssertionError: Unexpected ICU outside of an i18n block.');\n          }\n          if (op.message.id !== currentI18nOp.message.id) {\n            const contextOp = createI18nContextOp(I18nContextKind.Icu, job.allocateXrefId(), currentI18nOp.root, op.message, null);\n            unit.create.push(contextOp);\n            op.context = contextOp.xref;\n          } else {\n            op.context = currentI18nOp.context;\n            blockContextByI18nBlock.get(currentI18nOp.xref).contextKind = I18nContextKind.Icu;\n          }\n          break;\n      }\n    }\n  }\n}\nfunction deduplicateTextBindings(job) {\n  const seen = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.update.reversed()) {\n      if (op.kind === OpKind.Binding && op.isTextAttribute) {\n        const seenForElement = seen.get(op.target) || new Set();\n        if (seenForElement.has(op.name)) {\n          if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n            if (op.name === 'style' || op.name === 'class') {\n              OpList.remove(op);\n            }\n          }\n        }\n        seenForElement.add(op.name);\n        seen.set(op.target, seenForElement);\n      }\n    }\n  }\n}\nfunction configureDeferInstructions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.Defer) {\n        continue;\n      }\n      if (op.placeholderMinimumTime !== null) {\n        op.placeholderConfig = new ConstCollectedExpr(literalOrArrayLiteral([op.placeholderMinimumTime]));\n      }\n      if (op.loadingMinimumTime !== null || op.loadingAfterTime !== null) {\n        op.loadingConfig = new ConstCollectedExpr(literalOrArrayLiteral([op.loadingMinimumTime, op.loadingAfterTime]));\n      }\n    }\n  }\n}\nfunction resolveDeferTargetNames(job) {\n  const scopes = new Map();\n  function getScopeForView(view) {\n    if (scopes.has(view.xref)) {\n      return scopes.get(view.xref);\n    }\n    const scope = new Scope$1();\n    for (const op of view.create) {\n      if (!isElementOrContainerOp(op) || op.localRefs === null) {\n        continue;\n      }\n      if (!Array.isArray(op.localRefs)) {\n        throw new Error('LocalRefs were already processed, but were needed to resolve defer targets.');\n      }\n      for (const ref of op.localRefs) {\n        if (ref.target !== '') {\n          continue;\n        }\n        scope.targets.set(ref.name, {\n          xref: op.xref,\n          slot: op.handle\n        });\n      }\n    }\n    scopes.set(view.xref, scope);\n    return scope;\n  }\n  function resolveTrigger(deferOwnerView, op, placeholderView) {\n    switch (op.trigger.kind) {\n      case DeferTriggerKind.Idle:\n      case DeferTriggerKind.Never:\n      case DeferTriggerKind.Immediate:\n      case DeferTriggerKind.Timer:\n        return;\n      case DeferTriggerKind.Hover:\n      case DeferTriggerKind.Interaction:\n      case DeferTriggerKind.Viewport:\n        if (op.trigger.targetName === null) {\n          if (placeholderView === null) {\n            throw new Error('defer on trigger with no target name must have a placeholder block');\n          }\n          const placeholder = job.views.get(placeholderView);\n          if (placeholder == undefined) {\n            throw new Error('AssertionError: could not find placeholder view for defer on trigger');\n          }\n          for (const placeholderOp of placeholder.create) {\n            if (hasConsumesSlotTrait(placeholderOp) && (isElementOrContainerOp(placeholderOp) || placeholderOp.kind === OpKind.Projection)) {\n              op.trigger.targetXref = placeholderOp.xref;\n              op.trigger.targetView = placeholderView;\n              op.trigger.targetSlotViewSteps = -1;\n              op.trigger.targetSlot = placeholderOp.handle;\n              return;\n            }\n          }\n          return;\n        }\n        let view = placeholderView !== null ? job.views.get(placeholderView) : deferOwnerView;\n        let step = placeholderView !== null ? -1 : 0;\n        while (view !== null) {\n          const scope = getScopeForView(view);\n          if (scope.targets.has(op.trigger.targetName)) {\n            const {\n              xref,\n              slot\n            } = scope.targets.get(op.trigger.targetName);\n            op.trigger.targetXref = xref;\n            op.trigger.targetView = view.xref;\n            op.trigger.targetSlotViewSteps = step;\n            op.trigger.targetSlot = slot;\n            return;\n          }\n          view = view.parent !== null ? job.views.get(view.parent) : null;\n          step++;\n        }\n        break;\n      default:\n        throw new Error(`Trigger kind ${op.trigger.kind} not handled`);\n    }\n  }\n  for (const unit of job.units) {\n    const defers = new Map();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.Defer:\n          defers.set(op.xref, op);\n          break;\n        case OpKind.DeferOn:\n          const deferOp = defers.get(op.defer);\n          resolveTrigger(unit, op, op.modifier === \"hydrate\" ? deferOp.mainView : deferOp.placeholderView);\n          break;\n      }\n    }\n  }\n}\nlet Scope$1 = class Scope {\n  targets = new Map();\n};\nconst REPLACEMENTS = new Map([[OpKind.ElementEnd, [OpKind.ElementStart, OpKind.Element]], [OpKind.ContainerEnd, [OpKind.ContainerStart, OpKind.Container]], [OpKind.I18nEnd, [OpKind.I18nStart, OpKind.I18n]]]);\nconst IGNORED_OP_KINDS = new Set([OpKind.Pipe]);\nfunction collapseEmptyInstructions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      const opReplacements = REPLACEMENTS.get(op.kind);\n      if (opReplacements === undefined) {\n        continue;\n      }\n      const [startKind, mergedKind] = opReplacements;\n      let prevOp = op.prev;\n      while (prevOp !== null && IGNORED_OP_KINDS.has(prevOp.kind)) {\n        prevOp = prevOp.prev;\n      }\n      if (prevOp !== null && prevOp.kind === startKind) {\n        prevOp.kind = mergedKind;\n        OpList.remove(op);\n      }\n    }\n  }\n}\nfunction expandSafeReads(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, e => safeTransform(e, {\n        job\n      }), VisitorContextFlag.None);\n      transformExpressionsInOp(op, ternaryTransform, VisitorContextFlag.None);\n    }\n  }\n}\nfunction needsTemporaryInSafeAccess(e) {\n  if (e instanceof UnaryOperatorExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  } else if (e instanceof BinaryOperatorExpr) {\n    return needsTemporaryInSafeAccess(e.lhs) || needsTemporaryInSafeAccess(e.rhs);\n  } else if (e instanceof ConditionalExpr) {\n    if (e.falseCase && needsTemporaryInSafeAccess(e.falseCase)) return true;\n    return needsTemporaryInSafeAccess(e.condition) || needsTemporaryInSafeAccess(e.trueCase);\n  } else if (e instanceof NotExpr) {\n    return needsTemporaryInSafeAccess(e.condition);\n  } else if (e instanceof AssignTemporaryExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  } else if (e instanceof ReadPropExpr) {\n    return needsTemporaryInSafeAccess(e.receiver);\n  } else if (e instanceof ReadKeyExpr) {\n    return needsTemporaryInSafeAccess(e.receiver) || needsTemporaryInSafeAccess(e.index);\n  } else if (e instanceof ParenthesizedExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  }\n  return e instanceof InvokeFunctionExpr || e instanceof LiteralArrayExpr || e instanceof LiteralMapExpr || e instanceof SafeInvokeFunctionExpr || e instanceof PipeBindingExpr;\n}\nfunction temporariesIn(e) {\n  const temporaries = new Set();\n  transformExpressionsInExpression(e, e => {\n    if (e instanceof AssignTemporaryExpr) {\n      temporaries.add(e.xref);\n    }\n    return e;\n  }, VisitorContextFlag.None);\n  return temporaries;\n}\nfunction eliminateTemporaryAssignments(e, tmps, ctx) {\n  transformExpressionsInExpression(e, e => {\n    if (e instanceof AssignTemporaryExpr && tmps.has(e.xref)) {\n      const read = new ReadTemporaryExpr(e.xref);\n      return ctx.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder ? new AssignTemporaryExpr(read, read.xref) : read;\n    }\n    return e;\n  }, VisitorContextFlag.None);\n  return e;\n}\nfunction safeTernaryWithTemporary(guard, body, ctx) {\n  let result;\n  if (needsTemporaryInSafeAccess(guard)) {\n    const xref = ctx.job.allocateXrefId();\n    result = [new AssignTemporaryExpr(guard, xref), new ReadTemporaryExpr(xref)];\n  } else {\n    result = [guard, guard.clone()];\n    eliminateTemporaryAssignments(result[1], temporariesIn(result[0]), ctx);\n  }\n  return new SafeTernaryExpr(result[0], body(result[1]));\n}\nfunction isSafeAccessExpression(e) {\n  return e instanceof SafePropertyReadExpr || e instanceof SafeKeyedReadExpr || e instanceof SafeInvokeFunctionExpr;\n}\nfunction isUnsafeAccessExpression(e) {\n  return e instanceof ReadPropExpr || e instanceof ReadKeyExpr || e instanceof InvokeFunctionExpr;\n}\nfunction isAccessExpression(e) {\n  return isSafeAccessExpression(e) || isUnsafeAccessExpression(e);\n}\nfunction deepestSafeTernary(e) {\n  if (isAccessExpression(e) && e.receiver instanceof SafeTernaryExpr) {\n    let st = e.receiver;\n    while (st.expr instanceof SafeTernaryExpr) {\n      st = st.expr;\n    }\n    return st;\n  }\n  return null;\n}\nfunction safeTransform(e, ctx) {\n  if (!isAccessExpression(e)) {\n    return e;\n  }\n  const dst = deepestSafeTernary(e);\n  if (dst) {\n    if (e instanceof InvokeFunctionExpr) {\n      dst.expr = dst.expr.callFn(e.args);\n      return e.receiver;\n    }\n    if (e instanceof ReadPropExpr) {\n      dst.expr = dst.expr.prop(e.name);\n      return e.receiver;\n    }\n    if (e instanceof ReadKeyExpr) {\n      dst.expr = dst.expr.key(e.index);\n      return e.receiver;\n    }\n    if (e instanceof SafeInvokeFunctionExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.callFn(e.args), ctx);\n      return e.receiver;\n    }\n    if (e instanceof SafePropertyReadExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.prop(e.name), ctx);\n      return e.receiver;\n    }\n    if (e instanceof SafeKeyedReadExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.key(e.index), ctx);\n      return e.receiver;\n    }\n  } else {\n    if (e instanceof SafeInvokeFunctionExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.callFn(e.args), ctx);\n    }\n    if (e instanceof SafePropertyReadExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.prop(e.name), ctx);\n    }\n    if (e instanceof SafeKeyedReadExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.key(e.index), ctx);\n    }\n  }\n  return e;\n}\nfunction ternaryTransform(e) {\n  if (!(e instanceof SafeTernaryExpr)) {\n    return e;\n  }\n  return new ParenthesizedExpr(new ConditionalExpr(new BinaryOperatorExpr(BinaryOperator.Equals, e.guard, NULL_EXPR), NULL_EXPR, e.expr));\n}\nconst ESCAPE$1 = '\\uFFFD';\nconst ELEMENT_MARKER = '#';\nconst TEMPLATE_MARKER = '*';\nconst TAG_CLOSE_MARKER = '/';\nconst CONTEXT_MARKER = ':';\nconst LIST_START_MARKER = '[';\nconst LIST_END_MARKER = ']';\nconst LIST_DELIMITER = '|';\nfunction extractI18nMessages(job) {\n  const i18nMessagesByContext = new Map();\n  const i18nBlocks = new Map();\n  const i18nContexts = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          const i18nMessageOp = createI18nMessage(job, op);\n          unit.create.push(i18nMessageOp);\n          i18nMessagesByContext.set(op.xref, i18nMessageOp);\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.I18nStart:\n          i18nBlocks.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  let currentIcu = null;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.IcuStart:\n          currentIcu = op;\n          OpList.remove(op);\n          const icuContext = i18nContexts.get(op.context);\n          if (icuContext.contextKind !== I18nContextKind.Icu) {\n            continue;\n          }\n          const i18nBlock = i18nBlocks.get(icuContext.i18nBlock);\n          if (i18nBlock.context === icuContext.xref) {\n            continue;\n          }\n          const rootI18nBlock = i18nBlocks.get(i18nBlock.root);\n          const rootMessage = i18nMessagesByContext.get(rootI18nBlock.context);\n          if (rootMessage === undefined) {\n            throw Error('AssertionError: ICU sub-message should belong to a root message.');\n          }\n          const subMessage = i18nMessagesByContext.get(icuContext.xref);\n          subMessage.messagePlaceholder = op.messagePlaceholder;\n          rootMessage.subMessages.push(subMessage.xref);\n          break;\n        case OpKind.IcuEnd:\n          currentIcu = null;\n          OpList.remove(op);\n          break;\n        case OpKind.IcuPlaceholder:\n          if (currentIcu === null || currentIcu.context == null) {\n            throw Error('AssertionError: Unexpected ICU placeholder outside of i18n context');\n          }\n          const msg = i18nMessagesByContext.get(currentIcu.context);\n          msg.postprocessingParams.set(op.name, literal(formatIcuPlaceholder(op)));\n          OpList.remove(op);\n          break;\n      }\n    }\n  }\n}\nfunction createI18nMessage(job, context, messagePlaceholder) {\n  let formattedParams = formatParams(context.params);\n  const formattedPostprocessingParams = formatParams(context.postprocessingParams);\n  let needsPostprocessing = [...context.params.values()].some(v => v.length > 1);\n  return createI18nMessageOp(job.allocateXrefId(), context.xref, context.i18nBlock, context.message, null, formattedParams, formattedPostprocessingParams, needsPostprocessing);\n}\nfunction formatIcuPlaceholder(op) {\n  if (op.strings.length !== op.expressionPlaceholders.length + 1) {\n    throw Error(`AssertionError: Invalid ICU placeholder with ${op.strings.length} strings and ${op.expressionPlaceholders.length} expressions`);\n  }\n  const values = op.expressionPlaceholders.map(formatValue);\n  return op.strings.flatMap((str, i) => [str, values[i] || '']).join('');\n}\nfunction formatParams(params) {\n  const formattedParams = new Map();\n  for (const [placeholder, placeholderValues] of params) {\n    const serializedValues = formatParamValues(placeholderValues);\n    if (serializedValues !== null) {\n      formattedParams.set(placeholder, literal(serializedValues));\n    }\n  }\n  return formattedParams;\n}\nfunction formatParamValues(values) {\n  if (values.length === 0) {\n    return null;\n  }\n  const serializedValues = values.map(value => formatValue(value));\n  return serializedValues.length === 1 ? serializedValues[0] : `${LIST_START_MARKER}${serializedValues.join(LIST_DELIMITER)}${LIST_END_MARKER}`;\n}\nfunction formatValue(value) {\n  if (value.flags & I18nParamValueFlags.ElementTag && value.flags & I18nParamValueFlags.TemplateTag) {\n    if (typeof value.value !== 'object') {\n      throw Error('AssertionError: Expected i18n param value to have an element and template slot');\n    }\n    const elementValue = formatValue({\n      ...value,\n      value: value.value.element,\n      flags: value.flags & ~I18nParamValueFlags.TemplateTag\n    });\n    const templateValue = formatValue({\n      ...value,\n      value: value.value.template,\n      flags: value.flags & ~I18nParamValueFlags.ElementTag\n    });\n    if (value.flags & I18nParamValueFlags.OpenTag && value.flags & I18nParamValueFlags.CloseTag) {\n      return `${templateValue}${elementValue}${templateValue}`;\n    }\n    return value.flags & I18nParamValueFlags.CloseTag ? `${elementValue}${templateValue}` : `${templateValue}${elementValue}`;\n  }\n  if (value.flags & I18nParamValueFlags.OpenTag && value.flags & I18nParamValueFlags.CloseTag) {\n    return `${formatValue({\n      ...value,\n      flags: value.flags & ~I18nParamValueFlags.CloseTag\n    })}${formatValue({\n      ...value,\n      flags: value.flags & ~I18nParamValueFlags.OpenTag\n    })}`;\n  }\n  if (value.flags === I18nParamValueFlags.None) {\n    return `${value.value}`;\n  }\n  let tagMarker = '';\n  let closeMarker = '';\n  if (value.flags & I18nParamValueFlags.ElementTag) {\n    tagMarker = ELEMENT_MARKER;\n  } else if (value.flags & I18nParamValueFlags.TemplateTag) {\n    tagMarker = TEMPLATE_MARKER;\n  }\n  if (tagMarker !== '') {\n    closeMarker = value.flags & I18nParamValueFlags.CloseTag ? TAG_CLOSE_MARKER : '';\n  }\n  const context = value.subTemplateIndex === null ? '' : `${CONTEXT_MARKER}${value.subTemplateIndex}`;\n  return `${ESCAPE$1}${closeMarker}${tagMarker}${value.value}${context}${ESCAPE$1}`;\n}\nfunction generateAdvance(job) {\n  for (const unit of job.units) {\n    const slotMap = new Map();\n    for (const op of unit.create) {\n      if (!hasConsumesSlotTrait(op)) {\n        continue;\n      } else if (op.handle.slot === null) {\n        throw new Error(`AssertionError: expected slots to have been allocated before generating advance() calls`);\n      }\n      slotMap.set(op.xref, op.handle.slot);\n    }\n    let slotContext = 0;\n    for (const op of unit.update) {\n      let consumer = null;\n      if (hasDependsOnSlotContextTrait(op)) {\n        consumer = op;\n      } else {\n        visitExpressionsInOp(op, expr => {\n          if (consumer === null && hasDependsOnSlotContextTrait(expr)) {\n            consumer = expr;\n          }\n        });\n      }\n      if (consumer === null) {\n        continue;\n      }\n      if (!slotMap.has(consumer.target)) {\n        throw new Error(`AssertionError: reference to unknown slot for target ${consumer.target}`);\n      }\n      const slot = slotMap.get(consumer.target);\n      if (slotContext !== slot) {\n        const delta = slot - slotContext;\n        if (delta < 0) {\n          throw new Error(`AssertionError: slot counter should never need to move backwards`);\n        }\n        OpList.insertBefore(createAdvanceOp(delta, consumer.sourceSpan), op);\n        slotContext = slot;\n      }\n    }\n  }\n}\nfunction generateLocalLetReferences(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.StoreLet) {\n        continue;\n      }\n      const variable = {\n        kind: SemanticVariableKind.Identifier,\n        name: null,\n        identifier: op.declaredName,\n        local: true\n      };\n      OpList.replace(op, createVariableOp(job.allocateXrefId(), variable, new StoreLetExpr(op.target, op.value, op.sourceSpan), VariableFlags.None));\n    }\n  }\n}\nfunction generateProjectionDefs(job) {\n  const share = job.compatibility === CompatibilityMode.TemplateDefinitionBuilder;\n  const selectors = [];\n  let projectionSlotIndex = 0;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Projection) {\n        selectors.push(op.selector);\n        op.projectionSlotIndex = projectionSlotIndex++;\n      }\n    }\n  }\n  if (selectors.length > 0) {\n    let defExpr = null;\n    if (selectors.length > 1 || selectors[0] !== '*') {\n      const def = selectors.map(s => s === '*' ? s : parseSelectorToR3Selector(s));\n      defExpr = job.pool.getConstLiteral(literalOrArrayLiteral(def), share);\n    }\n    job.contentSelectors = job.pool.getConstLiteral(literalOrArrayLiteral(selectors), share);\n    job.root.create.prepend([createProjectionDefOp(defExpr)]);\n  }\n}\nfunction generateVariables(job) {\n  recursivelyProcessView(job.root, null);\n}\nfunction recursivelyProcessView(view, parentScope) {\n  const scope = getScopeForView(view, parentScope);\n  for (const op of view.create) {\n    switch (op.kind) {\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        recursivelyProcessView(view.job.views.get(op.xref), scope);\n        break;\n      case OpKind.Projection:\n        if (op.fallbackView !== null) {\n          recursivelyProcessView(view.job.views.get(op.fallbackView), scope);\n        }\n        break;\n      case OpKind.RepeaterCreate:\n        recursivelyProcessView(view.job.views.get(op.xref), scope);\n        if (op.emptyView) {\n          recursivelyProcessView(view.job.views.get(op.emptyView), scope);\n        }\n        if (op.trackByOps !== null) {\n          op.trackByOps.prepend(generateVariablesInScopeForView(view, scope, false));\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        op.handlerOps.prepend(generateVariablesInScopeForView(view, scope, true));\n        break;\n    }\n  }\n  view.update.prepend(generateVariablesInScopeForView(view, scope, false));\n}\nfunction getScopeForView(view, parent) {\n  const scope = {\n    view: view.xref,\n    viewContextVariable: {\n      kind: SemanticVariableKind.Context,\n      name: null,\n      view: view.xref\n    },\n    contextVariables: new Map(),\n    aliases: view.aliases,\n    references: [],\n    letDeclarations: [],\n    parent\n  };\n  for (const identifier of view.contextVariables.keys()) {\n    scope.contextVariables.set(identifier, {\n      kind: SemanticVariableKind.Identifier,\n      name: null,\n      identifier,\n      local: false\n    });\n  }\n  for (const op of view.create) {\n    switch (op.kind) {\n      case OpKind.ElementStart:\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        if (!Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: expected localRefs to be an array`);\n        }\n        for (let offset = 0; offset < op.localRefs.length; offset++) {\n          scope.references.push({\n            name: op.localRefs[offset].name,\n            targetId: op.xref,\n            targetSlot: op.handle,\n            offset,\n            variable: {\n              kind: SemanticVariableKind.Identifier,\n              name: null,\n              identifier: op.localRefs[offset].name,\n              local: false\n            }\n          });\n        }\n        break;\n      case OpKind.DeclareLet:\n        scope.letDeclarations.push({\n          targetId: op.xref,\n          targetSlot: op.handle,\n          variable: {\n            kind: SemanticVariableKind.Identifier,\n            name: null,\n            identifier: op.declaredName,\n            local: false\n          }\n        });\n        break;\n    }\n  }\n  return scope;\n}\nfunction generateVariablesInScopeForView(view, scope, isCallback) {\n  const newOps = [];\n  if (scope.view !== view.xref) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), scope.viewContextVariable, new NextContextExpr(), VariableFlags.None));\n  }\n  const scopeView = view.job.views.get(scope.view);\n  for (const [name, value] of scopeView.contextVariables) {\n    const context = new ContextExpr(scope.view);\n    const variable = value === CTX_REF ? context : new ReadPropExpr(context, value);\n    newOps.push(createVariableOp(view.job.allocateXrefId(), scope.contextVariables.get(name), variable, VariableFlags.None));\n  }\n  for (const alias of scopeView.aliases) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), alias, alias.expression.clone(), VariableFlags.AlwaysInline));\n  }\n  for (const ref of scope.references) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), ref.variable, new ReferenceExpr(ref.targetId, ref.targetSlot, ref.offset), VariableFlags.None));\n  }\n  if (scope.view !== view.xref || isCallback) {\n    for (const decl of scope.letDeclarations) {\n      newOps.push(createVariableOp(view.job.allocateXrefId(), decl.variable, new ContextLetReferenceExpr(decl.targetId, decl.targetSlot), VariableFlags.None));\n    }\n  }\n  if (scope.parent !== null) {\n    newOps.push(...generateVariablesInScopeForView(view, scope.parent, false));\n  }\n  return newOps;\n}\nfunction collectConstExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (!(expr instanceof ConstCollectedExpr)) {\n          return expr;\n        }\n        return literal(job.addConst(expr.expr));\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nconst STYLE_DOT = 'style.';\nconst CLASS_DOT = 'class.';\nconst STYLE_BANG = 'style!';\nconst CLASS_BANG = 'class!';\nconst BANG_IMPORTANT = '!important';\nfunction parseHostStyleProperties(job) {\n  for (const op of job.root.update) {\n    if (!(op.kind === OpKind.Binding && op.bindingKind === BindingKind.Property)) {\n      continue;\n    }\n    if (op.name.endsWith(BANG_IMPORTANT)) {\n      op.name = op.name.substring(0, op.name.length - BANG_IMPORTANT.length);\n    }\n    if (op.name.startsWith(STYLE_DOT)) {\n      op.bindingKind = BindingKind.StyleProperty;\n      op.name = op.name.substring(STYLE_DOT.length);\n      if (!isCssCustomProperty(op.name)) {\n        op.name = hyphenate$1(op.name);\n      }\n      const {\n        property,\n        suffix\n      } = parseProperty(op.name);\n      op.name = property;\n      op.unit = suffix;\n    } else if (op.name.startsWith(STYLE_BANG)) {\n      op.bindingKind = BindingKind.StyleProperty;\n      op.name = 'style';\n    } else if (op.name.startsWith(CLASS_DOT)) {\n      op.bindingKind = BindingKind.ClassName;\n      op.name = parseProperty(op.name.substring(CLASS_DOT.length)).property;\n    } else if (op.name.startsWith(CLASS_BANG)) {\n      op.bindingKind = BindingKind.ClassName;\n      op.name = parseProperty(op.name.substring(CLASS_BANG.length)).property;\n    }\n  }\n}\nfunction isCssCustomProperty(name) {\n  return name.startsWith('--');\n}\nfunction hyphenate$1(value) {\n  return value.replace(/[a-z][A-Z]/g, v => {\n    return v.charAt(0) + '-' + v.charAt(1);\n  }).toLowerCase();\n}\nfunction parseProperty(name) {\n  const overrideIndex = name.indexOf('!important');\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n  }\n  let suffix = null;\n  let property = name;\n  const unitIndex = name.lastIndexOf('.');\n  if (unitIndex > 0) {\n    suffix = name.slice(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n  return {\n    property,\n    suffix\n  };\n}\nfunction mapLiteral(obj, quoted = false) {\n  return literalMap(Object.keys(obj).map(key => ({\n    key,\n    quoted,\n    value: obj[key]\n  })));\n}\nclass IcuSerializerVisitor {\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    return result;\n  }\n  visitTagPlaceholder(ph) {\n    return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitPlaceholder(ph) {\n    return this.formatPh(ph.name);\n  }\n  visitBlockPlaceholder(ph) {\n    return `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this.formatPh(ph.name);\n  }\n  formatPh(value) {\n    return `{${formatI18nPlaceholderName(value, false)}}`;\n  }\n}\nconst serializer = new IcuSerializerVisitor();\nfunction serializeIcuNode(icu) {\n  return icu.visit(serializer);\n}\nclass NodeWithI18n {\n  sourceSpan;\n  i18n;\n  constructor(sourceSpan, i18n) {\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n}\nclass Text extends NodeWithI18n {\n  value;\n  tokens;\n  constructor(value, sourceSpan, tokens, i18n) {\n    super(sourceSpan, i18n);\n    this.value = value;\n    this.tokens = tokens;\n  }\n  visit(visitor, context) {\n    return visitor.visitText(this, context);\n  }\n}\nclass Expansion extends NodeWithI18n {\n  switchValue;\n  type;\n  cases;\n  switchValueSourceSpan;\n  constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n    super(sourceSpan, i18n);\n    this.switchValue = switchValue;\n    this.type = type;\n    this.cases = cases;\n    this.switchValueSourceSpan = switchValueSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitExpansion(this, context);\n  }\n}\nclass ExpansionCase {\n  value;\n  expression;\n  sourceSpan;\n  valueSourceSpan;\n  expSourceSpan;\n  constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n    this.value = value;\n    this.expression = expression;\n    this.sourceSpan = sourceSpan;\n    this.valueSourceSpan = valueSourceSpan;\n    this.expSourceSpan = expSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\nclass Attribute extends NodeWithI18n {\n  name;\n  value;\n  keySpan;\n  valueSpan;\n  valueTokens;\n  constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.value = value;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.valueTokens = valueTokens;\n  }\n  visit(visitor, context) {\n    return visitor.visitAttribute(this, context);\n  }\n}\nclass Element extends NodeWithI18n {\n  name;\n  attrs;\n  directives;\n  children;\n  isSelfClosing;\n  startSourceSpan;\n  endSourceSpan;\n  isVoid;\n  constructor(name, attrs, directives, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan = null, isVoid, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.attrs = attrs;\n    this.directives = directives;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.isVoid = isVoid;\n  }\n  visit(visitor, context) {\n    return visitor.visitElement(this, context);\n  }\n}\nclass Comment {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitComment(this, context);\n  }\n}\nclass Block extends NodeWithI18n {\n  name;\n  parameters;\n  children;\n  nameSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, parameters, children, sourceSpan, nameSpan, startSourceSpan, endSourceSpan = null, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.parameters = parameters;\n    this.children = children;\n    this.nameSpan = nameSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlock(this, context);\n  }\n}\nclass Component extends NodeWithI18n {\n  componentName;\n  tagName;\n  fullName;\n  attrs;\n  directives;\n  children;\n  isSelfClosing;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(componentName, tagName, fullName, attrs, directives, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {\n    super(sourceSpan, i18n);\n    this.componentName = componentName;\n    this.tagName = tagName;\n    this.fullName = fullName;\n    this.attrs = attrs;\n    this.directives = directives;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitComponent(this, context);\n  }\n}\nclass Directive {\n  name;\n  attrs;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, attrs, sourceSpan, startSourceSpan, endSourceSpan = null) {\n    this.name = name;\n    this.attrs = attrs;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitDirective(this, context);\n  }\n}\nclass BlockParameter {\n  expression;\n  sourceSpan;\n  constructor(expression, sourceSpan) {\n    this.expression = expression;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlockParameter(this, context);\n  }\n}\nclass LetDeclaration {\n  name;\n  value;\n  sourceSpan;\n  nameSpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, nameSpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitLetDeclaration(this, context);\n  }\n}\nfunction visitAll(visitor, nodes, context = null) {\n  const result = [];\n  const visit = visitor.visit ? ast => visitor.visit(ast, context) || ast.visit(visitor, context) : ast => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\nclass RecursiveVisitor {\n  constructor() {}\n  visitElement(ast, context) {\n    this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.directives);\n      visit(ast.children);\n    });\n  }\n  visitAttribute(ast, context) {}\n  visitText(ast, context) {}\n  visitComment(ast, context) {}\n  visitExpansion(ast, context) {\n    return this.visitChildren(context, visit => {\n      visit(ast.cases);\n    });\n  }\n  visitExpansionCase(ast, context) {}\n  visitBlock(block, context) {\n    this.visitChildren(context, visit => {\n      visit(block.parameters);\n      visit(block.children);\n    });\n  }\n  visitBlockParameter(ast, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this.visitChildren(context, visit => {\n      visit(component.attrs);\n      visit(component.children);\n    });\n  }\n  visitDirective(directive, context) {\n    this.visitChildren(context, visit => {\n      visit(directive.attrs);\n    });\n  }\n  visitChildren(context, cb) {\n    let results = [];\n    let t = this;\n    function visit(children) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\nconst NAMED_ENTITIES = {\n  'AElig': '\\u00C6',\n  'AMP': '\\u0026',\n  'amp': '\\u0026',\n  'Aacute': '\\u00C1',\n  'Abreve': '\\u0102',\n  'Acirc': '\\u00C2',\n  'Acy': '\\u0410',\n  'Afr': '\\uD835\\uDD04',\n  'Agrave': '\\u00C0',\n  'Alpha': '\\u0391',\n  'Amacr': '\\u0100',\n  'And': '\\u2A53',\n  'Aogon': '\\u0104',\n  'Aopf': '\\uD835\\uDD38',\n  'ApplyFunction': '\\u2061',\n  'af': '\\u2061',\n  'Aring': '\\u00C5',\n  'angst': '\\u00C5',\n  'Ascr': '\\uD835\\uDC9C',\n  'Assign': '\\u2254',\n  'colone': '\\u2254',\n  'coloneq': '\\u2254',\n  'Atilde': '\\u00C3',\n  'Auml': '\\u00C4',\n  'Backslash': '\\u2216',\n  'setminus': '\\u2216',\n  'setmn': '\\u2216',\n  'smallsetminus': '\\u2216',\n  'ssetmn': '\\u2216',\n  'Barv': '\\u2AE7',\n  'Barwed': '\\u2306',\n  'doublebarwedge': '\\u2306',\n  'Bcy': '\\u0411',\n  'Because': '\\u2235',\n  'becaus': '\\u2235',\n  'because': '\\u2235',\n  'Bernoullis': '\\u212C',\n  'Bscr': '\\u212C',\n  'bernou': '\\u212C',\n  'Beta': '\\u0392',\n  'Bfr': '\\uD835\\uDD05',\n  'Bopf': '\\uD835\\uDD39',\n  'Breve': '\\u02D8',\n  'breve': '\\u02D8',\n  'Bumpeq': '\\u224E',\n  'HumpDownHump': '\\u224E',\n  'bump': '\\u224E',\n  'CHcy': '\\u0427',\n  'COPY': '\\u00A9',\n  'copy': '\\u00A9',\n  'Cacute': '\\u0106',\n  'Cap': '\\u22D2',\n  'CapitalDifferentialD': '\\u2145',\n  'DD': '\\u2145',\n  'Cayleys': '\\u212D',\n  'Cfr': '\\u212D',\n  'Ccaron': '\\u010C',\n  'Ccedil': '\\u00C7',\n  'Ccirc': '\\u0108',\n  'Cconint': '\\u2230',\n  'Cdot': '\\u010A',\n  'Cedilla': '\\u00B8',\n  'cedil': '\\u00B8',\n  'CenterDot': '\\u00B7',\n  'centerdot': '\\u00B7',\n  'middot': '\\u00B7',\n  'Chi': '\\u03A7',\n  'CircleDot': '\\u2299',\n  'odot': '\\u2299',\n  'CircleMinus': '\\u2296',\n  'ominus': '\\u2296',\n  'CirclePlus': '\\u2295',\n  'oplus': '\\u2295',\n  'CircleTimes': '\\u2297',\n  'otimes': '\\u2297',\n  'ClockwiseContourIntegral': '\\u2232',\n  'cwconint': '\\u2232',\n  'CloseCurlyDoubleQuote': '\\u201D',\n  'rdquo': '\\u201D',\n  'rdquor': '\\u201D',\n  'CloseCurlyQuote': '\\u2019',\n  'rsquo': '\\u2019',\n  'rsquor': '\\u2019',\n  'Colon': '\\u2237',\n  'Proportion': '\\u2237',\n  'Colone': '\\u2A74',\n  'Congruent': '\\u2261',\n  'equiv': '\\u2261',\n  'Conint': '\\u222F',\n  'DoubleContourIntegral': '\\u222F',\n  'ContourIntegral': '\\u222E',\n  'conint': '\\u222E',\n  'oint': '\\u222E',\n  'Copf': '\\u2102',\n  'complexes': '\\u2102',\n  'Coproduct': '\\u2210',\n  'coprod': '\\u2210',\n  'CounterClockwiseContourIntegral': '\\u2233',\n  'awconint': '\\u2233',\n  'Cross': '\\u2A2F',\n  'Cscr': '\\uD835\\uDC9E',\n  'Cup': '\\u22D3',\n  'CupCap': '\\u224D',\n  'asympeq': '\\u224D',\n  'DDotrahd': '\\u2911',\n  'DJcy': '\\u0402',\n  'DScy': '\\u0405',\n  'DZcy': '\\u040F',\n  'Dagger': '\\u2021',\n  'ddagger': '\\u2021',\n  'Darr': '\\u21A1',\n  'Dashv': '\\u2AE4',\n  'DoubleLeftTee': '\\u2AE4',\n  'Dcaron': '\\u010E',\n  'Dcy': '\\u0414',\n  'Del': '\\u2207',\n  'nabla': '\\u2207',\n  'Delta': '\\u0394',\n  'Dfr': '\\uD835\\uDD07',\n  'DiacriticalAcute': '\\u00B4',\n  'acute': '\\u00B4',\n  'DiacriticalDot': '\\u02D9',\n  'dot': '\\u02D9',\n  'DiacriticalDoubleAcute': '\\u02DD',\n  'dblac': '\\u02DD',\n  'DiacriticalGrave': '\\u0060',\n  'grave': '\\u0060',\n  'DiacriticalTilde': '\\u02DC',\n  'tilde': '\\u02DC',\n  'Diamond': '\\u22C4',\n  'diam': '\\u22C4',\n  'diamond': '\\u22C4',\n  'DifferentialD': '\\u2146',\n  'dd': '\\u2146',\n  'Dopf': '\\uD835\\uDD3B',\n  'Dot': '\\u00A8',\n  'DoubleDot': '\\u00A8',\n  'die': '\\u00A8',\n  'uml': '\\u00A8',\n  'DotDot': '\\u20DC',\n  'DotEqual': '\\u2250',\n  'doteq': '\\u2250',\n  'esdot': '\\u2250',\n  'DoubleDownArrow': '\\u21D3',\n  'Downarrow': '\\u21D3',\n  'dArr': '\\u21D3',\n  'DoubleLeftArrow': '\\u21D0',\n  'Leftarrow': '\\u21D0',\n  'lArr': '\\u21D0',\n  'DoubleLeftRightArrow': '\\u21D4',\n  'Leftrightarrow': '\\u21D4',\n  'hArr': '\\u21D4',\n  'iff': '\\u21D4',\n  'DoubleLongLeftArrow': '\\u27F8',\n  'Longleftarrow': '\\u27F8',\n  'xlArr': '\\u27F8',\n  'DoubleLongLeftRightArrow': '\\u27FA',\n  'Longleftrightarrow': '\\u27FA',\n  'xhArr': '\\u27FA',\n  'DoubleLongRightArrow': '\\u27F9',\n  'Longrightarrow': '\\u27F9',\n  'xrArr': '\\u27F9',\n  'DoubleRightArrow': '\\u21D2',\n  'Implies': '\\u21D2',\n  'Rightarrow': '\\u21D2',\n  'rArr': '\\u21D2',\n  'DoubleRightTee': '\\u22A8',\n  'vDash': '\\u22A8',\n  'DoubleUpArrow': '\\u21D1',\n  'Uparrow': '\\u21D1',\n  'uArr': '\\u21D1',\n  'DoubleUpDownArrow': '\\u21D5',\n  'Updownarrow': '\\u21D5',\n  'vArr': '\\u21D5',\n  'DoubleVerticalBar': '\\u2225',\n  'par': '\\u2225',\n  'parallel': '\\u2225',\n  'shortparallel': '\\u2225',\n  'spar': '\\u2225',\n  'DownArrow': '\\u2193',\n  'ShortDownArrow': '\\u2193',\n  'darr': '\\u2193',\n  'downarrow': '\\u2193',\n  'DownArrowBar': '\\u2913',\n  'DownArrowUpArrow': '\\u21F5',\n  'duarr': '\\u21F5',\n  'DownBreve': '\\u0311',\n  'DownLeftRightVector': '\\u2950',\n  'DownLeftTeeVector': '\\u295E',\n  'DownLeftVector': '\\u21BD',\n  'leftharpoondown': '\\u21BD',\n  'lhard': '\\u21BD',\n  'DownLeftVectorBar': '\\u2956',\n  'DownRightTeeVector': '\\u295F',\n  'DownRightVector': '\\u21C1',\n  'rhard': '\\u21C1',\n  'rightharpoondown': '\\u21C1',\n  'DownRightVectorBar': '\\u2957',\n  'DownTee': '\\u22A4',\n  'top': '\\u22A4',\n  'DownTeeArrow': '\\u21A7',\n  'mapstodown': '\\u21A7',\n  'Dscr': '\\uD835\\uDC9F',\n  'Dstrok': '\\u0110',\n  'ENG': '\\u014A',\n  'ETH': '\\u00D0',\n  'Eacute': '\\u00C9',\n  'Ecaron': '\\u011A',\n  'Ecirc': '\\u00CA',\n  'Ecy': '\\u042D',\n  'Edot': '\\u0116',\n  'Efr': '\\uD835\\uDD08',\n  'Egrave': '\\u00C8',\n  'Element': '\\u2208',\n  'in': '\\u2208',\n  'isin': '\\u2208',\n  'isinv': '\\u2208',\n  'Emacr': '\\u0112',\n  'EmptySmallSquare': '\\u25FB',\n  'EmptyVerySmallSquare': '\\u25AB',\n  'Eogon': '\\u0118',\n  'Eopf': '\\uD835\\uDD3C',\n  'Epsilon': '\\u0395',\n  'Equal': '\\u2A75',\n  'EqualTilde': '\\u2242',\n  'eqsim': '\\u2242',\n  'esim': '\\u2242',\n  'Equilibrium': '\\u21CC',\n  'rightleftharpoons': '\\u21CC',\n  'rlhar': '\\u21CC',\n  'Escr': '\\u2130',\n  'expectation': '\\u2130',\n  'Esim': '\\u2A73',\n  'Eta': '\\u0397',\n  'Euml': '\\u00CB',\n  'Exists': '\\u2203',\n  'exist': '\\u2203',\n  'ExponentialE': '\\u2147',\n  'ee': '\\u2147',\n  'exponentiale': '\\u2147',\n  'Fcy': '\\u0424',\n  'Ffr': '\\uD835\\uDD09',\n  'FilledSmallSquare': '\\u25FC',\n  'FilledVerySmallSquare': '\\u25AA',\n  'blacksquare': '\\u25AA',\n  'squarf': '\\u25AA',\n  'squf': '\\u25AA',\n  'Fopf': '\\uD835\\uDD3D',\n  'ForAll': '\\u2200',\n  'forall': '\\u2200',\n  'Fouriertrf': '\\u2131',\n  'Fscr': '\\u2131',\n  'GJcy': '\\u0403',\n  'GT': '\\u003E',\n  'gt': '\\u003E',\n  'Gamma': '\\u0393',\n  'Gammad': '\\u03DC',\n  'Gbreve': '\\u011E',\n  'Gcedil': '\\u0122',\n  'Gcirc': '\\u011C',\n  'Gcy': '\\u0413',\n  'Gdot': '\\u0120',\n  'Gfr': '\\uD835\\uDD0A',\n  'Gg': '\\u22D9',\n  'ggg': '\\u22D9',\n  'Gopf': '\\uD835\\uDD3E',\n  'GreaterEqual': '\\u2265',\n  'ge': '\\u2265',\n  'geq': '\\u2265',\n  'GreaterEqualLess': '\\u22DB',\n  'gel': '\\u22DB',\n  'gtreqless': '\\u22DB',\n  'GreaterFullEqual': '\\u2267',\n  'gE': '\\u2267',\n  'geqq': '\\u2267',\n  'GreaterGreater': '\\u2AA2',\n  'GreaterLess': '\\u2277',\n  'gl': '\\u2277',\n  'gtrless': '\\u2277',\n  'GreaterSlantEqual': '\\u2A7E',\n  'geqslant': '\\u2A7E',\n  'ges': '\\u2A7E',\n  'GreaterTilde': '\\u2273',\n  'gsim': '\\u2273',\n  'gtrsim': '\\u2273',\n  'Gscr': '\\uD835\\uDCA2',\n  'Gt': '\\u226B',\n  'NestedGreaterGreater': '\\u226B',\n  'gg': '\\u226B',\n  'HARDcy': '\\u042A',\n  'Hacek': '\\u02C7',\n  'caron': '\\u02C7',\n  'Hat': '\\u005E',\n  'Hcirc': '\\u0124',\n  'Hfr': '\\u210C',\n  'Poincareplane': '\\u210C',\n  'HilbertSpace': '\\u210B',\n  'Hscr': '\\u210B',\n  'hamilt': '\\u210B',\n  'Hopf': '\\u210D',\n  'quaternions': '\\u210D',\n  'HorizontalLine': '\\u2500',\n  'boxh': '\\u2500',\n  'Hstrok': '\\u0126',\n  'HumpEqual': '\\u224F',\n  'bumpe': '\\u224F',\n  'bumpeq': '\\u224F',\n  'IEcy': '\\u0415',\n  'IJlig': '\\u0132',\n  'IOcy': '\\u0401',\n  'Iacute': '\\u00CD',\n  'Icirc': '\\u00CE',\n  'Icy': '\\u0418',\n  'Idot': '\\u0130',\n  'Ifr': '\\u2111',\n  'Im': '\\u2111',\n  'image': '\\u2111',\n  'imagpart': '\\u2111',\n  'Igrave': '\\u00CC',\n  'Imacr': '\\u012A',\n  'ImaginaryI': '\\u2148',\n  'ii': '\\u2148',\n  'Int': '\\u222C',\n  'Integral': '\\u222B',\n  'int': '\\u222B',\n  'Intersection': '\\u22C2',\n  'bigcap': '\\u22C2',\n  'xcap': '\\u22C2',\n  'InvisibleComma': '\\u2063',\n  'ic': '\\u2063',\n  'InvisibleTimes': '\\u2062',\n  'it': '\\u2062',\n  'Iogon': '\\u012E',\n  'Iopf': '\\uD835\\uDD40',\n  'Iota': '\\u0399',\n  'Iscr': '\\u2110',\n  'imagline': '\\u2110',\n  'Itilde': '\\u0128',\n  'Iukcy': '\\u0406',\n  'Iuml': '\\u00CF',\n  'Jcirc': '\\u0134',\n  'Jcy': '\\u0419',\n  'Jfr': '\\uD835\\uDD0D',\n  'Jopf': '\\uD835\\uDD41',\n  'Jscr': '\\uD835\\uDCA5',\n  'Jsercy': '\\u0408',\n  'Jukcy': '\\u0404',\n  'KHcy': '\\u0425',\n  'KJcy': '\\u040C',\n  'Kappa': '\\u039A',\n  'Kcedil': '\\u0136',\n  'Kcy': '\\u041A',\n  'Kfr': '\\uD835\\uDD0E',\n  'Kopf': '\\uD835\\uDD42',\n  'Kscr': '\\uD835\\uDCA6',\n  'LJcy': '\\u0409',\n  'LT': '\\u003C',\n  'lt': '\\u003C',\n  'Lacute': '\\u0139',\n  'Lambda': '\\u039B',\n  'Lang': '\\u27EA',\n  'Laplacetrf': '\\u2112',\n  'Lscr': '\\u2112',\n  'lagran': '\\u2112',\n  'Larr': '\\u219E',\n  'twoheadleftarrow': '\\u219E',\n  'Lcaron': '\\u013D',\n  'Lcedil': '\\u013B',\n  'Lcy': '\\u041B',\n  'LeftAngleBracket': '\\u27E8',\n  'lang': '\\u27E8',\n  'langle': '\\u27E8',\n  'LeftArrow': '\\u2190',\n  'ShortLeftArrow': '\\u2190',\n  'larr': '\\u2190',\n  'leftarrow': '\\u2190',\n  'slarr': '\\u2190',\n  'LeftArrowBar': '\\u21E4',\n  'larrb': '\\u21E4',\n  'LeftArrowRightArrow': '\\u21C6',\n  'leftrightarrows': '\\u21C6',\n  'lrarr': '\\u21C6',\n  'LeftCeiling': '\\u2308',\n  'lceil': '\\u2308',\n  'LeftDoubleBracket': '\\u27E6',\n  'lobrk': '\\u27E6',\n  'LeftDownTeeVector': '\\u2961',\n  'LeftDownVector': '\\u21C3',\n  'dharl': '\\u21C3',\n  'downharpoonleft': '\\u21C3',\n  'LeftDownVectorBar': '\\u2959',\n  'LeftFloor': '\\u230A',\n  'lfloor': '\\u230A',\n  'LeftRightArrow': '\\u2194',\n  'harr': '\\u2194',\n  'leftrightarrow': '\\u2194',\n  'LeftRightVector': '\\u294E',\n  'LeftTee': '\\u22A3',\n  'dashv': '\\u22A3',\n  'LeftTeeArrow': '\\u21A4',\n  'mapstoleft': '\\u21A4',\n  'LeftTeeVector': '\\u295A',\n  'LeftTriangle': '\\u22B2',\n  'vartriangleleft': '\\u22B2',\n  'vltri': '\\u22B2',\n  'LeftTriangleBar': '\\u29CF',\n  'LeftTriangleEqual': '\\u22B4',\n  'ltrie': '\\u22B4',\n  'trianglelefteq': '\\u22B4',\n  'LeftUpDownVector': '\\u2951',\n  'LeftUpTeeVector': '\\u2960',\n  'LeftUpVector': '\\u21BF',\n  'uharl': '\\u21BF',\n  'upharpoonleft': '\\u21BF',\n  'LeftUpVectorBar': '\\u2958',\n  'LeftVector': '\\u21BC',\n  'leftharpoonup': '\\u21BC',\n  'lharu': '\\u21BC',\n  'LeftVectorBar': '\\u2952',\n  'LessEqualGreater': '\\u22DA',\n  'leg': '\\u22DA',\n  'lesseqgtr': '\\u22DA',\n  'LessFullEqual': '\\u2266',\n  'lE': '\\u2266',\n  'leqq': '\\u2266',\n  'LessGreater': '\\u2276',\n  'lessgtr': '\\u2276',\n  'lg': '\\u2276',\n  'LessLess': '\\u2AA1',\n  'LessSlantEqual': '\\u2A7D',\n  'leqslant': '\\u2A7D',\n  'les': '\\u2A7D',\n  'LessTilde': '\\u2272',\n  'lesssim': '\\u2272',\n  'lsim': '\\u2272',\n  'Lfr': '\\uD835\\uDD0F',\n  'Ll': '\\u22D8',\n  'Lleftarrow': '\\u21DA',\n  'lAarr': '\\u21DA',\n  'Lmidot': '\\u013F',\n  'LongLeftArrow': '\\u27F5',\n  'longleftarrow': '\\u27F5',\n  'xlarr': '\\u27F5',\n  'LongLeftRightArrow': '\\u27F7',\n  'longleftrightarrow': '\\u27F7',\n  'xharr': '\\u27F7',\n  'LongRightArrow': '\\u27F6',\n  'longrightarrow': '\\u27F6',\n  'xrarr': '\\u27F6',\n  'Lopf': '\\uD835\\uDD43',\n  'LowerLeftArrow': '\\u2199',\n  'swarr': '\\u2199',\n  'swarrow': '\\u2199',\n  'LowerRightArrow': '\\u2198',\n  'searr': '\\u2198',\n  'searrow': '\\u2198',\n  'Lsh': '\\u21B0',\n  'lsh': '\\u21B0',\n  'Lstrok': '\\u0141',\n  'Lt': '\\u226A',\n  'NestedLessLess': '\\u226A',\n  'll': '\\u226A',\n  'Map': '\\u2905',\n  'Mcy': '\\u041C',\n  'MediumSpace': '\\u205F',\n  'Mellintrf': '\\u2133',\n  'Mscr': '\\u2133',\n  'phmmat': '\\u2133',\n  'Mfr': '\\uD835\\uDD10',\n  'MinusPlus': '\\u2213',\n  'mnplus': '\\u2213',\n  'mp': '\\u2213',\n  'Mopf': '\\uD835\\uDD44',\n  'Mu': '\\u039C',\n  'NJcy': '\\u040A',\n  'Nacute': '\\u0143',\n  'Ncaron': '\\u0147',\n  'Ncedil': '\\u0145',\n  'Ncy': '\\u041D',\n  'NegativeMediumSpace': '\\u200B',\n  'NegativeThickSpace': '\\u200B',\n  'NegativeThinSpace': '\\u200B',\n  'NegativeVeryThinSpace': '\\u200B',\n  'ZeroWidthSpace': '\\u200B',\n  'NewLine': '\\u000A',\n  'Nfr': '\\uD835\\uDD11',\n  'NoBreak': '\\u2060',\n  'NonBreakingSpace': '\\u00A0',\n  'nbsp': '\\u00A0',\n  'Nopf': '\\u2115',\n  'naturals': '\\u2115',\n  'Not': '\\u2AEC',\n  'NotCongruent': '\\u2262',\n  'nequiv': '\\u2262',\n  'NotCupCap': '\\u226D',\n  'NotDoubleVerticalBar': '\\u2226',\n  'npar': '\\u2226',\n  'nparallel': '\\u2226',\n  'nshortparallel': '\\u2226',\n  'nspar': '\\u2226',\n  'NotElement': '\\u2209',\n  'notin': '\\u2209',\n  'notinva': '\\u2209',\n  'NotEqual': '\\u2260',\n  'ne': '\\u2260',\n  'NotEqualTilde': '\\u2242\\u0338',\n  'nesim': '\\u2242\\u0338',\n  'NotExists': '\\u2204',\n  'nexist': '\\u2204',\n  'nexists': '\\u2204',\n  'NotGreater': '\\u226F',\n  'ngt': '\\u226F',\n  'ngtr': '\\u226F',\n  'NotGreaterEqual': '\\u2271',\n  'nge': '\\u2271',\n  'ngeq': '\\u2271',\n  'NotGreaterFullEqual': '\\u2267\\u0338',\n  'ngE': '\\u2267\\u0338',\n  'ngeqq': '\\u2267\\u0338',\n  'NotGreaterGreater': '\\u226B\\u0338',\n  'nGtv': '\\u226B\\u0338',\n  'NotGreaterLess': '\\u2279',\n  'ntgl': '\\u2279',\n  'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n  'ngeqslant': '\\u2A7E\\u0338',\n  'nges': '\\u2A7E\\u0338',\n  'NotGreaterTilde': '\\u2275',\n  'ngsim': '\\u2275',\n  'NotHumpDownHump': '\\u224E\\u0338',\n  'nbump': '\\u224E\\u0338',\n  'NotHumpEqual': '\\u224F\\u0338',\n  'nbumpe': '\\u224F\\u0338',\n  'NotLeftTriangle': '\\u22EA',\n  'nltri': '\\u22EA',\n  'ntriangleleft': '\\u22EA',\n  'NotLeftTriangleBar': '\\u29CF\\u0338',\n  'NotLeftTriangleEqual': '\\u22EC',\n  'nltrie': '\\u22EC',\n  'ntrianglelefteq': '\\u22EC',\n  'NotLess': '\\u226E',\n  'nless': '\\u226E',\n  'nlt': '\\u226E',\n  'NotLessEqual': '\\u2270',\n  'nle': '\\u2270',\n  'nleq': '\\u2270',\n  'NotLessGreater': '\\u2278',\n  'ntlg': '\\u2278',\n  'NotLessLess': '\\u226A\\u0338',\n  'nLtv': '\\u226A\\u0338',\n  'NotLessSlantEqual': '\\u2A7D\\u0338',\n  'nleqslant': '\\u2A7D\\u0338',\n  'nles': '\\u2A7D\\u0338',\n  'NotLessTilde': '\\u2274',\n  'nlsim': '\\u2274',\n  'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n  'NotNestedLessLess': '\\u2AA1\\u0338',\n  'NotPrecedes': '\\u2280',\n  'npr': '\\u2280',\n  'nprec': '\\u2280',\n  'NotPrecedesEqual': '\\u2AAF\\u0338',\n  'npre': '\\u2AAF\\u0338',\n  'npreceq': '\\u2AAF\\u0338',\n  'NotPrecedesSlantEqual': '\\u22E0',\n  'nprcue': '\\u22E0',\n  'NotReverseElement': '\\u220C',\n  'notni': '\\u220C',\n  'notniva': '\\u220C',\n  'NotRightTriangle': '\\u22EB',\n  'nrtri': '\\u22EB',\n  'ntriangleright': '\\u22EB',\n  'NotRightTriangleBar': '\\u29D0\\u0338',\n  'NotRightTriangleEqual': '\\u22ED',\n  'nrtrie': '\\u22ED',\n  'ntrianglerighteq': '\\u22ED',\n  'NotSquareSubset': '\\u228F\\u0338',\n  'NotSquareSubsetEqual': '\\u22E2',\n  'nsqsube': '\\u22E2',\n  'NotSquareSuperset': '\\u2290\\u0338',\n  'NotSquareSupersetEqual': '\\u22E3',\n  'nsqsupe': '\\u22E3',\n  'NotSubset': '\\u2282\\u20D2',\n  'nsubset': '\\u2282\\u20D2',\n  'vnsub': '\\u2282\\u20D2',\n  'NotSubsetEqual': '\\u2288',\n  'nsube': '\\u2288',\n  'nsubseteq': '\\u2288',\n  'NotSucceeds': '\\u2281',\n  'nsc': '\\u2281',\n  'nsucc': '\\u2281',\n  'NotSucceedsEqual': '\\u2AB0\\u0338',\n  'nsce': '\\u2AB0\\u0338',\n  'nsucceq': '\\u2AB0\\u0338',\n  'NotSucceedsSlantEqual': '\\u22E1',\n  'nsccue': '\\u22E1',\n  'NotSucceedsTilde': '\\u227F\\u0338',\n  'NotSuperset': '\\u2283\\u20D2',\n  'nsupset': '\\u2283\\u20D2',\n  'vnsup': '\\u2283\\u20D2',\n  'NotSupersetEqual': '\\u2289',\n  'nsupe': '\\u2289',\n  'nsupseteq': '\\u2289',\n  'NotTilde': '\\u2241',\n  'nsim': '\\u2241',\n  'NotTildeEqual': '\\u2244',\n  'nsime': '\\u2244',\n  'nsimeq': '\\u2244',\n  'NotTildeFullEqual': '\\u2247',\n  'ncong': '\\u2247',\n  'NotTildeTilde': '\\u2249',\n  'nap': '\\u2249',\n  'napprox': '\\u2249',\n  'NotVerticalBar': '\\u2224',\n  'nmid': '\\u2224',\n  'nshortmid': '\\u2224',\n  'nsmid': '\\u2224',\n  'Nscr': '\\uD835\\uDCA9',\n  'Ntilde': '\\u00D1',\n  'Nu': '\\u039D',\n  'OElig': '\\u0152',\n  'Oacute': '\\u00D3',\n  'Ocirc': '\\u00D4',\n  'Ocy': '\\u041E',\n  'Odblac': '\\u0150',\n  'Ofr': '\\uD835\\uDD12',\n  'Ograve': '\\u00D2',\n  'Omacr': '\\u014C',\n  'Omega': '\\u03A9',\n  'ohm': '\\u03A9',\n  'Omicron': '\\u039F',\n  'Oopf': '\\uD835\\uDD46',\n  'OpenCurlyDoubleQuote': '\\u201C',\n  'ldquo': '\\u201C',\n  'OpenCurlyQuote': '\\u2018',\n  'lsquo': '\\u2018',\n  'Or': '\\u2A54',\n  'Oscr': '\\uD835\\uDCAA',\n  'Oslash': '\\u00D8',\n  'Otilde': '\\u00D5',\n  'Otimes': '\\u2A37',\n  'Ouml': '\\u00D6',\n  'OverBar': '\\u203E',\n  'oline': '\\u203E',\n  'OverBrace': '\\u23DE',\n  'OverBracket': '\\u23B4',\n  'tbrk': '\\u23B4',\n  'OverParenthesis': '\\u23DC',\n  'PartialD': '\\u2202',\n  'part': '\\u2202',\n  'Pcy': '\\u041F',\n  'Pfr': '\\uD835\\uDD13',\n  'Phi': '\\u03A6',\n  'Pi': '\\u03A0',\n  'PlusMinus': '\\u00B1',\n  'plusmn': '\\u00B1',\n  'pm': '\\u00B1',\n  'Popf': '\\u2119',\n  'primes': '\\u2119',\n  'Pr': '\\u2ABB',\n  'Precedes': '\\u227A',\n  'pr': '\\u227A',\n  'prec': '\\u227A',\n  'PrecedesEqual': '\\u2AAF',\n  'pre': '\\u2AAF',\n  'preceq': '\\u2AAF',\n  'PrecedesSlantEqual': '\\u227C',\n  'prcue': '\\u227C',\n  'preccurlyeq': '\\u227C',\n  'PrecedesTilde': '\\u227E',\n  'precsim': '\\u227E',\n  'prsim': '\\u227E',\n  'Prime': '\\u2033',\n  'Product': '\\u220F',\n  'prod': '\\u220F',\n  'Proportional': '\\u221D',\n  'prop': '\\u221D',\n  'propto': '\\u221D',\n  'varpropto': '\\u221D',\n  'vprop': '\\u221D',\n  'Pscr': '\\uD835\\uDCAB',\n  'Psi': '\\u03A8',\n  'QUOT': '\\u0022',\n  'quot': '\\u0022',\n  'Qfr': '\\uD835\\uDD14',\n  'Qopf': '\\u211A',\n  'rationals': '\\u211A',\n  'Qscr': '\\uD835\\uDCAC',\n  'RBarr': '\\u2910',\n  'drbkarow': '\\u2910',\n  'REG': '\\u00AE',\n  'circledR': '\\u00AE',\n  'reg': '\\u00AE',\n  'Racute': '\\u0154',\n  'Rang': '\\u27EB',\n  'Rarr': '\\u21A0',\n  'twoheadrightarrow': '\\u21A0',\n  'Rarrtl': '\\u2916',\n  'Rcaron': '\\u0158',\n  'Rcedil': '\\u0156',\n  'Rcy': '\\u0420',\n  'Re': '\\u211C',\n  'Rfr': '\\u211C',\n  'real': '\\u211C',\n  'realpart': '\\u211C',\n  'ReverseElement': '\\u220B',\n  'SuchThat': '\\u220B',\n  'ni': '\\u220B',\n  'niv': '\\u220B',\n  'ReverseEquilibrium': '\\u21CB',\n  'leftrightharpoons': '\\u21CB',\n  'lrhar': '\\u21CB',\n  'ReverseUpEquilibrium': '\\u296F',\n  'duhar': '\\u296F',\n  'Rho': '\\u03A1',\n  'RightAngleBracket': '\\u27E9',\n  'rang': '\\u27E9',\n  'rangle': '\\u27E9',\n  'RightArrow': '\\u2192',\n  'ShortRightArrow': '\\u2192',\n  'rarr': '\\u2192',\n  'rightarrow': '\\u2192',\n  'srarr': '\\u2192',\n  'RightArrowBar': '\\u21E5',\n  'rarrb': '\\u21E5',\n  'RightArrowLeftArrow': '\\u21C4',\n  'rightleftarrows': '\\u21C4',\n  'rlarr': '\\u21C4',\n  'RightCeiling': '\\u2309',\n  'rceil': '\\u2309',\n  'RightDoubleBracket': '\\u27E7',\n  'robrk': '\\u27E7',\n  'RightDownTeeVector': '\\u295D',\n  'RightDownVector': '\\u21C2',\n  'dharr': '\\u21C2',\n  'downharpoonright': '\\u21C2',\n  'RightDownVectorBar': '\\u2955',\n  'RightFloor': '\\u230B',\n  'rfloor': '\\u230B',\n  'RightTee': '\\u22A2',\n  'vdash': '\\u22A2',\n  'RightTeeArrow': '\\u21A6',\n  'map': '\\u21A6',\n  'mapsto': '\\u21A6',\n  'RightTeeVector': '\\u295B',\n  'RightTriangle': '\\u22B3',\n  'vartriangleright': '\\u22B3',\n  'vrtri': '\\u22B3',\n  'RightTriangleBar': '\\u29D0',\n  'RightTriangleEqual': '\\u22B5',\n  'rtrie': '\\u22B5',\n  'trianglerighteq': '\\u22B5',\n  'RightUpDownVector': '\\u294F',\n  'RightUpTeeVector': '\\u295C',\n  'RightUpVector': '\\u21BE',\n  'uharr': '\\u21BE',\n  'upharpoonright': '\\u21BE',\n  'RightUpVectorBar': '\\u2954',\n  'RightVector': '\\u21C0',\n  'rharu': '\\u21C0',\n  'rightharpoonup': '\\u21C0',\n  'RightVectorBar': '\\u2953',\n  'Ropf': '\\u211D',\n  'reals': '\\u211D',\n  'RoundImplies': '\\u2970',\n  'Rrightarrow': '\\u21DB',\n  'rAarr': '\\u21DB',\n  'Rscr': '\\u211B',\n  'realine': '\\u211B',\n  'Rsh': '\\u21B1',\n  'rsh': '\\u21B1',\n  'RuleDelayed': '\\u29F4',\n  'SHCHcy': '\\u0429',\n  'SHcy': '\\u0428',\n  'SOFTcy': '\\u042C',\n  'Sacute': '\\u015A',\n  'Sc': '\\u2ABC',\n  'Scaron': '\\u0160',\n  'Scedil': '\\u015E',\n  'Scirc': '\\u015C',\n  'Scy': '\\u0421',\n  'Sfr': '\\uD835\\uDD16',\n  'ShortUpArrow': '\\u2191',\n  'UpArrow': '\\u2191',\n  'uarr': '\\u2191',\n  'uparrow': '\\u2191',\n  'Sigma': '\\u03A3',\n  'SmallCircle': '\\u2218',\n  'compfn': '\\u2218',\n  'Sopf': '\\uD835\\uDD4A',\n  'Sqrt': '\\u221A',\n  'radic': '\\u221A',\n  'Square': '\\u25A1',\n  'squ': '\\u25A1',\n  'square': '\\u25A1',\n  'SquareIntersection': '\\u2293',\n  'sqcap': '\\u2293',\n  'SquareSubset': '\\u228F',\n  'sqsub': '\\u228F',\n  'sqsubset': '\\u228F',\n  'SquareSubsetEqual': '\\u2291',\n  'sqsube': '\\u2291',\n  'sqsubseteq': '\\u2291',\n  'SquareSuperset': '\\u2290',\n  'sqsup': '\\u2290',\n  'sqsupset': '\\u2290',\n  'SquareSupersetEqual': '\\u2292',\n  'sqsupe': '\\u2292',\n  'sqsupseteq': '\\u2292',\n  'SquareUnion': '\\u2294',\n  'sqcup': '\\u2294',\n  'Sscr': '\\uD835\\uDCAE',\n  'Star': '\\u22C6',\n  'sstarf': '\\u22C6',\n  'Sub': '\\u22D0',\n  'Subset': '\\u22D0',\n  'SubsetEqual': '\\u2286',\n  'sube': '\\u2286',\n  'subseteq': '\\u2286',\n  'Succeeds': '\\u227B',\n  'sc': '\\u227B',\n  'succ': '\\u227B',\n  'SucceedsEqual': '\\u2AB0',\n  'sce': '\\u2AB0',\n  'succeq': '\\u2AB0',\n  'SucceedsSlantEqual': '\\u227D',\n  'sccue': '\\u227D',\n  'succcurlyeq': '\\u227D',\n  'SucceedsTilde': '\\u227F',\n  'scsim': '\\u227F',\n  'succsim': '\\u227F',\n  'Sum': '\\u2211',\n  'sum': '\\u2211',\n  'Sup': '\\u22D1',\n  'Supset': '\\u22D1',\n  'Superset': '\\u2283',\n  'sup': '\\u2283',\n  'supset': '\\u2283',\n  'SupersetEqual': '\\u2287',\n  'supe': '\\u2287',\n  'supseteq': '\\u2287',\n  'THORN': '\\u00DE',\n  'TRADE': '\\u2122',\n  'trade': '\\u2122',\n  'TSHcy': '\\u040B',\n  'TScy': '\\u0426',\n  'Tab': '\\u0009',\n  'Tau': '\\u03A4',\n  'Tcaron': '\\u0164',\n  'Tcedil': '\\u0162',\n  'Tcy': '\\u0422',\n  'Tfr': '\\uD835\\uDD17',\n  'Therefore': '\\u2234',\n  'there4': '\\u2234',\n  'therefore': '\\u2234',\n  'Theta': '\\u0398',\n  'ThickSpace': '\\u205F\\u200A',\n  'ThinSpace': '\\u2009',\n  'thinsp': '\\u2009',\n  'Tilde': '\\u223C',\n  'sim': '\\u223C',\n  'thicksim': '\\u223C',\n  'thksim': '\\u223C',\n  'TildeEqual': '\\u2243',\n  'sime': '\\u2243',\n  'simeq': '\\u2243',\n  'TildeFullEqual': '\\u2245',\n  'cong': '\\u2245',\n  'TildeTilde': '\\u2248',\n  'ap': '\\u2248',\n  'approx': '\\u2248',\n  'asymp': '\\u2248',\n  'thickapprox': '\\u2248',\n  'thkap': '\\u2248',\n  'Topf': '\\uD835\\uDD4B',\n  'TripleDot': '\\u20DB',\n  'tdot': '\\u20DB',\n  'Tscr': '\\uD835\\uDCAF',\n  'Tstrok': '\\u0166',\n  'Uacute': '\\u00DA',\n  'Uarr': '\\u219F',\n  'Uarrocir': '\\u2949',\n  'Ubrcy': '\\u040E',\n  'Ubreve': '\\u016C',\n  'Ucirc': '\\u00DB',\n  'Ucy': '\\u0423',\n  'Udblac': '\\u0170',\n  'Ufr': '\\uD835\\uDD18',\n  'Ugrave': '\\u00D9',\n  'Umacr': '\\u016A',\n  'UnderBar': '\\u005F',\n  'lowbar': '\\u005F',\n  'UnderBrace': '\\u23DF',\n  'UnderBracket': '\\u23B5',\n  'bbrk': '\\u23B5',\n  'UnderParenthesis': '\\u23DD',\n  'Union': '\\u22C3',\n  'bigcup': '\\u22C3',\n  'xcup': '\\u22C3',\n  'UnionPlus': '\\u228E',\n  'uplus': '\\u228E',\n  'Uogon': '\\u0172',\n  'Uopf': '\\uD835\\uDD4C',\n  'UpArrowBar': '\\u2912',\n  'UpArrowDownArrow': '\\u21C5',\n  'udarr': '\\u21C5',\n  'UpDownArrow': '\\u2195',\n  'updownarrow': '\\u2195',\n  'varr': '\\u2195',\n  'UpEquilibrium': '\\u296E',\n  'udhar': '\\u296E',\n  'UpTee': '\\u22A5',\n  'bot': '\\u22A5',\n  'bottom': '\\u22A5',\n  'perp': '\\u22A5',\n  'UpTeeArrow': '\\u21A5',\n  'mapstoup': '\\u21A5',\n  'UpperLeftArrow': '\\u2196',\n  'nwarr': '\\u2196',\n  'nwarrow': '\\u2196',\n  'UpperRightArrow': '\\u2197',\n  'nearr': '\\u2197',\n  'nearrow': '\\u2197',\n  'Upsi': '\\u03D2',\n  'upsih': '\\u03D2',\n  'Upsilon': '\\u03A5',\n  'Uring': '\\u016E',\n  'Uscr': '\\uD835\\uDCB0',\n  'Utilde': '\\u0168',\n  'Uuml': '\\u00DC',\n  'VDash': '\\u22AB',\n  'Vbar': '\\u2AEB',\n  'Vcy': '\\u0412',\n  'Vdash': '\\u22A9',\n  'Vdashl': '\\u2AE6',\n  'Vee': '\\u22C1',\n  'bigvee': '\\u22C1',\n  'xvee': '\\u22C1',\n  'Verbar': '\\u2016',\n  'Vert': '\\u2016',\n  'VerticalBar': '\\u2223',\n  'mid': '\\u2223',\n  'shortmid': '\\u2223',\n  'smid': '\\u2223',\n  'VerticalLine': '\\u007C',\n  'verbar': '\\u007C',\n  'vert': '\\u007C',\n  'VerticalSeparator': '\\u2758',\n  'VerticalTilde': '\\u2240',\n  'wr': '\\u2240',\n  'wreath': '\\u2240',\n  'VeryThinSpace': '\\u200A',\n  'hairsp': '\\u200A',\n  'Vfr': '\\uD835\\uDD19',\n  'Vopf': '\\uD835\\uDD4D',\n  'Vscr': '\\uD835\\uDCB1',\n  'Vvdash': '\\u22AA',\n  'Wcirc': '\\u0174',\n  'Wedge': '\\u22C0',\n  'bigwedge': '\\u22C0',\n  'xwedge': '\\u22C0',\n  'Wfr': '\\uD835\\uDD1A',\n  'Wopf': '\\uD835\\uDD4E',\n  'Wscr': '\\uD835\\uDCB2',\n  'Xfr': '\\uD835\\uDD1B',\n  'Xi': '\\u039E',\n  'Xopf': '\\uD835\\uDD4F',\n  'Xscr': '\\uD835\\uDCB3',\n  'YAcy': '\\u042F',\n  'YIcy': '\\u0407',\n  'YUcy': '\\u042E',\n  'Yacute': '\\u00DD',\n  'Ycirc': '\\u0176',\n  'Ycy': '\\u042B',\n  'Yfr': '\\uD835\\uDD1C',\n  'Yopf': '\\uD835\\uDD50',\n  'Yscr': '\\uD835\\uDCB4',\n  'Yuml': '\\u0178',\n  'ZHcy': '\\u0416',\n  'Zacute': '\\u0179',\n  'Zcaron': '\\u017D',\n  'Zcy': '\\u0417',\n  'Zdot': '\\u017B',\n  'Zeta': '\\u0396',\n  'Zfr': '\\u2128',\n  'zeetrf': '\\u2128',\n  'Zopf': '\\u2124',\n  'integers': '\\u2124',\n  'Zscr': '\\uD835\\uDCB5',\n  'aacute': '\\u00E1',\n  'abreve': '\\u0103',\n  'ac': '\\u223E',\n  'mstpos': '\\u223E',\n  'acE': '\\u223E\\u0333',\n  'acd': '\\u223F',\n  'acirc': '\\u00E2',\n  'acy': '\\u0430',\n  'aelig': '\\u00E6',\n  'afr': '\\uD835\\uDD1E',\n  'agrave': '\\u00E0',\n  'alefsym': '\\u2135',\n  'aleph': '\\u2135',\n  'alpha': '\\u03B1',\n  'amacr': '\\u0101',\n  'amalg': '\\u2A3F',\n  'and': '\\u2227',\n  'wedge': '\\u2227',\n  'andand': '\\u2A55',\n  'andd': '\\u2A5C',\n  'andslope': '\\u2A58',\n  'andv': '\\u2A5A',\n  'ang': '\\u2220',\n  'angle': '\\u2220',\n  'ange': '\\u29A4',\n  'angmsd': '\\u2221',\n  'measuredangle': '\\u2221',\n  'angmsdaa': '\\u29A8',\n  'angmsdab': '\\u29A9',\n  'angmsdac': '\\u29AA',\n  'angmsdad': '\\u29AB',\n  'angmsdae': '\\u29AC',\n  'angmsdaf': '\\u29AD',\n  'angmsdag': '\\u29AE',\n  'angmsdah': '\\u29AF',\n  'angrt': '\\u221F',\n  'angrtvb': '\\u22BE',\n  'angrtvbd': '\\u299D',\n  'angsph': '\\u2222',\n  'angzarr': '\\u237C',\n  'aogon': '\\u0105',\n  'aopf': '\\uD835\\uDD52',\n  'apE': '\\u2A70',\n  'apacir': '\\u2A6F',\n  'ape': '\\u224A',\n  'approxeq': '\\u224A',\n  'apid': '\\u224B',\n  'apos': '\\u0027',\n  'aring': '\\u00E5',\n  'ascr': '\\uD835\\uDCB6',\n  'ast': '\\u002A',\n  'midast': '\\u002A',\n  'atilde': '\\u00E3',\n  'auml': '\\u00E4',\n  'awint': '\\u2A11',\n  'bNot': '\\u2AED',\n  'backcong': '\\u224C',\n  'bcong': '\\u224C',\n  'backepsilon': '\\u03F6',\n  'bepsi': '\\u03F6',\n  'backprime': '\\u2035',\n  'bprime': '\\u2035',\n  'backsim': '\\u223D',\n  'bsim': '\\u223D',\n  'backsimeq': '\\u22CD',\n  'bsime': '\\u22CD',\n  'barvee': '\\u22BD',\n  'barwed': '\\u2305',\n  'barwedge': '\\u2305',\n  'bbrktbrk': '\\u23B6',\n  'bcy': '\\u0431',\n  'bdquo': '\\u201E',\n  'ldquor': '\\u201E',\n  'bemptyv': '\\u29B0',\n  'beta': '\\u03B2',\n  'beth': '\\u2136',\n  'between': '\\u226C',\n  'twixt': '\\u226C',\n  'bfr': '\\uD835\\uDD1F',\n  'bigcirc': '\\u25EF',\n  'xcirc': '\\u25EF',\n  'bigodot': '\\u2A00',\n  'xodot': '\\u2A00',\n  'bigoplus': '\\u2A01',\n  'xoplus': '\\u2A01',\n  'bigotimes': '\\u2A02',\n  'xotime': '\\u2A02',\n  'bigsqcup': '\\u2A06',\n  'xsqcup': '\\u2A06',\n  'bigstar': '\\u2605',\n  'starf': '\\u2605',\n  'bigtriangledown': '\\u25BD',\n  'xdtri': '\\u25BD',\n  'bigtriangleup': '\\u25B3',\n  'xutri': '\\u25B3',\n  'biguplus': '\\u2A04',\n  'xuplus': '\\u2A04',\n  'bkarow': '\\u290D',\n  'rbarr': '\\u290D',\n  'blacklozenge': '\\u29EB',\n  'lozf': '\\u29EB',\n  'blacktriangle': '\\u25B4',\n  'utrif': '\\u25B4',\n  'blacktriangledown': '\\u25BE',\n  'dtrif': '\\u25BE',\n  'blacktriangleleft': '\\u25C2',\n  'ltrif': '\\u25C2',\n  'blacktriangleright': '\\u25B8',\n  'rtrif': '\\u25B8',\n  'blank': '\\u2423',\n  'blk12': '\\u2592',\n  'blk14': '\\u2591',\n  'blk34': '\\u2593',\n  'block': '\\u2588',\n  'bne': '\\u003D\\u20E5',\n  'bnequiv': '\\u2261\\u20E5',\n  'bnot': '\\u2310',\n  'bopf': '\\uD835\\uDD53',\n  'bowtie': '\\u22C8',\n  'boxDL': '\\u2557',\n  'boxDR': '\\u2554',\n  'boxDl': '\\u2556',\n  'boxDr': '\\u2553',\n  'boxH': '\\u2550',\n  'boxHD': '\\u2566',\n  'boxHU': '\\u2569',\n  'boxHd': '\\u2564',\n  'boxHu': '\\u2567',\n  'boxUL': '\\u255D',\n  'boxUR': '\\u255A',\n  'boxUl': '\\u255C',\n  'boxUr': '\\u2559',\n  'boxV': '\\u2551',\n  'boxVH': '\\u256C',\n  'boxVL': '\\u2563',\n  'boxVR': '\\u2560',\n  'boxVh': '\\u256B',\n  'boxVl': '\\u2562',\n  'boxVr': '\\u255F',\n  'boxbox': '\\u29C9',\n  'boxdL': '\\u2555',\n  'boxdR': '\\u2552',\n  'boxdl': '\\u2510',\n  'boxdr': '\\u250C',\n  'boxhD': '\\u2565',\n  'boxhU': '\\u2568',\n  'boxhd': '\\u252C',\n  'boxhu': '\\u2534',\n  'boxminus': '\\u229F',\n  'minusb': '\\u229F',\n  'boxplus': '\\u229E',\n  'plusb': '\\u229E',\n  'boxtimes': '\\u22A0',\n  'timesb': '\\u22A0',\n  'boxuL': '\\u255B',\n  'boxuR': '\\u2558',\n  'boxul': '\\u2518',\n  'boxur': '\\u2514',\n  'boxv': '\\u2502',\n  'boxvH': '\\u256A',\n  'boxvL': '\\u2561',\n  'boxvR': '\\u255E',\n  'boxvh': '\\u253C',\n  'boxvl': '\\u2524',\n  'boxvr': '\\u251C',\n  'brvbar': '\\u00A6',\n  'bscr': '\\uD835\\uDCB7',\n  'bsemi': '\\u204F',\n  'bsol': '\\u005C',\n  'bsolb': '\\u29C5',\n  'bsolhsub': '\\u27C8',\n  'bull': '\\u2022',\n  'bullet': '\\u2022',\n  'bumpE': '\\u2AAE',\n  'cacute': '\\u0107',\n  'cap': '\\u2229',\n  'capand': '\\u2A44',\n  'capbrcup': '\\u2A49',\n  'capcap': '\\u2A4B',\n  'capcup': '\\u2A47',\n  'capdot': '\\u2A40',\n  'caps': '\\u2229\\uFE00',\n  'caret': '\\u2041',\n  'ccaps': '\\u2A4D',\n  'ccaron': '\\u010D',\n  'ccedil': '\\u00E7',\n  'ccirc': '\\u0109',\n  'ccups': '\\u2A4C',\n  'ccupssm': '\\u2A50',\n  'cdot': '\\u010B',\n  'cemptyv': '\\u29B2',\n  'cent': '\\u00A2',\n  'cfr': '\\uD835\\uDD20',\n  'chcy': '\\u0447',\n  'check': '\\u2713',\n  'checkmark': '\\u2713',\n  'chi': '\\u03C7',\n  'cir': '\\u25CB',\n  'cirE': '\\u29C3',\n  'circ': '\\u02C6',\n  'circeq': '\\u2257',\n  'cire': '\\u2257',\n  'circlearrowleft': '\\u21BA',\n  'olarr': '\\u21BA',\n  'circlearrowright': '\\u21BB',\n  'orarr': '\\u21BB',\n  'circledS': '\\u24C8',\n  'oS': '\\u24C8',\n  'circledast': '\\u229B',\n  'oast': '\\u229B',\n  'circledcirc': '\\u229A',\n  'ocir': '\\u229A',\n  'circleddash': '\\u229D',\n  'odash': '\\u229D',\n  'cirfnint': '\\u2A10',\n  'cirmid': '\\u2AEF',\n  'cirscir': '\\u29C2',\n  'clubs': '\\u2663',\n  'clubsuit': '\\u2663',\n  'colon': '\\u003A',\n  'comma': '\\u002C',\n  'commat': '\\u0040',\n  'comp': '\\u2201',\n  'complement': '\\u2201',\n  'congdot': '\\u2A6D',\n  'copf': '\\uD835\\uDD54',\n  'copysr': '\\u2117',\n  'crarr': '\\u21B5',\n  'cross': '\\u2717',\n  'cscr': '\\uD835\\uDCB8',\n  'csub': '\\u2ACF',\n  'csube': '\\u2AD1',\n  'csup': '\\u2AD0',\n  'csupe': '\\u2AD2',\n  'ctdot': '\\u22EF',\n  'cudarrl': '\\u2938',\n  'cudarrr': '\\u2935',\n  'cuepr': '\\u22DE',\n  'curlyeqprec': '\\u22DE',\n  'cuesc': '\\u22DF',\n  'curlyeqsucc': '\\u22DF',\n  'cularr': '\\u21B6',\n  'curvearrowleft': '\\u21B6',\n  'cularrp': '\\u293D',\n  'cup': '\\u222A',\n  'cupbrcap': '\\u2A48',\n  'cupcap': '\\u2A46',\n  'cupcup': '\\u2A4A',\n  'cupdot': '\\u228D',\n  'cupor': '\\u2A45',\n  'cups': '\\u222A\\uFE00',\n  'curarr': '\\u21B7',\n  'curvearrowright': '\\u21B7',\n  'curarrm': '\\u293C',\n  'curlyvee': '\\u22CE',\n  'cuvee': '\\u22CE',\n  'curlywedge': '\\u22CF',\n  'cuwed': '\\u22CF',\n  'curren': '\\u00A4',\n  'cwint': '\\u2231',\n  'cylcty': '\\u232D',\n  'dHar': '\\u2965',\n  'dagger': '\\u2020',\n  'daleth': '\\u2138',\n  'dash': '\\u2010',\n  'hyphen': '\\u2010',\n  'dbkarow': '\\u290F',\n  'rBarr': '\\u290F',\n  'dcaron': '\\u010F',\n  'dcy': '\\u0434',\n  'ddarr': '\\u21CA',\n  'downdownarrows': '\\u21CA',\n  'ddotseq': '\\u2A77',\n  'eDDot': '\\u2A77',\n  'deg': '\\u00B0',\n  'delta': '\\u03B4',\n  'demptyv': '\\u29B1',\n  'dfisht': '\\u297F',\n  'dfr': '\\uD835\\uDD21',\n  'diamondsuit': '\\u2666',\n  'diams': '\\u2666',\n  'digamma': '\\u03DD',\n  'gammad': '\\u03DD',\n  'disin': '\\u22F2',\n  'div': '\\u00F7',\n  'divide': '\\u00F7',\n  'divideontimes': '\\u22C7',\n  'divonx': '\\u22C7',\n  'djcy': '\\u0452',\n  'dlcorn': '\\u231E',\n  'llcorner': '\\u231E',\n  'dlcrop': '\\u230D',\n  'dollar': '\\u0024',\n  'dopf': '\\uD835\\uDD55',\n  'doteqdot': '\\u2251',\n  'eDot': '\\u2251',\n  'dotminus': '\\u2238',\n  'minusd': '\\u2238',\n  'dotplus': '\\u2214',\n  'plusdo': '\\u2214',\n  'dotsquare': '\\u22A1',\n  'sdotb': '\\u22A1',\n  'drcorn': '\\u231F',\n  'lrcorner': '\\u231F',\n  'drcrop': '\\u230C',\n  'dscr': '\\uD835\\uDCB9',\n  'dscy': '\\u0455',\n  'dsol': '\\u29F6',\n  'dstrok': '\\u0111',\n  'dtdot': '\\u22F1',\n  'dtri': '\\u25BF',\n  'triangledown': '\\u25BF',\n  'dwangle': '\\u29A6',\n  'dzcy': '\\u045F',\n  'dzigrarr': '\\u27FF',\n  'eacute': '\\u00E9',\n  'easter': '\\u2A6E',\n  'ecaron': '\\u011B',\n  'ecir': '\\u2256',\n  'eqcirc': '\\u2256',\n  'ecirc': '\\u00EA',\n  'ecolon': '\\u2255',\n  'eqcolon': '\\u2255',\n  'ecy': '\\u044D',\n  'edot': '\\u0117',\n  'efDot': '\\u2252',\n  'fallingdotseq': '\\u2252',\n  'efr': '\\uD835\\uDD22',\n  'eg': '\\u2A9A',\n  'egrave': '\\u00E8',\n  'egs': '\\u2A96',\n  'eqslantgtr': '\\u2A96',\n  'egsdot': '\\u2A98',\n  'el': '\\u2A99',\n  'elinters': '\\u23E7',\n  'ell': '\\u2113',\n  'els': '\\u2A95',\n  'eqslantless': '\\u2A95',\n  'elsdot': '\\u2A97',\n  'emacr': '\\u0113',\n  'empty': '\\u2205',\n  'emptyset': '\\u2205',\n  'emptyv': '\\u2205',\n  'varnothing': '\\u2205',\n  'emsp13': '\\u2004',\n  'emsp14': '\\u2005',\n  'emsp': '\\u2003',\n  'eng': '\\u014B',\n  'ensp': '\\u2002',\n  'eogon': '\\u0119',\n  'eopf': '\\uD835\\uDD56',\n  'epar': '\\u22D5',\n  'eparsl': '\\u29E3',\n  'eplus': '\\u2A71',\n  'epsi': '\\u03B5',\n  'epsilon': '\\u03B5',\n  'epsiv': '\\u03F5',\n  'straightepsilon': '\\u03F5',\n  'varepsilon': '\\u03F5',\n  'equals': '\\u003D',\n  'equest': '\\u225F',\n  'questeq': '\\u225F',\n  'equivDD': '\\u2A78',\n  'eqvparsl': '\\u29E5',\n  'erDot': '\\u2253',\n  'risingdotseq': '\\u2253',\n  'erarr': '\\u2971',\n  'escr': '\\u212F',\n  'eta': '\\u03B7',\n  'eth': '\\u00F0',\n  'euml': '\\u00EB',\n  'euro': '\\u20AC',\n  'excl': '\\u0021',\n  'fcy': '\\u0444',\n  'female': '\\u2640',\n  'ffilig': '\\uFB03',\n  'fflig': '\\uFB00',\n  'ffllig': '\\uFB04',\n  'ffr': '\\uD835\\uDD23',\n  'filig': '\\uFB01',\n  'fjlig': '\\u0066\\u006A',\n  'flat': '\\u266D',\n  'fllig': '\\uFB02',\n  'fltns': '\\u25B1',\n  'fnof': '\\u0192',\n  'fopf': '\\uD835\\uDD57',\n  'fork': '\\u22D4',\n  'pitchfork': '\\u22D4',\n  'forkv': '\\u2AD9',\n  'fpartint': '\\u2A0D',\n  'frac12': '\\u00BD',\n  'half': '\\u00BD',\n  'frac13': '\\u2153',\n  'frac14': '\\u00BC',\n  'frac15': '\\u2155',\n  'frac16': '\\u2159',\n  'frac18': '\\u215B',\n  'frac23': '\\u2154',\n  'frac25': '\\u2156',\n  'frac34': '\\u00BE',\n  'frac35': '\\u2157',\n  'frac38': '\\u215C',\n  'frac45': '\\u2158',\n  'frac56': '\\u215A',\n  'frac58': '\\u215D',\n  'frac78': '\\u215E',\n  'frasl': '\\u2044',\n  'frown': '\\u2322',\n  'sfrown': '\\u2322',\n  'fscr': '\\uD835\\uDCBB',\n  'gEl': '\\u2A8C',\n  'gtreqqless': '\\u2A8C',\n  'gacute': '\\u01F5',\n  'gamma': '\\u03B3',\n  'gap': '\\u2A86',\n  'gtrapprox': '\\u2A86',\n  'gbreve': '\\u011F',\n  'gcirc': '\\u011D',\n  'gcy': '\\u0433',\n  'gdot': '\\u0121',\n  'gescc': '\\u2AA9',\n  'gesdot': '\\u2A80',\n  'gesdoto': '\\u2A82',\n  'gesdotol': '\\u2A84',\n  'gesl': '\\u22DB\\uFE00',\n  'gesles': '\\u2A94',\n  'gfr': '\\uD835\\uDD24',\n  'gimel': '\\u2137',\n  'gjcy': '\\u0453',\n  'glE': '\\u2A92',\n  'gla': '\\u2AA5',\n  'glj': '\\u2AA4',\n  'gnE': '\\u2269',\n  'gneqq': '\\u2269',\n  'gnap': '\\u2A8A',\n  'gnapprox': '\\u2A8A',\n  'gne': '\\u2A88',\n  'gneq': '\\u2A88',\n  'gnsim': '\\u22E7',\n  'gopf': '\\uD835\\uDD58',\n  'gscr': '\\u210A',\n  'gsime': '\\u2A8E',\n  'gsiml': '\\u2A90',\n  'gtcc': '\\u2AA7',\n  'gtcir': '\\u2A7A',\n  'gtdot': '\\u22D7',\n  'gtrdot': '\\u22D7',\n  'gtlPar': '\\u2995',\n  'gtquest': '\\u2A7C',\n  'gtrarr': '\\u2978',\n  'gvertneqq': '\\u2269\\uFE00',\n  'gvnE': '\\u2269\\uFE00',\n  'hardcy': '\\u044A',\n  'harrcir': '\\u2948',\n  'harrw': '\\u21AD',\n  'leftrightsquigarrow': '\\u21AD',\n  'hbar': '\\u210F',\n  'hslash': '\\u210F',\n  'planck': '\\u210F',\n  'plankv': '\\u210F',\n  'hcirc': '\\u0125',\n  'hearts': '\\u2665',\n  'heartsuit': '\\u2665',\n  'hellip': '\\u2026',\n  'mldr': '\\u2026',\n  'hercon': '\\u22B9',\n  'hfr': '\\uD835\\uDD25',\n  'hksearow': '\\u2925',\n  'searhk': '\\u2925',\n  'hkswarow': '\\u2926',\n  'swarhk': '\\u2926',\n  'hoarr': '\\u21FF',\n  'homtht': '\\u223B',\n  'hookleftarrow': '\\u21A9',\n  'larrhk': '\\u21A9',\n  'hookrightarrow': '\\u21AA',\n  'rarrhk': '\\u21AA',\n  'hopf': '\\uD835\\uDD59',\n  'horbar': '\\u2015',\n  'hscr': '\\uD835\\uDCBD',\n  'hstrok': '\\u0127',\n  'hybull': '\\u2043',\n  'iacute': '\\u00ED',\n  'icirc': '\\u00EE',\n  'icy': '\\u0438',\n  'iecy': '\\u0435',\n  'iexcl': '\\u00A1',\n  'ifr': '\\uD835\\uDD26',\n  'igrave': '\\u00EC',\n  'iiiint': '\\u2A0C',\n  'qint': '\\u2A0C',\n  'iiint': '\\u222D',\n  'tint': '\\u222D',\n  'iinfin': '\\u29DC',\n  'iiota': '\\u2129',\n  'ijlig': '\\u0133',\n  'imacr': '\\u012B',\n  'imath': '\\u0131',\n  'inodot': '\\u0131',\n  'imof': '\\u22B7',\n  'imped': '\\u01B5',\n  'incare': '\\u2105',\n  'infin': '\\u221E',\n  'infintie': '\\u29DD',\n  'intcal': '\\u22BA',\n  'intercal': '\\u22BA',\n  'intlarhk': '\\u2A17',\n  'intprod': '\\u2A3C',\n  'iprod': '\\u2A3C',\n  'iocy': '\\u0451',\n  'iogon': '\\u012F',\n  'iopf': '\\uD835\\uDD5A',\n  'iota': '\\u03B9',\n  'iquest': '\\u00BF',\n  'iscr': '\\uD835\\uDCBE',\n  'isinE': '\\u22F9',\n  'isindot': '\\u22F5',\n  'isins': '\\u22F4',\n  'isinsv': '\\u22F3',\n  'itilde': '\\u0129',\n  'iukcy': '\\u0456',\n  'iuml': '\\u00EF',\n  'jcirc': '\\u0135',\n  'jcy': '\\u0439',\n  'jfr': '\\uD835\\uDD27',\n  'jmath': '\\u0237',\n  'jopf': '\\uD835\\uDD5B',\n  'jscr': '\\uD835\\uDCBF',\n  'jsercy': '\\u0458',\n  'jukcy': '\\u0454',\n  'kappa': '\\u03BA',\n  'kappav': '\\u03F0',\n  'varkappa': '\\u03F0',\n  'kcedil': '\\u0137',\n  'kcy': '\\u043A',\n  'kfr': '\\uD835\\uDD28',\n  'kgreen': '\\u0138',\n  'khcy': '\\u0445',\n  'kjcy': '\\u045C',\n  'kopf': '\\uD835\\uDD5C',\n  'kscr': '\\uD835\\uDCC0',\n  'lAtail': '\\u291B',\n  'lBarr': '\\u290E',\n  'lEg': '\\u2A8B',\n  'lesseqqgtr': '\\u2A8B',\n  'lHar': '\\u2962',\n  'lacute': '\\u013A',\n  'laemptyv': '\\u29B4',\n  'lambda': '\\u03BB',\n  'langd': '\\u2991',\n  'lap': '\\u2A85',\n  'lessapprox': '\\u2A85',\n  'laquo': '\\u00AB',\n  'larrbfs': '\\u291F',\n  'larrfs': '\\u291D',\n  'larrlp': '\\u21AB',\n  'looparrowleft': '\\u21AB',\n  'larrpl': '\\u2939',\n  'larrsim': '\\u2973',\n  'larrtl': '\\u21A2',\n  'leftarrowtail': '\\u21A2',\n  'lat': '\\u2AAB',\n  'latail': '\\u2919',\n  'late': '\\u2AAD',\n  'lates': '\\u2AAD\\uFE00',\n  'lbarr': '\\u290C',\n  'lbbrk': '\\u2772',\n  'lbrace': '\\u007B',\n  'lcub': '\\u007B',\n  'lbrack': '\\u005B',\n  'lsqb': '\\u005B',\n  'lbrke': '\\u298B',\n  'lbrksld': '\\u298F',\n  'lbrkslu': '\\u298D',\n  'lcaron': '\\u013E',\n  'lcedil': '\\u013C',\n  'lcy': '\\u043B',\n  'ldca': '\\u2936',\n  'ldrdhar': '\\u2967',\n  'ldrushar': '\\u294B',\n  'ldsh': '\\u21B2',\n  'le': '\\u2264',\n  'leq': '\\u2264',\n  'leftleftarrows': '\\u21C7',\n  'llarr': '\\u21C7',\n  'leftthreetimes': '\\u22CB',\n  'lthree': '\\u22CB',\n  'lescc': '\\u2AA8',\n  'lesdot': '\\u2A7F',\n  'lesdoto': '\\u2A81',\n  'lesdotor': '\\u2A83',\n  'lesg': '\\u22DA\\uFE00',\n  'lesges': '\\u2A93',\n  'lessdot': '\\u22D6',\n  'ltdot': '\\u22D6',\n  'lfisht': '\\u297C',\n  'lfr': '\\uD835\\uDD29',\n  'lgE': '\\u2A91',\n  'lharul': '\\u296A',\n  'lhblk': '\\u2584',\n  'ljcy': '\\u0459',\n  'llhard': '\\u296B',\n  'lltri': '\\u25FA',\n  'lmidot': '\\u0140',\n  'lmoust': '\\u23B0',\n  'lmoustache': '\\u23B0',\n  'lnE': '\\u2268',\n  'lneqq': '\\u2268',\n  'lnap': '\\u2A89',\n  'lnapprox': '\\u2A89',\n  'lne': '\\u2A87',\n  'lneq': '\\u2A87',\n  'lnsim': '\\u22E6',\n  'loang': '\\u27EC',\n  'loarr': '\\u21FD',\n  'longmapsto': '\\u27FC',\n  'xmap': '\\u27FC',\n  'looparrowright': '\\u21AC',\n  'rarrlp': '\\u21AC',\n  'lopar': '\\u2985',\n  'lopf': '\\uD835\\uDD5D',\n  'loplus': '\\u2A2D',\n  'lotimes': '\\u2A34',\n  'lowast': '\\u2217',\n  'loz': '\\u25CA',\n  'lozenge': '\\u25CA',\n  'lpar': '\\u0028',\n  'lparlt': '\\u2993',\n  'lrhard': '\\u296D',\n  'lrm': '\\u200E',\n  'lrtri': '\\u22BF',\n  'lsaquo': '\\u2039',\n  'lscr': '\\uD835\\uDCC1',\n  'lsime': '\\u2A8D',\n  'lsimg': '\\u2A8F',\n  'lsquor': '\\u201A',\n  'sbquo': '\\u201A',\n  'lstrok': '\\u0142',\n  'ltcc': '\\u2AA6',\n  'ltcir': '\\u2A79',\n  'ltimes': '\\u22C9',\n  'ltlarr': '\\u2976',\n  'ltquest': '\\u2A7B',\n  'ltrPar': '\\u2996',\n  'ltri': '\\u25C3',\n  'triangleleft': '\\u25C3',\n  'lurdshar': '\\u294A',\n  'luruhar': '\\u2966',\n  'lvertneqq': '\\u2268\\uFE00',\n  'lvnE': '\\u2268\\uFE00',\n  'mDDot': '\\u223A',\n  'macr': '\\u00AF',\n  'strns': '\\u00AF',\n  'male': '\\u2642',\n  'malt': '\\u2720',\n  'maltese': '\\u2720',\n  'marker': '\\u25AE',\n  'mcomma': '\\u2A29',\n  'mcy': '\\u043C',\n  'mdash': '\\u2014',\n  'mfr': '\\uD835\\uDD2A',\n  'mho': '\\u2127',\n  'micro': '\\u00B5',\n  'midcir': '\\u2AF0',\n  'minus': '\\u2212',\n  'minusdu': '\\u2A2A',\n  'mlcp': '\\u2ADB',\n  'models': '\\u22A7',\n  'mopf': '\\uD835\\uDD5E',\n  'mscr': '\\uD835\\uDCC2',\n  'mu': '\\u03BC',\n  'multimap': '\\u22B8',\n  'mumap': '\\u22B8',\n  'nGg': '\\u22D9\\u0338',\n  'nGt': '\\u226B\\u20D2',\n  'nLeftarrow': '\\u21CD',\n  'nlArr': '\\u21CD',\n  'nLeftrightarrow': '\\u21CE',\n  'nhArr': '\\u21CE',\n  'nLl': '\\u22D8\\u0338',\n  'nLt': '\\u226A\\u20D2',\n  'nRightarrow': '\\u21CF',\n  'nrArr': '\\u21CF',\n  'nVDash': '\\u22AF',\n  'nVdash': '\\u22AE',\n  'nacute': '\\u0144',\n  'nang': '\\u2220\\u20D2',\n  'napE': '\\u2A70\\u0338',\n  'napid': '\\u224B\\u0338',\n  'napos': '\\u0149',\n  'natur': '\\u266E',\n  'natural': '\\u266E',\n  'ncap': '\\u2A43',\n  'ncaron': '\\u0148',\n  'ncedil': '\\u0146',\n  'ncongdot': '\\u2A6D\\u0338',\n  'ncup': '\\u2A42',\n  'ncy': '\\u043D',\n  'ndash': '\\u2013',\n  'neArr': '\\u21D7',\n  'nearhk': '\\u2924',\n  'nedot': '\\u2250\\u0338',\n  'nesear': '\\u2928',\n  'toea': '\\u2928',\n  'nfr': '\\uD835\\uDD2B',\n  'nharr': '\\u21AE',\n  'nleftrightarrow': '\\u21AE',\n  'nhpar': '\\u2AF2',\n  'nis': '\\u22FC',\n  'nisd': '\\u22FA',\n  'njcy': '\\u045A',\n  'nlE': '\\u2266\\u0338',\n  'nleqq': '\\u2266\\u0338',\n  'nlarr': '\\u219A',\n  'nleftarrow': '\\u219A',\n  'nldr': '\\u2025',\n  'nopf': '\\uD835\\uDD5F',\n  'not': '\\u00AC',\n  'notinE': '\\u22F9\\u0338',\n  'notindot': '\\u22F5\\u0338',\n  'notinvb': '\\u22F7',\n  'notinvc': '\\u22F6',\n  'notnivb': '\\u22FE',\n  'notnivc': '\\u22FD',\n  'nparsl': '\\u2AFD\\u20E5',\n  'npart': '\\u2202\\u0338',\n  'npolint': '\\u2A14',\n  'nrarr': '\\u219B',\n  'nrightarrow': '\\u219B',\n  'nrarrc': '\\u2933\\u0338',\n  'nrarrw': '\\u219D\\u0338',\n  'nscr': '\\uD835\\uDCC3',\n  'nsub': '\\u2284',\n  'nsubE': '\\u2AC5\\u0338',\n  'nsubseteqq': '\\u2AC5\\u0338',\n  'nsup': '\\u2285',\n  'nsupE': '\\u2AC6\\u0338',\n  'nsupseteqq': '\\u2AC6\\u0338',\n  'ntilde': '\\u00F1',\n  'nu': '\\u03BD',\n  'num': '\\u0023',\n  'numero': '\\u2116',\n  'numsp': '\\u2007',\n  'nvDash': '\\u22AD',\n  'nvHarr': '\\u2904',\n  'nvap': '\\u224D\\u20D2',\n  'nvdash': '\\u22AC',\n  'nvge': '\\u2265\\u20D2',\n  'nvgt': '\\u003E\\u20D2',\n  'nvinfin': '\\u29DE',\n  'nvlArr': '\\u2902',\n  'nvle': '\\u2264\\u20D2',\n  'nvlt': '\\u003C\\u20D2',\n  'nvltrie': '\\u22B4\\u20D2',\n  'nvrArr': '\\u2903',\n  'nvrtrie': '\\u22B5\\u20D2',\n  'nvsim': '\\u223C\\u20D2',\n  'nwArr': '\\u21D6',\n  'nwarhk': '\\u2923',\n  'nwnear': '\\u2927',\n  'oacute': '\\u00F3',\n  'ocirc': '\\u00F4',\n  'ocy': '\\u043E',\n  'odblac': '\\u0151',\n  'odiv': '\\u2A38',\n  'odsold': '\\u29BC',\n  'oelig': '\\u0153',\n  'ofcir': '\\u29BF',\n  'ofr': '\\uD835\\uDD2C',\n  'ogon': '\\u02DB',\n  'ograve': '\\u00F2',\n  'ogt': '\\u29C1',\n  'ohbar': '\\u29B5',\n  'olcir': '\\u29BE',\n  'olcross': '\\u29BB',\n  'olt': '\\u29C0',\n  'omacr': '\\u014D',\n  'omega': '\\u03C9',\n  'omicron': '\\u03BF',\n  'omid': '\\u29B6',\n  'oopf': '\\uD835\\uDD60',\n  'opar': '\\u29B7',\n  'operp': '\\u29B9',\n  'or': '\\u2228',\n  'vee': '\\u2228',\n  'ord': '\\u2A5D',\n  'order': '\\u2134',\n  'orderof': '\\u2134',\n  'oscr': '\\u2134',\n  'ordf': '\\u00AA',\n  'ordm': '\\u00BA',\n  'origof': '\\u22B6',\n  'oror': '\\u2A56',\n  'orslope': '\\u2A57',\n  'orv': '\\u2A5B',\n  'oslash': '\\u00F8',\n  'osol': '\\u2298',\n  'otilde': '\\u00F5',\n  'otimesas': '\\u2A36',\n  'ouml': '\\u00F6',\n  'ovbar': '\\u233D',\n  'para': '\\u00B6',\n  'parsim': '\\u2AF3',\n  'parsl': '\\u2AFD',\n  'pcy': '\\u043F',\n  'percnt': '\\u0025',\n  'period': '\\u002E',\n  'permil': '\\u2030',\n  'pertenk': '\\u2031',\n  'pfr': '\\uD835\\uDD2D',\n  'phi': '\\u03C6',\n  'phiv': '\\u03D5',\n  'straightphi': '\\u03D5',\n  'varphi': '\\u03D5',\n  'phone': '\\u260E',\n  'pi': '\\u03C0',\n  'piv': '\\u03D6',\n  'varpi': '\\u03D6',\n  'planckh': '\\u210E',\n  'plus': '\\u002B',\n  'plusacir': '\\u2A23',\n  'pluscir': '\\u2A22',\n  'plusdu': '\\u2A25',\n  'pluse': '\\u2A72',\n  'plussim': '\\u2A26',\n  'plustwo': '\\u2A27',\n  'pointint': '\\u2A15',\n  'popf': '\\uD835\\uDD61',\n  'pound': '\\u00A3',\n  'prE': '\\u2AB3',\n  'prap': '\\u2AB7',\n  'precapprox': '\\u2AB7',\n  'precnapprox': '\\u2AB9',\n  'prnap': '\\u2AB9',\n  'precneqq': '\\u2AB5',\n  'prnE': '\\u2AB5',\n  'precnsim': '\\u22E8',\n  'prnsim': '\\u22E8',\n  'prime': '\\u2032',\n  'profalar': '\\u232E',\n  'profline': '\\u2312',\n  'profsurf': '\\u2313',\n  'prurel': '\\u22B0',\n  'pscr': '\\uD835\\uDCC5',\n  'psi': '\\u03C8',\n  'puncsp': '\\u2008',\n  'qfr': '\\uD835\\uDD2E',\n  'qopf': '\\uD835\\uDD62',\n  'qprime': '\\u2057',\n  'qscr': '\\uD835\\uDCC6',\n  'quatint': '\\u2A16',\n  'quest': '\\u003F',\n  'rAtail': '\\u291C',\n  'rHar': '\\u2964',\n  'race': '\\u223D\\u0331',\n  'racute': '\\u0155',\n  'raemptyv': '\\u29B3',\n  'rangd': '\\u2992',\n  'range': '\\u29A5',\n  'raquo': '\\u00BB',\n  'rarrap': '\\u2975',\n  'rarrbfs': '\\u2920',\n  'rarrc': '\\u2933',\n  'rarrfs': '\\u291E',\n  'rarrpl': '\\u2945',\n  'rarrsim': '\\u2974',\n  'rarrtl': '\\u21A3',\n  'rightarrowtail': '\\u21A3',\n  'rarrw': '\\u219D',\n  'rightsquigarrow': '\\u219D',\n  'ratail': '\\u291A',\n  'ratio': '\\u2236',\n  'rbbrk': '\\u2773',\n  'rbrace': '\\u007D',\n  'rcub': '\\u007D',\n  'rbrack': '\\u005D',\n  'rsqb': '\\u005D',\n  'rbrke': '\\u298C',\n  'rbrksld': '\\u298E',\n  'rbrkslu': '\\u2990',\n  'rcaron': '\\u0159',\n  'rcedil': '\\u0157',\n  'rcy': '\\u0440',\n  'rdca': '\\u2937',\n  'rdldhar': '\\u2969',\n  'rdsh': '\\u21B3',\n  'rect': '\\u25AD',\n  'rfisht': '\\u297D',\n  'rfr': '\\uD835\\uDD2F',\n  'rharul': '\\u296C',\n  'rho': '\\u03C1',\n  'rhov': '\\u03F1',\n  'varrho': '\\u03F1',\n  'rightrightarrows': '\\u21C9',\n  'rrarr': '\\u21C9',\n  'rightthreetimes': '\\u22CC',\n  'rthree': '\\u22CC',\n  'ring': '\\u02DA',\n  'rlm': '\\u200F',\n  'rmoust': '\\u23B1',\n  'rmoustache': '\\u23B1',\n  'rnmid': '\\u2AEE',\n  'roang': '\\u27ED',\n  'roarr': '\\u21FE',\n  'ropar': '\\u2986',\n  'ropf': '\\uD835\\uDD63',\n  'roplus': '\\u2A2E',\n  'rotimes': '\\u2A35',\n  'rpar': '\\u0029',\n  'rpargt': '\\u2994',\n  'rppolint': '\\u2A12',\n  'rsaquo': '\\u203A',\n  'rscr': '\\uD835\\uDCC7',\n  'rtimes': '\\u22CA',\n  'rtri': '\\u25B9',\n  'triangleright': '\\u25B9',\n  'rtriltri': '\\u29CE',\n  'ruluhar': '\\u2968',\n  'rx': '\\u211E',\n  'sacute': '\\u015B',\n  'scE': '\\u2AB4',\n  'scap': '\\u2AB8',\n  'succapprox': '\\u2AB8',\n  'scaron': '\\u0161',\n  'scedil': '\\u015F',\n  'scirc': '\\u015D',\n  'scnE': '\\u2AB6',\n  'succneqq': '\\u2AB6',\n  'scnap': '\\u2ABA',\n  'succnapprox': '\\u2ABA',\n  'scnsim': '\\u22E9',\n  'succnsim': '\\u22E9',\n  'scpolint': '\\u2A13',\n  'scy': '\\u0441',\n  'sdot': '\\u22C5',\n  'sdote': '\\u2A66',\n  'seArr': '\\u21D8',\n  'sect': '\\u00A7',\n  'semi': '\\u003B',\n  'seswar': '\\u2929',\n  'tosa': '\\u2929',\n  'sext': '\\u2736',\n  'sfr': '\\uD835\\uDD30',\n  'sharp': '\\u266F',\n  'shchcy': '\\u0449',\n  'shcy': '\\u0448',\n  'shy': '\\u00AD',\n  'sigma': '\\u03C3',\n  'sigmaf': '\\u03C2',\n  'sigmav': '\\u03C2',\n  'varsigma': '\\u03C2',\n  'simdot': '\\u2A6A',\n  'simg': '\\u2A9E',\n  'simgE': '\\u2AA0',\n  'siml': '\\u2A9D',\n  'simlE': '\\u2A9F',\n  'simne': '\\u2246',\n  'simplus': '\\u2A24',\n  'simrarr': '\\u2972',\n  'smashp': '\\u2A33',\n  'smeparsl': '\\u29E4',\n  'smile': '\\u2323',\n  'ssmile': '\\u2323',\n  'smt': '\\u2AAA',\n  'smte': '\\u2AAC',\n  'smtes': '\\u2AAC\\uFE00',\n  'softcy': '\\u044C',\n  'sol': '\\u002F',\n  'solb': '\\u29C4',\n  'solbar': '\\u233F',\n  'sopf': '\\uD835\\uDD64',\n  'spades': '\\u2660',\n  'spadesuit': '\\u2660',\n  'sqcaps': '\\u2293\\uFE00',\n  'sqcups': '\\u2294\\uFE00',\n  'sscr': '\\uD835\\uDCC8',\n  'star': '\\u2606',\n  'sub': '\\u2282',\n  'subset': '\\u2282',\n  'subE': '\\u2AC5',\n  'subseteqq': '\\u2AC5',\n  'subdot': '\\u2ABD',\n  'subedot': '\\u2AC3',\n  'submult': '\\u2AC1',\n  'subnE': '\\u2ACB',\n  'subsetneqq': '\\u2ACB',\n  'subne': '\\u228A',\n  'subsetneq': '\\u228A',\n  'subplus': '\\u2ABF',\n  'subrarr': '\\u2979',\n  'subsim': '\\u2AC7',\n  'subsub': '\\u2AD5',\n  'subsup': '\\u2AD3',\n  'sung': '\\u266A',\n  'sup1': '\\u00B9',\n  'sup2': '\\u00B2',\n  'sup3': '\\u00B3',\n  'supE': '\\u2AC6',\n  'supseteqq': '\\u2AC6',\n  'supdot': '\\u2ABE',\n  'supdsub': '\\u2AD8',\n  'supedot': '\\u2AC4',\n  'suphsol': '\\u27C9',\n  'suphsub': '\\u2AD7',\n  'suplarr': '\\u297B',\n  'supmult': '\\u2AC2',\n  'supnE': '\\u2ACC',\n  'supsetneqq': '\\u2ACC',\n  'supne': '\\u228B',\n  'supsetneq': '\\u228B',\n  'supplus': '\\u2AC0',\n  'supsim': '\\u2AC8',\n  'supsub': '\\u2AD4',\n  'supsup': '\\u2AD6',\n  'swArr': '\\u21D9',\n  'swnwar': '\\u292A',\n  'szlig': '\\u00DF',\n  'target': '\\u2316',\n  'tau': '\\u03C4',\n  'tcaron': '\\u0165',\n  'tcedil': '\\u0163',\n  'tcy': '\\u0442',\n  'telrec': '\\u2315',\n  'tfr': '\\uD835\\uDD31',\n  'theta': '\\u03B8',\n  'thetasym': '\\u03D1',\n  'thetav': '\\u03D1',\n  'vartheta': '\\u03D1',\n  'thorn': '\\u00FE',\n  'times': '\\u00D7',\n  'timesbar': '\\u2A31',\n  'timesd': '\\u2A30',\n  'topbot': '\\u2336',\n  'topcir': '\\u2AF1',\n  'topf': '\\uD835\\uDD65',\n  'topfork': '\\u2ADA',\n  'tprime': '\\u2034',\n  'triangle': '\\u25B5',\n  'utri': '\\u25B5',\n  'triangleq': '\\u225C',\n  'trie': '\\u225C',\n  'tridot': '\\u25EC',\n  'triminus': '\\u2A3A',\n  'triplus': '\\u2A39',\n  'trisb': '\\u29CD',\n  'tritime': '\\u2A3B',\n  'trpezium': '\\u23E2',\n  'tscr': '\\uD835\\uDCC9',\n  'tscy': '\\u0446',\n  'tshcy': '\\u045B',\n  'tstrok': '\\u0167',\n  'uHar': '\\u2963',\n  'uacute': '\\u00FA',\n  'ubrcy': '\\u045E',\n  'ubreve': '\\u016D',\n  'ucirc': '\\u00FB',\n  'ucy': '\\u0443',\n  'udblac': '\\u0171',\n  'ufisht': '\\u297E',\n  'ufr': '\\uD835\\uDD32',\n  'ugrave': '\\u00F9',\n  'uhblk': '\\u2580',\n  'ulcorn': '\\u231C',\n  'ulcorner': '\\u231C',\n  'ulcrop': '\\u230F',\n  'ultri': '\\u25F8',\n  'umacr': '\\u016B',\n  'uogon': '\\u0173',\n  'uopf': '\\uD835\\uDD66',\n  'upsi': '\\u03C5',\n  'upsilon': '\\u03C5',\n  'upuparrows': '\\u21C8',\n  'uuarr': '\\u21C8',\n  'urcorn': '\\u231D',\n  'urcorner': '\\u231D',\n  'urcrop': '\\u230E',\n  'uring': '\\u016F',\n  'urtri': '\\u25F9',\n  'uscr': '\\uD835\\uDCCA',\n  'utdot': '\\u22F0',\n  'utilde': '\\u0169',\n  'uuml': '\\u00FC',\n  'uwangle': '\\u29A7',\n  'vBar': '\\u2AE8',\n  'vBarv': '\\u2AE9',\n  'vangrt': '\\u299C',\n  'varsubsetneq': '\\u228A\\uFE00',\n  'vsubne': '\\u228A\\uFE00',\n  'varsubsetneqq': '\\u2ACB\\uFE00',\n  'vsubnE': '\\u2ACB\\uFE00',\n  'varsupsetneq': '\\u228B\\uFE00',\n  'vsupne': '\\u228B\\uFE00',\n  'varsupsetneqq': '\\u2ACC\\uFE00',\n  'vsupnE': '\\u2ACC\\uFE00',\n  'vcy': '\\u0432',\n  'veebar': '\\u22BB',\n  'veeeq': '\\u225A',\n  'vellip': '\\u22EE',\n  'vfr': '\\uD835\\uDD33',\n  'vopf': '\\uD835\\uDD67',\n  'vscr': '\\uD835\\uDCCB',\n  'vzigzag': '\\u299A',\n  'wcirc': '\\u0175',\n  'wedbar': '\\u2A5F',\n  'wedgeq': '\\u2259',\n  'weierp': '\\u2118',\n  'wp': '\\u2118',\n  'wfr': '\\uD835\\uDD34',\n  'wopf': '\\uD835\\uDD68',\n  'wscr': '\\uD835\\uDCCC',\n  'xfr': '\\uD835\\uDD35',\n  'xi': '\\u03BE',\n  'xnis': '\\u22FB',\n  'xopf': '\\uD835\\uDD69',\n  'xscr': '\\uD835\\uDCCD',\n  'yacute': '\\u00FD',\n  'yacy': '\\u044F',\n  'ycirc': '\\u0177',\n  'ycy': '\\u044B',\n  'yen': '\\u00A5',\n  'yfr': '\\uD835\\uDD36',\n  'yicy': '\\u0457',\n  'yopf': '\\uD835\\uDD6A',\n  'yscr': '\\uD835\\uDCCE',\n  'yucy': '\\u044E',\n  'yuml': '\\u00FF',\n  'zacute': '\\u017A',\n  'zcaron': '\\u017E',\n  'zcy': '\\u0437',\n  'zdot': '\\u017C',\n  'zeta': '\\u03B6',\n  'zfr': '\\uD835\\uDD37',\n  'zhcy': '\\u0436',\n  'zigrarr': '\\u21DD',\n  'zopf': '\\uD835\\uDD6B',\n  'zscr': '\\uD835\\uDCCF',\n  'zwj': '\\u200D',\n  'zwnj': '\\u200C'\n};\nconst NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\nclass TokenizeResult {\n  tokens;\n  errors;\n  nonNormalizedIcuExpressions;\n  constructor(tokens, errors, nonNormalizedIcuExpressions) {\n    this.tokens = tokens;\n    this.errors = errors;\n    this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n  }\n}\nfunction tokenize(source, url, getTagDefinition, options = {}) {\n  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\nfunction _unexpectedCharacterErrorMsg(charCode) {\n  const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\nfunction _unknownEntityErrorMsg(entitySrc) {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\nfunction _unparsableEntityErrorMsg(type, entityStr) {\n  return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\n}\nvar CharacterReferenceType = /*#__PURE__*/function (CharacterReferenceType) {\n  CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\n  CharacterReferenceType[\"DEC\"] = \"decimal\";\n  return CharacterReferenceType;\n}(CharacterReferenceType || {});\nconst SUPPORTED_BLOCKS = ['@if', '@else', '@for', '@switch', '@case', '@default', '@empty', '@defer', '@placeholder', '@loading', '@error'];\nconst INTERPOLATION = {\n  start: '{{',\n  end: '}}'\n};\nclass _Tokenizer {\n  _getTagDefinition;\n  _cursor;\n  _tokenizeIcu;\n  _leadingTriviaCodePoints;\n  _currentTokenStart = null;\n  _currentTokenType = null;\n  _expansionCaseStack = [];\n  _openDirectiveCount = 0;\n  _inInterpolation = false;\n  _preserveLineEndings;\n  _i18nNormalizeLineEndingsInICUs;\n  _tokenizeBlocks;\n  _tokenizeLet;\n  _selectorlessEnabled;\n  tokens = [];\n  errors = [];\n  nonNormalizedIcuExpressions = [];\n  constructor(_file, _getTagDefinition, options) {\n    this._getTagDefinition = _getTagDefinition;\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n    const range = options.range || {\n      endPos: _file.content.length,\n      startPos: 0,\n      startLine: 0,\n      startCol: 0\n    };\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n    this._tokenizeBlocks = options.tokenizeBlocks ?? true;\n    this._tokenizeLet = options.tokenizeLet ?? true;\n    this._selectorlessEnabled = options.selectorlessEnabled ?? false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n  _processCarriageReturns(content) {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n  tokenize() {\n    while (this._cursor.peek() !== $EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode($LT)) {\n          if (this._attemptCharCode($BANG)) {\n            if (this._attemptCharCode($LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode($MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode($SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (this._tokenizeLet && this._cursor.peek() === $AT && !this._inInterpolation && this._isLetStart()) {\n          this._consumeLetDeclaration(start);\n        } else if (this._tokenizeBlocks && this._isBlockStart()) {\n          this._consumeBlockStart(start);\n        } else if (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode($RBRACE)) {\n          this._consumeBlockEnd(start);\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(41);\n    this._endToken([]);\n  }\n  _getBlockName() {\n    let spacesInNameAllowed = false;\n    const nameCursor = this._cursor.clone();\n    this._attemptCharCodeUntilFn(code => {\n      if (isWhitespace(code)) {\n        return !spacesInNameAllowed;\n      }\n      if (isBlockNameChar(code)) {\n        spacesInNameAllowed = true;\n        return false;\n      }\n      return true;\n    });\n    return this._cursor.getChars(nameCursor).trim();\n  }\n  _consumeBlockStart(start) {\n    this._requireCharCode($AT);\n    this._beginToken(24, start);\n    const startToken = this._endToken([this._getBlockName()]);\n    if (this._cursor.peek() === $LPAREN) {\n      this._cursor.advance();\n      this._consumeBlockParameters();\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (this._attemptCharCode($RPAREN)) {\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        startToken.type = 28;\n        return;\n      }\n    }\n    if (this._attemptCharCode($LBRACE)) {\n      this._beginToken(25);\n      this._endToken([]);\n    } else {\n      startToken.type = 28;\n    }\n  }\n  _consumeBlockEnd(start) {\n    this._beginToken(26, start);\n    this._endToken([]);\n  }\n  _consumeBlockParameters() {\n    this._attemptCharCodeUntilFn(isBlockParameterChar);\n    while (this._cursor.peek() !== $RPAREN && this._cursor.peek() !== $EOF) {\n      this._beginToken(27);\n      const start = this._cursor.clone();\n      let inQuote = null;\n      let openParens = 0;\n      while (this._cursor.peek() !== $SEMICOLON && this._cursor.peek() !== $EOF || inQuote !== null) {\n        const char = this._cursor.peek();\n        if (char === $BACKSLASH) {\n          this._cursor.advance();\n        } else if (char === inQuote) {\n          inQuote = null;\n        } else if (inQuote === null && isQuote(char)) {\n          inQuote = char;\n        } else if (char === $LPAREN && inQuote === null) {\n          openParens++;\n        } else if (char === $RPAREN && inQuote === null) {\n          if (openParens === 0) {\n            break;\n          } else if (openParens > 0) {\n            openParens--;\n          }\n        }\n        this._cursor.advance();\n      }\n      this._endToken([this._cursor.getChars(start)]);\n      this._attemptCharCodeUntilFn(isBlockParameterChar);\n    }\n  }\n  _consumeLetDeclaration(start) {\n    this._requireStr('@let');\n    this._beginToken(29, start);\n    if (isWhitespace(this._cursor.peek())) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n    } else {\n      const token = this._endToken([this._cursor.getChars(start)]);\n      token.type = 32;\n      return;\n    }\n    const startToken = this._endToken([this._getLetDeclarationName()]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (!this._attemptCharCode($EQ)) {\n      startToken.type = 32;\n      return;\n    }\n    this._attemptCharCodeUntilFn(code => isNotWhitespace(code) && !isNewLine(code));\n    this._consumeLetDeclarationValue();\n    const endChar = this._cursor.peek();\n    if (endChar === $SEMICOLON) {\n      this._beginToken(31);\n      this._endToken([]);\n      this._cursor.advance();\n    } else {\n      startToken.type = 32;\n      startToken.sourceSpan = this._cursor.getSpan(start);\n    }\n  }\n  _getLetDeclarationName() {\n    const nameCursor = this._cursor.clone();\n    let allowDigit = false;\n    this._attemptCharCodeUntilFn(code => {\n      if (isAsciiLetter(code) || code === $$ || code === $_ || allowDigit && isDigit(code)) {\n        allowDigit = true;\n        return false;\n      }\n      return true;\n    });\n    return this._cursor.getChars(nameCursor).trim();\n  }\n  _consumeLetDeclarationValue() {\n    const start = this._cursor.clone();\n    this._beginToken(30, start);\n    while (this._cursor.peek() !== $EOF) {\n      const char = this._cursor.peek();\n      if (char === $SEMICOLON) {\n        break;\n      }\n      if (isQuote(char)) {\n        this._cursor.advance();\n        this._attemptCharCodeUntilFn(inner => {\n          if (inner === $BACKSLASH) {\n            this._cursor.advance();\n            return false;\n          }\n          return inner === char;\n        });\n      }\n      this._cursor.advance();\n    }\n    this._endToken([this._cursor.getChars(start)]);\n  }\n  _tokenizeExpansionForm() {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n    if (this._cursor.peek() === $RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n    return false;\n  }\n  _beginToken(type, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n  _endToken(parts, end) {\n    if (this._currentTokenStart === null) {\n      throw new ParseError(this._cursor.getSpan(end), 'Programming error - attempted to end a token when there was no start to the token');\n    }\n    if (this._currentTokenType === null) {\n      throw new ParseError(this._cursor.getSpan(this._currentTokenStart), 'Programming error - attempted to end a token which has no token type');\n    }\n    const token = {\n      type: this._currentTokenType,\n      parts,\n      sourceSpan: (end ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints)\n    };\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n  _createError(msg, span) {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new ParseError(span, msg);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return error;\n  }\n  handleError(e) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof ParseError) {\n      this.errors.push(e);\n    } else {\n      throw e;\n    }\n  }\n  _attemptCharCode(charCode) {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n  _attemptCharCodeCaseInsensitive(charCode) {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n  _requireCharCode(charCode) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n  _attemptStr(chars) {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n  _attemptStrCaseInsensitive(chars) {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _requireStr(chars) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n  _attemptCharCodeUntilFn(predicate) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n  _requireCharCodeUntilFn(predicate, len) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n  }\n  _attemptUntilChar(char) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n  _readChar() {\n    const char = String.fromCodePoint(this._cursor.peek());\n    this._cursor.advance();\n    return char;\n  }\n  _peekStr(chars) {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const cursor = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (cursor.peek() !== chars.charCodeAt(i)) {\n        return false;\n      }\n      cursor.advance();\n    }\n    return true;\n  }\n  _isBlockStart() {\n    return this._cursor.peek() === $AT && SUPPORTED_BLOCKS.some(blockName => this._peekStr(blockName));\n  }\n  _isLetStart() {\n    return this._cursor.peek() === $AT && this._peekStr('@let');\n  }\n  _consumeEntity(textTokenType) {\n    this._beginToken(9);\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode($HASH)) {\n      const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != $SEMICOLON) {\n        this._cursor.advance();\n        const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n        throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        this._endToken([String.fromCodePoint(charCode), this._cursor.getChars(start)]);\n      } catch {\n        throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != $SEMICOLON) {\n        this._beginToken(textTokenType, start);\n        this._cursor = nameStart;\n        this._endToken(['&']);\n      } else {\n        const name = this._cursor.getChars(nameStart);\n        this._cursor.advance();\n        const char = NAMED_ENTITIES.hasOwnProperty(name) && NAMED_ENTITIES[name];\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n        this._endToken([char, `&${name};`]);\n      }\n    }\n  }\n  _consumeRawText(consumeEntities, endMarkerPredicate) {\n    this._beginToken(consumeEntities ? 6 : 7);\n    const parts = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      if (consumeEntities && this._cursor.peek() === $AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(6);\n        this._beginToken(6);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n  _consumeComment(start) {\n    this._beginToken(10, start);\n    this._requireCharCode($MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(11);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n  _consumeCdata(start) {\n    this._beginToken(12, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(13);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n  _consumeDocType(start) {\n    this._beginToken(18, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar($GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n  _consumePrefixAndName(endPredicate) {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix = '';\n    while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart;\n    if (this._cursor.peek() === $COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(endPredicate, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n  _consumeTagOpen(start) {\n    let tagName;\n    let prefix;\n    let closingTagName;\n    let openToken;\n    try {\n      if (this._selectorlessEnabled && isSelectorlessNameStart(this._cursor.peek())) {\n        openToken = this._consumeComponentOpenStart(start);\n        [closingTagName, prefix, tagName] = openToken.parts;\n        if (prefix) {\n          closingTagName += `:${prefix}`;\n        }\n        if (tagName) {\n          closingTagName += `:${tagName}`;\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        if (!isAsciiLetter(this._cursor.peek())) {\n          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n        openToken = this._consumeTagOpenStart(start);\n        prefix = openToken.parts[0];\n        tagName = closingTagName = openToken.parts[1];\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      while (!isAttributeTerminator(this._cursor.peek())) {\n        if (this._selectorlessEnabled && this._cursor.peek() === $AT) {\n          const start = this._cursor.clone();\n          const nameStart = start.clone();\n          nameStart.advance();\n          if (isSelectorlessNameStart(nameStart.peek())) {\n            this._consumeDirective(start, nameStart);\n          }\n        } else {\n          this._consumeAttribute();\n        }\n      }\n      if (openToken.type === 33) {\n        this._consumeComponentOpenEnd();\n      } else {\n        this._consumeTagOpenEnd();\n      }\n    } catch (e) {\n      if (e instanceof ParseError) {\n        if (openToken) {\n          openToken.type = openToken.type === 33 ? 37 : 4;\n        } else {\n          this._beginToken(5, start);\n          this._endToken(['<']);\n        }\n        return;\n      }\n      throw e;\n    }\n    const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, true);\n    }\n  }\n  _consumeRawTextWithTagClose(openToken, tagName, consumeEntities) {\n    this._consumeRawText(consumeEntities, () => {\n      if (!this._attemptCharCode($LT)) return false;\n      if (!this._attemptCharCode($SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode($GT);\n    });\n    this._beginToken(openToken.type === 33 ? 36 : 3);\n    this._requireCharCodeUntilFn(code => code === $GT, 3);\n    this._cursor.advance();\n    this._endToken(openToken.parts);\n  }\n  _consumeTagOpenStart(start) {\n    this._beginToken(0, start);\n    const parts = this._consumePrefixAndName(isNameEnd);\n    return this._endToken(parts);\n  }\n  _consumeComponentOpenStart(start) {\n    this._beginToken(33, start);\n    const parts = this._consumeComponentName();\n    return this._endToken(parts);\n  }\n  _consumeComponentName() {\n    const nameStart = this._cursor.clone();\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    const name = this._cursor.getChars(nameStart);\n    let prefix = '';\n    let tagName = '';\n    if (this._cursor.peek() === $COLON) {\n      this._cursor.advance();\n      [prefix, tagName] = this._consumePrefixAndName(isNameEnd);\n    }\n    return [name, prefix, tagName];\n  }\n  _consumeAttribute() {\n    this._consumeAttributeName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (this._attemptCharCode($EQ)) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      this._consumeAttributeValue();\n    }\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === $SQ || attrNameStart === $DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(14);\n    let nameEndPredicate;\n    if (this._openDirectiveCount > 0) {\n      let openParens = 0;\n      nameEndPredicate = code => {\n        if (this._openDirectiveCount > 0) {\n          if (code === $LPAREN) {\n            openParens++;\n          } else if (code === $RPAREN) {\n            if (openParens === 0) {\n              return true;\n            }\n            openParens--;\n          }\n        }\n        return isNameEnd(code);\n      };\n    } else if (attrNameStart === $LBRACKET) {\n      let openBrackets = 0;\n      nameEndPredicate = code => {\n        if (code === $LBRACKET) {\n          openBrackets++;\n        } else if (code === $RBRACKET) {\n          openBrackets--;\n        }\n        return openBrackets <= 0 ? isNameEnd(code) : isNewLine(code);\n      };\n    } else {\n      nameEndPredicate = isNameEnd;\n    }\n    const prefixAndName = this._consumePrefixAndName(nameEndPredicate);\n    this._endToken(prefixAndName);\n  }\n  _consumeAttributeValue() {\n    if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n      const quoteChar = this._cursor.peek();\n      this._consumeQuote(quoteChar);\n      const endPredicate = () => this._cursor.peek() === quoteChar;\n      this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);\n      this._consumeQuote(quoteChar);\n    } else {\n      const endPredicate = () => isNameEnd(this._cursor.peek());\n      this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);\n    }\n  }\n  _consumeQuote(quoteChar) {\n    this._beginToken(15);\n    this._requireCharCode(quoteChar);\n    this._endToken([String.fromCodePoint(quoteChar)]);\n  }\n  _consumeTagOpenEnd() {\n    const tokenType = this._attemptCharCode($SLASH) ? 2 : 1;\n    this._beginToken(tokenType);\n    this._requireCharCode($GT);\n    this._endToken([]);\n  }\n  _consumeComponentOpenEnd() {\n    const tokenType = this._attemptCharCode($SLASH) ? 35 : 34;\n    this._beginToken(tokenType);\n    this._requireCharCode($GT);\n    this._endToken([]);\n  }\n  _consumeTagClose(start) {\n    if (this._selectorlessEnabled) {\n      const clone = start.clone();\n      while (clone.peek() !== $GT && !isSelectorlessNameStart(clone.peek())) {\n        clone.advance();\n      }\n      if (isSelectorlessNameStart(clone.peek())) {\n        this._beginToken(36, start);\n        const parts = this._consumeComponentName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(parts);\n        return;\n      }\n    }\n    this._beginToken(3, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName(isNameEnd);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode($GT);\n    this._endToken(prefixAndName);\n  }\n  _consumeExpansionFormStart() {\n    this._beginToken(19);\n    this._requireCharCode($LBRACE);\n    this._endToken([]);\n    this._expansionCaseStack.push(19);\n    this._beginToken(7);\n    const condition = this._readUntil($COMMA);\n    const normalizedCondition = this._processCarriageReturns(condition);\n    if (this._i18nNormalizeLineEndingsInICUs) {\n      this._endToken([normalizedCondition]);\n    } else {\n      const conditionToken = this._endToken([condition]);\n      if (normalizedCondition !== condition) {\n        this.nonNormalizedIcuExpressions.push(conditionToken);\n      }\n    }\n    this._requireCharCode($COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._beginToken(7);\n    const type = this._readUntil($COMMA);\n    this._endToken([type]);\n    this._requireCharCode($COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _consumeExpansionCaseStart() {\n    this._beginToken(20);\n    const value = this._readUntil($LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._beginToken(21);\n    this._requireCharCode($LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._expansionCaseStack.push(21);\n  }\n  _consumeExpansionCaseEnd() {\n    this._beginToken(22);\n    this._requireCharCode($RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._expansionCaseStack.pop();\n  }\n  _consumeExpansionFormEnd() {\n    this._beginToken(23);\n    this._requireCharCode($RBRACE);\n    this._endToken([]);\n    this._expansionCaseStack.pop();\n  }\n  _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {\n    this._beginToken(textTokenType);\n    const parts = [];\n    while (!endPredicate()) {\n      const current = this._cursor.clone();\n      if (this._attemptStr(INTERPOLATION.start)) {\n        this._endToken([this._processCarriageReturns(parts.join(''))], current);\n        parts.length = 0;\n        this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n        this._beginToken(textTokenType);\n      } else if (this._cursor.peek() === $AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(textTokenType);\n        this._beginToken(textTokenType);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._inInterpolation = false;\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n  _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {\n    const parts = [];\n    this._beginToken(interpolationTokenType, interpolationStart);\n    parts.push(INTERPOLATION.start);\n    const expressionStart = this._cursor.clone();\n    let inQuote = null;\n    let inComment = false;\n    while (this._cursor.peek() !== $EOF && (prematureEndPredicate === null || !prematureEndPredicate())) {\n      const current = this._cursor.clone();\n      if (this._isTagStart()) {\n        this._cursor = current;\n        parts.push(this._getProcessedChars(expressionStart, current));\n        this._endToken(parts);\n        return;\n      }\n      if (inQuote === null) {\n        if (this._attemptStr(INTERPOLATION.end)) {\n          parts.push(this._getProcessedChars(expressionStart, current));\n          parts.push(INTERPOLATION.end);\n          this._endToken(parts);\n          return;\n        } else if (this._attemptStr('//')) {\n          inComment = true;\n        }\n      }\n      const char = this._cursor.peek();\n      this._cursor.advance();\n      if (char === $BACKSLASH) {\n        this._cursor.advance();\n      } else if (char === inQuote) {\n        inQuote = null;\n      } else if (!inComment && inQuote === null && isQuote(char)) {\n        inQuote = char;\n      }\n    }\n    parts.push(this._getProcessedChars(expressionStart, this._cursor));\n    this._endToken(parts);\n  }\n  _consumeDirective(start, nameStart) {\n    this._requireCharCode($AT);\n    this._cursor.advance();\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    this._beginToken(38, start);\n    const name = this._cursor.getChars(nameStart);\n    this._endToken([name]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (this._cursor.peek() !== $LPAREN) {\n      return;\n    }\n    this._openDirectiveCount++;\n    this._beginToken(39);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    while (!isAttributeTerminator(this._cursor.peek()) && this._cursor.peek() !== $RPAREN) {\n      this._consumeAttribute();\n    }\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._openDirectiveCount--;\n    if (this._cursor.peek() !== $RPAREN) {\n      if (this._cursor.peek() === $GT || this._cursor.peek() === $SLASH) {\n        return;\n      }\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n    this._beginToken(40);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _getProcessedChars(start, end) {\n    return this._processCarriageReturns(end.getChars(start));\n  }\n  _isTextEnd() {\n    if (this._isTagStart() || this._cursor.peek() === $EOF) {\n      return true;\n    }\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        return true;\n      }\n      if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n        return true;\n      }\n    }\n    if (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._isLetStart() || this._cursor.peek() === $RBRACE)) {\n      return true;\n    }\n    return false;\n  }\n  _isTagStart() {\n    if (this._cursor.peek() === $LT) {\n      const tmp = this._cursor.clone();\n      tmp.advance();\n      const code = tmp.peek();\n      if ($a <= code && code <= $z || $A <= code && code <= $Z || code === $SLASH || code === $BANG) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _readUntil(char) {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n  _isInExpansion() {\n    return this._isInExpansionCase() || this._isInExpansionForm();\n  }\n  _isInExpansionCase() {\n    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 21;\n  }\n  _isInExpansionForm() {\n    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 19;\n  }\n  isExpansionFormStart() {\n    if (this._cursor.peek() !== $LBRACE) {\n      return false;\n    }\n    const start = this._cursor.clone();\n    const isInterpolation = this._attemptStr(INTERPOLATION.start);\n    this._cursor = start;\n    return !isInterpolation;\n  }\n}\nfunction isNotWhitespace(code) {\n  return !isWhitespace(code) || code === $EOF;\n}\nfunction isNameEnd(code) {\n  return isWhitespace(code) || code === $GT || code === $LT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ || code === $EOF;\n}\nfunction isPrefixEnd(code) {\n  return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);\n}\nfunction isDigitEntityEnd(code) {\n  return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);\n}\nfunction isNamedEntityEnd(code) {\n  return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);\n}\nfunction isExpansionCaseStart(peek) {\n  return peek !== $RBRACE;\n}\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\nfunction toUpperCaseCharCode(code) {\n  return code >= $a && code <= $z ? code - $a + $A : code;\n}\nfunction isBlockNameChar(code) {\n  return isAsciiLetter(code) || isDigit(code) || code === $_;\n}\nfunction isBlockParameterChar(code) {\n  return code !== $SEMICOLON && isNotWhitespace(code);\n}\nfunction isSelectorlessNameStart(code) {\n  return code === $_ || code >= $A && code <= $Z;\n}\nfunction isSelectorlessNameChar(code) {\n  return isAsciiLetter(code) || isDigit(code) || code === $_;\n}\nfunction isAttributeTerminator(code) {\n  return code === $SLASH || code === $GT || code === $LT || code === $EOF;\n}\nfunction mergeTextTokens(srcTokens) {\n  const dstTokens = [];\n  let lastDstToken = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type === 5 && token.type === 5 || lastDstToken && lastDstToken.type === 16 && token.type === 16) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n  return dstTokens;\n}\nclass PlainCharacterCursor {\n  state;\n  file;\n  input;\n  end;\n  constructor(fileOrCursor, range) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n      const state = fileOrCursor.state;\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column\n      };\n    } else {\n      if (!range) {\n        throw new Error('Programming error: the range argument must be provided with a file argument.');\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol\n      };\n    }\n  }\n  clone() {\n    return new PlainCharacterCursor(this);\n  }\n  peek() {\n    return this.state.peek;\n  }\n  charsLeft() {\n    return this.end - this.state.offset;\n  }\n  diff(other) {\n    return this.state.offset - other.state.offset;\n  }\n  advance() {\n    this.advanceState(this.state);\n  }\n  init() {\n    this.updatePeek(this.state);\n  }\n  getSpan(start, leadingTriviaCodePoints) {\n    start = start || this;\n    let fullStart = start;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (fullStart === start) {\n          start = start.clone();\n        }\n        start.advance();\n      }\n    }\n    const startLocation = this.locationFromCursor(start);\n    const endLocation = this.locationFromCursor(this);\n    const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n  }\n  getChars(start) {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n  charAt(pos) {\n    return this.input.charCodeAt(pos);\n  }\n  advanceState(state) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === $LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n  updatePeek(state) {\n    state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n  }\n  locationFromCursor(cursor) {\n    return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n  }\n}\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  internalState;\n  constructor(fileOrCursor, range) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {\n        ...fileOrCursor.internalState\n      };\n    } else {\n      super(fileOrCursor, range);\n      this.internalState = this.state;\n    }\n  }\n  advance() {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n  init() {\n    super.init();\n    this.processEscapeSequence();\n  }\n  clone() {\n    return new EscapedCharacterCursor(this);\n  }\n  getChars(start) {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n  processEscapeSequence() {\n    const peek = () => this.internalState.peek;\n    if (peek() === $BACKSLASH) {\n      this.internalState = {\n        ...this.state\n      };\n      this.advanceState(this.internalState);\n      if (peek() === $n) {\n        this.state.peek = $LF;\n      } else if (peek() === $r) {\n        this.state.peek = $CR;\n      } else if (peek() === $v) {\n        this.state.peek = $VTAB;\n      } else if (peek() === $t) {\n        this.state.peek = $TAB;\n      } else if (peek() === $b) {\n        this.state.peek = $BSPACE;\n      } else if (peek() === $f) {\n        this.state.peek = $FF;\n      } else if (peek() === $u) {\n        this.advanceState(this.internalState);\n        if (peek() === $LBRACE) {\n          this.advanceState(this.internalState);\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== $RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      } else if (peek() === $x) {\n        this.advanceState(this.internalState);\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      } else if (isOctalDigit(peek())) {\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        this.internalState = previous.internalState;\n      } else if (isNewLine(this.internalState.peek)) {\n        this.advanceState(this.internalState);\n        this.state = this.internalState;\n      } else {\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n  decodeHexDigits(start, length) {\n    const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\nclass CursorError extends Error {\n  msg;\n  cursor;\n  constructor(msg, cursor) {\n    super(msg);\n    this.msg = msg;\n    this.cursor = cursor;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\nclass TreeError extends ParseError {\n  elementName;\n  static create(elementName, span, msg) {\n    return new TreeError(elementName, span, msg);\n  }\n  constructor(elementName, span, msg) {\n    super(span, msg);\n    this.elementName = elementName;\n  }\n}\nclass ParseTreeResult {\n  rootNodes;\n  errors;\n  constructor(rootNodes, errors) {\n    this.rootNodes = rootNodes;\n    this.errors = errors;\n  }\n}\nlet Parser$1 = class Parser {\n  getTagDefinition;\n  constructor(getTagDefinition) {\n    this.getTagDefinition = getTagDefinition;\n  }\n  parse(source, url, options) {\n    const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n    const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n    parser.build();\n    return new ParseTreeResult(parser.rootNodes, [...tokenizeResult.errors, ...parser.errors]);\n  }\n};\nclass _TreeBuilder {\n  tokens;\n  tagDefinitionResolver;\n  _index = -1;\n  _peek;\n  _containerStack = [];\n  rootNodes = [];\n  errors = [];\n  constructor(tokens, tagDefinitionResolver) {\n    this.tokens = tokens;\n    this.tagDefinitionResolver = tagDefinitionResolver;\n    this._advance();\n  }\n  build() {\n    while (this._peek.type !== 41) {\n      if (this._peek.type === 0 || this._peek.type === 4) {\n        this._consumeElementStartTag(this._advance());\n      } else if (this._peek.type === 3) {\n        this._consumeElementEndTag(this._advance());\n      } else if (this._peek.type === 12) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === 10) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === 19) {\n        this._consumeExpansion(this._advance());\n      } else if (this._peek.type === 24) {\n        this._closeVoidElement();\n        this._consumeBlockOpen(this._advance());\n      } else if (this._peek.type === 26) {\n        this._closeVoidElement();\n        this._consumeBlockClose(this._advance());\n      } else if (this._peek.type === 28) {\n        this._closeVoidElement();\n        this._consumeIncompleteBlock(this._advance());\n      } else if (this._peek.type === 29) {\n        this._closeVoidElement();\n        this._consumeLet(this._advance());\n      } else if (this._peek.type === 32) {\n        this._closeVoidElement();\n        this._consumeIncompleteLet(this._advance());\n      } else if (this._peek.type === 33 || this._peek.type === 37) {\n        this._consumeComponentStartTag(this._advance());\n      } else if (this._peek.type === 36) {\n        this._consumeComponentEndTag(this._advance());\n      } else {\n        this._advance();\n      }\n    }\n    for (const leftoverContainer of this._containerStack) {\n      if (leftoverContainer instanceof Block) {\n        this.errors.push(TreeError.create(leftoverContainer.name, leftoverContainer.sourceSpan, `Unclosed block \"${leftoverContainer.name}\"`));\n      }\n    }\n  }\n  _advance() {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev;\n  }\n  _advanceIf(type) {\n    if (this._peek.type === type) {\n      return this._advance();\n    }\n    return null;\n  }\n  _consumeCdata(_startToken) {\n    this._consumeText(this._advance());\n    this._advanceIf(13);\n  }\n  _consumeComment(token) {\n    const text = this._advanceIf(7);\n    const endToken = this._advanceIf(11);\n    const value = text != null ? text.parts[0].trim() : null;\n    const sourceSpan = endToken == null ? token.sourceSpan : new ParseSourceSpan(token.sourceSpan.start, endToken.sourceSpan.end, token.sourceSpan.fullStart);\n    this._addToParent(new Comment(value, sourceSpan));\n  }\n  _consumeExpansion(token) {\n    const switchValue = this._advance();\n    const type = this._advance();\n    const cases = [];\n    while (this._peek.type === 20) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) return;\n      cases.push(expCase);\n    }\n    if (this._peek.type !== 23) {\n      this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n    this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n    this._advance();\n  }\n  _parseExpansionCase() {\n    const value = this._advance();\n    if (this._peek.type !== 21) {\n      this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n    const start = this._advance();\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) return null;\n    const end = this._advance();\n    exp.push({\n      type: 41,\n      parts: [],\n      sourceSpan: end.sourceSpan\n    });\n    const expansionCaseParser = new _TreeBuilder(exp, this.tagDefinitionResolver);\n    expansionCaseParser.build();\n    if (expansionCaseParser.errors.length > 0) {\n      this.errors = this.errors.concat(expansionCaseParser.errors);\n      return null;\n    }\n    const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n    const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n    return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n  _collectExpansionExpTokens(start) {\n    const exp = [];\n    const expansionFormStack = [21];\n    while (true) {\n      if (this._peek.type === 19 || this._peek.type === 21) {\n        expansionFormStack.push(this._peek.type);\n      }\n      if (this._peek.type === 22) {\n        if (lastOnStack(expansionFormStack, 21)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) return exp;\n        } else {\n          this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n      if (this._peek.type === 23) {\n        if (lastOnStack(expansionFormStack, 19)) {\n          expansionFormStack.pop();\n        } else {\n          this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n      if (this._peek.type === 41) {\n        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n      exp.push(this._advance());\n    }\n  }\n  _consumeText(token) {\n    const tokens = [token];\n    const startSpan = token.sourceSpan;\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === '\\n') {\n      const parent = this._getContainer();\n      if (parent != null && parent.children.length === 0 && this._getTagDefinition(parent)?.ignoreFirstLf) {\n        text = text.substring(1);\n        tokens[0] = {\n          type: token.type,\n          sourceSpan: token.sourceSpan,\n          parts: [text]\n        };\n      }\n    }\n    while (this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9) {\n      token = this._advance();\n      tokens.push(token);\n      if (token.type === 8) {\n        text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n      } else if (token.type === 9) {\n        text += token.parts[0];\n      } else {\n        text += token.parts.join('');\n      }\n    }\n    if (text.length > 0) {\n      const endSpan = token.sourceSpan;\n      this._addToParent(new Text(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));\n    }\n  }\n  _closeVoidElement() {\n    const el = this._getContainer();\n    if (el !== null && this._getTagDefinition(el)?.isVoid) {\n      this._containerStack.pop();\n    }\n  }\n  _consumeElementStartTag(startTagToken) {\n    const attrs = [];\n    const directives = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n    const fullName = this._getElementFullName(startTagToken, this._getClosestElementLikeParent());\n    const tagDef = this._getTagDefinition(fullName);\n    let selfClosing = false;\n    if (this._peek.type === 2) {\n      this._advance();\n      selfClosing = true;\n      if (!(tagDef?.canSelfClose || getNsPrefix(fullName) !== null || tagDef?.isVoid)) {\n        this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void, custom and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n      }\n    } else if (this._peek.type === 1) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    const el = new Element(fullName, attrs, directives, [], selfClosing, span, startSpan, undefined, tagDef?.isVoid ?? false);\n    const parent = this._getContainer();\n    const isClosedByChild = parent !== null && !!this._getTagDefinition(parent)?.isClosedByChild(el.name);\n    this._pushContainer(el, isClosedByChild);\n    if (selfClosing) {\n      this._popContainer(fullName, Element, span);\n    } else if (startTagToken.type === 4) {\n      this._popContainer(fullName, Element, null);\n      this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n    }\n  }\n  _consumeComponentStartTag(startToken) {\n    const componentName = startToken.parts[0];\n    const attrs = [];\n    const directives = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n    const closestElement = this._getClosestElementLikeParent();\n    const tagName = this._getComponentTagName(startToken, closestElement);\n    const fullName = this._getComponentFullName(startToken, closestElement);\n    const selfClosing = this._peek.type === 35;\n    this._advance();\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const node = new Component(componentName, tagName, fullName, attrs, directives, [], selfClosing, span, startSpan, undefined);\n    const parent = this._getContainer();\n    const isClosedByChild = parent !== null && node.tagName !== null && !!this._getTagDefinition(parent)?.isClosedByChild(node.tagName);\n    this._pushContainer(node, isClosedByChild);\n    if (selfClosing) {\n      this._popContainer(fullName, Component, span);\n    } else if (startToken.type === 37) {\n      this._popContainer(fullName, Component, null);\n      this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n    }\n  }\n  _consumeAttributesAndDirectives(attributesResult, directivesResult) {\n    while (this._peek.type === 14 || this._peek.type === 38) {\n      if (this._peek.type === 38) {\n        directivesResult.push(this._consumeDirective(this._peek));\n      } else {\n        attributesResult.push(this._consumeAttr(this._advance()));\n      }\n    }\n  }\n  _consumeComponentEndTag(endToken) {\n    const fullName = this._getComponentFullName(endToken, this._getClosestElementLikeParent());\n    if (!this._popContainer(fullName, Component, endToken.sourceSpan)) {\n      const container = this._containerStack[this._containerStack.length - 1];\n      let suffix;\n      if (container instanceof Component && container.componentName === endToken.parts[0]) {\n        suffix = `, did you mean \"${container.fullName}\"?`;\n      } else {\n        suffix = '. It may happen when the tag has already been closed by another tag.';\n      }\n      const errMsg = `Unexpected closing tag \"${fullName}\"${suffix}`;\n      this.errors.push(TreeError.create(fullName, endToken.sourceSpan, errMsg));\n    }\n  }\n  _getTagDefinition(nodeOrName) {\n    if (typeof nodeOrName === 'string') {\n      return this.tagDefinitionResolver(nodeOrName);\n    } else if (nodeOrName instanceof Element) {\n      return this.tagDefinitionResolver(nodeOrName.name);\n    } else if (nodeOrName instanceof Component && nodeOrName.tagName !== null) {\n      return this.tagDefinitionResolver(nodeOrName.tagName);\n    } else {\n      return null;\n    }\n  }\n  _pushContainer(node, isClosedByChild) {\n    if (isClosedByChild) {\n      this._containerStack.pop();\n    }\n    this._addToParent(node);\n    this._containerStack.push(node);\n  }\n  _consumeElementEndTag(endTagToken) {\n    const fullName = this._getElementFullName(endTagToken, this._getClosestElementLikeParent());\n    if (this._getTagDefinition(fullName)?.isVoid) {\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n    } else if (!this._popContainer(fullName, Element, endTagToken.sourceSpan)) {\n      const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n  _popContainer(expectedName, expectedType, endSourceSpan) {\n    let unexpectedCloseTagDetected = false;\n    for (let stackIndex = this._containerStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const node = this._containerStack[stackIndex];\n      const nodeName = node instanceof Component ? node.fullName : node.name;\n      if ((nodeName === expectedName || expectedName === null) && node instanceof expectedType) {\n        node.endSourceSpan = endSourceSpan;\n        node.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : node.sourceSpan.end;\n        this._containerStack.splice(stackIndex, this._containerStack.length - stackIndex);\n        return !unexpectedCloseTagDetected;\n      }\n      if (node instanceof Block || !this._getTagDefinition(node)?.closedByParent) {\n        unexpectedCloseTagDetected = true;\n      }\n    }\n    return false;\n  }\n  _consumeAttr(attrName) {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let attrEnd = attrName.sourceSpan.end;\n    if (this._peek.type === 15) {\n      this._advance();\n    }\n    let value = '';\n    const valueTokens = [];\n    let valueStartSpan = undefined;\n    let valueEnd = undefined;\n    const nextTokenType = this._peek.type;\n    if (nextTokenType === 16) {\n      valueStartSpan = this._peek.sourceSpan;\n      valueEnd = this._peek.sourceSpan.end;\n      while (this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9) {\n        const valueToken = this._advance();\n        valueTokens.push(valueToken);\n        if (valueToken.type === 17) {\n          value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n        } else if (valueToken.type === 9) {\n          value += valueToken.parts[0];\n        } else {\n          value += valueToken.parts.join('');\n        }\n        valueEnd = attrEnd = valueToken.sourceSpan.end;\n      }\n    }\n    if (this._peek.type === 15) {\n      const quoteToken = this._advance();\n      attrEnd = quoteToken.sourceSpan.end;\n    }\n    const valueSpan = valueStartSpan && valueEnd && new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n    return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);\n  }\n  _consumeDirective(nameToken) {\n    const attributes = [];\n    let startSourceSpanEnd = nameToken.sourceSpan.end;\n    let endSourceSpan = null;\n    this._advance();\n    if (this._peek.type === 39) {\n      startSourceSpanEnd = this._peek.sourceSpan.end;\n      this._advance();\n      while (this._peek.type === 14) {\n        attributes.push(this._consumeAttr(this._advance()));\n      }\n      if (this._peek.type === 40) {\n        endSourceSpan = this._peek.sourceSpan;\n        this._advance();\n      } else {\n        this.errors.push(TreeError.create(null, nameToken.sourceSpan, 'Unterminated directive definition'));\n      }\n    }\n    const startSourceSpan = new ParseSourceSpan(nameToken.sourceSpan.start, startSourceSpanEnd, nameToken.sourceSpan.fullStart);\n    const sourceSpan = new ParseSourceSpan(startSourceSpan.start, endSourceSpan === null ? nameToken.sourceSpan.end : endSourceSpan.end, startSourceSpan.fullStart);\n    return new Directive(nameToken.parts[0], attributes, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n  _consumeBlockOpen(token) {\n    const parameters = [];\n    while (this._peek.type === 27) {\n      const paramToken = this._advance();\n      parameters.push(new BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n    if (this._peek.type === 25) {\n      this._advance();\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n  }\n  _consumeBlockClose(token) {\n    if (!this._popContainer(null, Block, token.sourceSpan)) {\n      this.errors.push(TreeError.create(null, token.sourceSpan, `Unexpected closing block. The block may have been closed earlier. ` + `If you meant to write the } character, you should use the \"&#125;\" ` + `HTML entity instead.`));\n    }\n  }\n  _consumeIncompleteBlock(token) {\n    const parameters = [];\n    while (this._peek.type === 27) {\n      const paramToken = this._advance();\n      parameters.push(new BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n    this._popContainer(null, Block, null);\n    this.errors.push(TreeError.create(token.parts[0], span, `Incomplete block \"${token.parts[0]}\". If you meant to write the @ character, ` + `you should use the \"&#64;\" HTML entity instead.`));\n  }\n  _consumeLet(startToken) {\n    const name = startToken.parts[0];\n    let valueToken;\n    let endToken;\n    if (this._peek.type !== 30) {\n      this.errors.push(TreeError.create(startToken.parts[0], startToken.sourceSpan, `Invalid @let declaration \"${name}\". Declaration must have a value.`));\n      return;\n    } else {\n      valueToken = this._advance();\n    }\n    if (this._peek.type !== 31) {\n      this.errors.push(TreeError.create(startToken.parts[0], startToken.sourceSpan, `Unterminated @let declaration \"${name}\". Declaration must be terminated with a semicolon.`));\n      return;\n    } else {\n      endToken = this._advance();\n    }\n    const end = endToken.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const startOffset = startToken.sourceSpan.toString().lastIndexOf(name);\n    const nameStart = startToken.sourceSpan.start.moveBy(startOffset);\n    const nameSpan = new ParseSourceSpan(nameStart, startToken.sourceSpan.end);\n    const node = new LetDeclaration(name, valueToken.parts[0], span, nameSpan, valueToken.sourceSpan);\n    this._addToParent(node);\n  }\n  _consumeIncompleteLet(token) {\n    const name = token.parts[0] ?? '';\n    const nameString = name ? ` \"${name}\"` : '';\n    if (name.length > 0) {\n      const startOffset = token.sourceSpan.toString().lastIndexOf(name);\n      const nameStart = token.sourceSpan.start.moveBy(startOffset);\n      const nameSpan = new ParseSourceSpan(nameStart, token.sourceSpan.end);\n      const valueSpan = new ParseSourceSpan(token.sourceSpan.start, token.sourceSpan.start.moveBy(0));\n      const node = new LetDeclaration(name, '', token.sourceSpan, nameSpan, valueSpan);\n      this._addToParent(node);\n    }\n    this.errors.push(TreeError.create(token.parts[0], token.sourceSpan, `Incomplete @let declaration${nameString}. ` + `@let declarations must be written as \\`@let <name> = <value>;\\``));\n  }\n  _getContainer() {\n    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;\n  }\n  _getClosestElementLikeParent() {\n    for (let i = this._containerStack.length - 1; i > -1; i--) {\n      const current = this._containerStack[i];\n      if (current instanceof Element || current instanceof Component) {\n        return current;\n      }\n    }\n    return null;\n  }\n  _addToParent(node) {\n    const parent = this._getContainer();\n    if (parent === null) {\n      this.rootNodes.push(node);\n    } else {\n      parent.children.push(node);\n    }\n  }\n  _getElementFullName(token, parent) {\n    const prefix = this._getPrefix(token, parent);\n    return mergeNsAndName(prefix, token.parts[1]);\n  }\n  _getComponentFullName(token, parent) {\n    const componentName = token.parts[0];\n    const tagName = this._getComponentTagName(token, parent);\n    if (tagName === null) {\n      return componentName;\n    }\n    return tagName.startsWith(':') ? componentName + tagName : `${componentName}:${tagName}`;\n  }\n  _getComponentTagName(token, parent) {\n    const prefix = this._getPrefix(token, parent);\n    const tagName = token.parts[2];\n    if (!prefix && !tagName) {\n      return null;\n    } else if (!prefix && tagName) {\n      return tagName;\n    } else {\n      return mergeNsAndName(prefix, tagName || 'ng-component');\n    }\n  }\n  _getPrefix(token, parent) {\n    let prefix;\n    let tagName;\n    if (token.type === 33 || token.type === 37 || token.type === 36) {\n      prefix = token.parts[1];\n      tagName = token.parts[2];\n    } else {\n      prefix = token.parts[0];\n      tagName = token.parts[1];\n    }\n    prefix = prefix || this._getTagDefinition(tagName)?.implicitNamespacePrefix || '';\n    if (!prefix && parent) {\n      const parentName = parent instanceof Element ? parent.name : parent.tagName;\n      if (parentName !== null) {\n        const parentTagName = splitNsName(parentName)[1];\n        const parentTagDefinition = this._getTagDefinition(parentTagName);\n        if (parentTagDefinition !== null && !parentTagDefinition.preventNamespaceInheritance) {\n          prefix = getNsPrefix(parentName);\n        }\n      }\n    }\n    return prefix;\n  }\n}\nfunction lastOnStack(stack, element) {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\nfunction decodeEntity(match, entity) {\n  if (NAMED_ENTITIES[entity] !== undefined) {\n    return NAMED_ENTITIES[entity] || match;\n  }\n  if (/^#x[a-f0-9]+$/i.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(2), 16));\n  }\n  if (/^#\\d+$/.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(1), 10));\n  }\n  return match;\n}\nconst PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\nfunction hasPreserveWhitespacesAttr(attrs) {\n  return attrs.some(attr => attr.name === PRESERVE_WS_ATTR_NAME);\n}\nfunction replaceNgsp(value) {\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\nclass WhitespaceVisitor {\n  preserveSignificantWhitespace;\n  originalNodeMap;\n  requireContext;\n  icuExpansionDepth = 0;\n  constructor(preserveSignificantWhitespace, originalNodeMap, requireContext = true) {\n    this.preserveSignificantWhitespace = preserveSignificantWhitespace;\n    this.originalNodeMap = originalNodeMap;\n    this.requireContext = requireContext;\n  }\n  visitElement(element, context) {\n    if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n      const newElement = new Element(element.name, visitAllWithSiblings(this, element.attrs), visitAllWithSiblings(this, element.directives), element.children, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n      this.originalNodeMap?.set(newElement, element);\n      return newElement;\n    }\n    const newElement = new Element(element.name, element.attrs, element.directives, visitAllWithSiblings(this, element.children), element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n    this.originalNodeMap?.set(newElement, element);\n    return newElement;\n  }\n  visitAttribute(attribute, context) {\n    return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n  }\n  visitText(text, context) {\n    const isNotBlank = text.value.match(NO_WS_REGEXP);\n    const hasExpansionSibling = context && (context.prev instanceof Expansion || context.next instanceof Expansion);\n    const inIcuExpansion = this.icuExpansionDepth > 0;\n    if (inIcuExpansion && this.preserveSignificantWhitespace) return text;\n    if (isNotBlank || hasExpansionSibling) {\n      const tokens = text.tokens.map(token => token.type === 5 ? createWhitespaceProcessedTextToken(token) : token);\n      if (!this.preserveSignificantWhitespace && tokens.length > 0) {\n        const firstToken = tokens[0];\n        tokens.splice(0, 1, trimLeadingWhitespace(firstToken, context));\n        const lastToken = tokens[tokens.length - 1];\n        tokens.splice(tokens.length - 1, 1, trimTrailingWhitespace(lastToken, context));\n      }\n      const processed = processWhitespace(text.value);\n      const value = this.preserveSignificantWhitespace ? processed : trimLeadingAndTrailingWhitespace(processed, context);\n      const result = new Text(value, text.sourceSpan, tokens, text.i18n);\n      this.originalNodeMap?.set(result, text);\n      return result;\n    }\n    return null;\n  }\n  visitComment(comment, context) {\n    return comment;\n  }\n  visitExpansion(expansion, context) {\n    this.icuExpansionDepth++;\n    let newExpansion;\n    try {\n      newExpansion = new Expansion(expansion.switchValue, expansion.type, visitAllWithSiblings(this, expansion.cases), expansion.sourceSpan, expansion.switchValueSourceSpan, expansion.i18n);\n    } finally {\n      this.icuExpansionDepth--;\n    }\n    this.originalNodeMap?.set(newExpansion, expansion);\n    return newExpansion;\n  }\n  visitExpansionCase(expansionCase, context) {\n    const newExpansionCase = new ExpansionCase(expansionCase.value, visitAllWithSiblings(this, expansionCase.expression), expansionCase.sourceSpan, expansionCase.valueSourceSpan, expansionCase.expSourceSpan);\n    this.originalNodeMap?.set(newExpansionCase, expansionCase);\n    return newExpansionCase;\n  }\n  visitBlock(block, context) {\n    const newBlock = new Block(block.name, block.parameters, visitAllWithSiblings(this, block.children), block.sourceSpan, block.nameSpan, block.startSourceSpan, block.endSourceSpan);\n    this.originalNodeMap?.set(newBlock, block);\n    return newBlock;\n  }\n  visitBlockParameter(parameter, context) {\n    return parameter;\n  }\n  visitLetDeclaration(decl, context) {\n    return decl;\n  }\n  visitComponent(node, context) {\n    if (node.tagName && SKIP_WS_TRIM_TAGS.has(node.tagName) || hasPreserveWhitespacesAttr(node.attrs)) {\n      const newElement = new Component(node.componentName, node.tagName, node.fullName, visitAllWithSiblings(this, node.attrs), visitAllWithSiblings(this, node.directives), node.children, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.i18n);\n      this.originalNodeMap?.set(newElement, node);\n      return newElement;\n    }\n    const newElement = new Component(node.componentName, node.tagName, node.fullName, node.attrs, node.directives, visitAllWithSiblings(this, node.children), node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.i18n);\n    this.originalNodeMap?.set(newElement, node);\n    return newElement;\n  }\n  visitDirective(directive, context) {\n    return directive;\n  }\n  visit(_node, context) {\n    if (this.requireContext && !context) {\n      throw new Error(`WhitespaceVisitor requires context. Visit via \\`visitAllWithSiblings\\` to get this context.`);\n    }\n    return false;\n  }\n}\nfunction trimLeadingWhitespace(token, context) {\n  if (token.type !== 5) return token;\n  const isFirstTokenInTag = !context?.prev;\n  if (!isFirstTokenInTag) return token;\n  return transformTextToken(token, text => text.trimStart());\n}\nfunction trimTrailingWhitespace(token, context) {\n  if (token.type !== 5) return token;\n  const isLastTokenInTag = !context?.next;\n  if (!isLastTokenInTag) return token;\n  return transformTextToken(token, text => text.trimEnd());\n}\nfunction trimLeadingAndTrailingWhitespace(text, context) {\n  const isFirstTokenInTag = !context?.prev;\n  const isLastTokenInTag = !context?.next;\n  const maybeTrimmedStart = isFirstTokenInTag ? text.trimStart() : text;\n  const maybeTrimmed = isLastTokenInTag ? maybeTrimmedStart.trimEnd() : maybeTrimmedStart;\n  return maybeTrimmed;\n}\nfunction createWhitespaceProcessedTextToken({\n  type,\n  parts,\n  sourceSpan\n}) {\n  return {\n    type,\n    parts: [processWhitespace(parts[0])],\n    sourceSpan\n  };\n}\nfunction transformTextToken({\n  type,\n  parts,\n  sourceSpan\n}, transform) {\n  return {\n    type,\n    parts: [transform(parts[0])],\n    sourceSpan\n  };\n}\nfunction processWhitespace(text) {\n  return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\nfunction visitAllWithSiblings(visitor, nodes) {\n  const result = [];\n  nodes.forEach((ast, i) => {\n    const context = {\n      prev: nodes[i - 1],\n      next: nodes[i + 1]\n    };\n    const astResult = ast.visit(visitor, context);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\nvar TokenType = /*#__PURE__*/function (TokenType) {\n  TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n  TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n  TokenType[TokenType[\"PrivateIdentifier\"] = 2] = \"PrivateIdentifier\";\n  TokenType[TokenType[\"Keyword\"] = 3] = \"Keyword\";\n  TokenType[TokenType[\"String\"] = 4] = \"String\";\n  TokenType[TokenType[\"Operator\"] = 5] = \"Operator\";\n  TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n  TokenType[TokenType[\"RegExpBody\"] = 7] = \"RegExpBody\";\n  TokenType[TokenType[\"RegExpFlags\"] = 8] = \"RegExpFlags\";\n  TokenType[TokenType[\"Error\"] = 9] = \"Error\";\n  return TokenType;\n}(TokenType || {});\nvar StringTokenKind = /*#__PURE__*/function (StringTokenKind) {\n  StringTokenKind[StringTokenKind[\"Plain\"] = 0] = \"Plain\";\n  StringTokenKind[StringTokenKind[\"TemplateLiteralPart\"] = 1] = \"TemplateLiteralPart\";\n  StringTokenKind[StringTokenKind[\"TemplateLiteralEnd\"] = 2] = \"TemplateLiteralEnd\";\n  return StringTokenKind;\n}(StringTokenKind || {});\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this', 'typeof', 'void', 'in'];\nclass Lexer {\n  tokenize(text) {\n    return new _Scanner(text).scan();\n  }\n}\nclass Token {\n  index;\n  end;\n  type;\n  numValue;\n  strValue;\n  constructor(index, end, type, numValue, strValue) {\n    this.index = index;\n    this.end = end;\n    this.type = type;\n    this.numValue = numValue;\n    this.strValue = strValue;\n  }\n  isCharacter(code) {\n    return this.type === TokenType.Character && this.numValue === code;\n  }\n  isNumber() {\n    return this.type === TokenType.Number;\n  }\n  isString() {\n    return this.type === TokenType.String;\n  }\n  isOperator(operator) {\n    return this.type === TokenType.Operator && this.strValue === operator;\n  }\n  isIdentifier() {\n    return this.type === TokenType.Identifier;\n  }\n  isPrivateIdentifier() {\n    return this.type === TokenType.PrivateIdentifier;\n  }\n  isKeyword() {\n    return this.type === TokenType.Keyword;\n  }\n  isKeywordLet() {\n    return this.type === TokenType.Keyword && this.strValue === 'let';\n  }\n  isKeywordAs() {\n    return this.type === TokenType.Keyword && this.strValue === 'as';\n  }\n  isKeywordNull() {\n    return this.type === TokenType.Keyword && this.strValue === 'null';\n  }\n  isKeywordUndefined() {\n    return this.type === TokenType.Keyword && this.strValue === 'undefined';\n  }\n  isKeywordTrue() {\n    return this.type === TokenType.Keyword && this.strValue === 'true';\n  }\n  isKeywordFalse() {\n    return this.type === TokenType.Keyword && this.strValue === 'false';\n  }\n  isKeywordThis() {\n    return this.type === TokenType.Keyword && this.strValue === 'this';\n  }\n  isKeywordTypeof() {\n    return this.type === TokenType.Keyword && this.strValue === 'typeof';\n  }\n  isKeywordVoid() {\n    return this.type === TokenType.Keyword && this.strValue === 'void';\n  }\n  isKeywordIn() {\n    return this.type === TokenType.Keyword && this.strValue === 'in';\n  }\n  isError() {\n    return this.type === TokenType.Error;\n  }\n  isRegExpBody() {\n    return this.type === TokenType.RegExpBody;\n  }\n  isRegExpFlags() {\n    return this.type === TokenType.RegExpFlags;\n  }\n  toNumber() {\n    return this.type === TokenType.Number ? this.numValue : -1;\n  }\n  isTemplateLiteralPart() {\n    return this.isString() && this.kind === StringTokenKind.TemplateLiteralPart;\n  }\n  isTemplateLiteralEnd() {\n    return this.isString() && this.kind === StringTokenKind.TemplateLiteralEnd;\n  }\n  isTemplateLiteralInterpolationStart() {\n    return this.isOperator('${');\n  }\n  toString() {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.PrivateIdentifier:\n      case TokenType.String:\n      case TokenType.Error:\n      case TokenType.RegExpBody:\n      case TokenType.RegExpFlags:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\nclass StringToken extends Token {\n  kind;\n  constructor(index, end, strValue, kind) {\n    super(index, end, TokenType.String, 0, strValue);\n    this.kind = kind;\n  }\n}\nfunction newCharacterToken(index, end, code) {\n  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\nfunction newIdentifierToken(index, end, text) {\n  return new Token(index, end, TokenType.Identifier, 0, text);\n}\nfunction newPrivateIdentifierToken(index, end, text) {\n  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\nfunction newKeywordToken(index, end, text) {\n  return new Token(index, end, TokenType.Keyword, 0, text);\n}\nfunction newOperatorToken(index, end, text) {\n  return new Token(index, end, TokenType.Operator, 0, text);\n}\nfunction newNumberToken(index, end, n) {\n  return new Token(index, end, TokenType.Number, n, '');\n}\nfunction newErrorToken(index, end, message) {\n  return new Token(index, end, TokenType.Error, 0, message);\n}\nfunction newRegExpBodyToken(index, end, text) {\n  return new Token(index, end, TokenType.RegExpBody, 0, text);\n}\nfunction newRegExpFlagsToken(index, end, text) {\n  return new Token(index, end, TokenType.RegExpFlags, 0, text);\n}\nconst EOF = new Token(-1, -1, TokenType.Character, 0, '');\nclass _Scanner {\n  input;\n  tokens = [];\n  length;\n  peek = 0;\n  index = -1;\n  braceStack = [];\n  constructor(input) {\n    this.input = input;\n    this.length = input.length;\n    this.advance();\n  }\n  scan() {\n    let token = this.scanToken();\n    while (token !== null) {\n      this.tokens.push(token);\n      token = this.scanToken();\n    }\n    return this.tokens;\n  }\n  advance() {\n    this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n  }\n  scanToken() {\n    const input = this.input;\n    const length = this.length;\n    let peek = this.peek;\n    let index = this.index;\n    while (peek <= $SPACE) {\n      if (++index >= length) {\n        peek = $EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n    this.peek = peek;\n    this.index = index;\n    if (index >= length) {\n      return null;\n    }\n    if (isIdentifierStart(peek)) {\n      return this.scanIdentifier();\n    }\n    if (isDigit(peek)) {\n      return this.scanNumber(index);\n    }\n    const start = index;\n    switch (peek) {\n      case $PERIOD:\n        this.advance();\n        return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);\n      case $LPAREN:\n      case $RPAREN:\n      case $LBRACKET:\n      case $RBRACKET:\n      case $COMMA:\n      case $COLON:\n      case $SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case $LBRACE:\n        return this.scanOpenBrace(start, peek);\n      case $RBRACE:\n        return this.scanCloseBrace(start, peek);\n      case $SQ:\n      case $DQ:\n        return this.scanString();\n      case $BT:\n        this.advance();\n        return this.scanTemplateLiteralPart(start);\n      case $HASH:\n        return this.scanPrivateIdentifier();\n      case $PLUS:\n        return this.scanComplexOperator(start, '+', $EQ, '=');\n      case $MINUS:\n        return this.scanComplexOperator(start, '-', $EQ, '=');\n      case $SLASH:\n        return this.isStartOfRegex() ? this.scanRegex(index) : this.scanComplexOperator(start, '/', $EQ, '=');\n      case $PERCENT:\n        return this.scanComplexOperator(start, '%', $EQ, '=');\n      case $CARET:\n        return this.scanOperator(start, '^');\n      case $STAR:\n        return this.scanStar(start);\n      case $QUESTION:\n        return this.scanQuestion(start);\n      case $LT:\n      case $GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n      case $BANG:\n      case $EQ:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n      case $AMPERSAND:\n        return this.scanComplexOperator(start, '&', $AMPERSAND, '&', $EQ, '=');\n      case $BAR:\n        return this.scanComplexOperator(start, '|', $BAR, '|', $EQ, '=');\n      case $NBSP:\n        while (isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n  scanCharacter(start, code) {\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n  scanOperator(start, str) {\n    this.advance();\n    return newOperatorToken(start, this.index, str);\n  }\n  scanOpenBrace(start, code) {\n    this.braceStack.push('expression');\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n  scanCloseBrace(start, code) {\n    this.advance();\n    const currentBrace = this.braceStack.pop();\n    if (currentBrace === 'interpolation') {\n      this.tokens.push(newCharacterToken(start, this.index, $RBRACE));\n      return this.scanTemplateLiteralPart(this.index);\n    }\n    return newCharacterToken(start, this.index, code);\n  }\n  scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n    this.advance();\n    let str = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n  scanIdentifier() {\n    const start = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);\n  }\n  scanPrivateIdentifier() {\n    const start = this.index;\n    this.advance();\n    if (!isIdentifierStart(this.peek)) {\n      return this.error('Invalid character [#]', -1);\n    }\n    while (isIdentifierPart(this.peek)) this.advance();\n    const identifierName = this.input.substring(start, this.index);\n    return newPrivateIdentifierToken(start, this.index, identifierName);\n  }\n  scanNumber(start) {\n    let simple = this.index === start;\n    let hasSeparators = false;\n    this.advance();\n    while (true) {\n      if (isDigit(this.peek)) ;else if (this.peek === $_) {\n        if (!isDigit(this.input.charCodeAt(this.index - 1)) || !isDigit(this.input.charCodeAt(this.index + 1))) {\n          return this.error('Invalid numeric separator', 0);\n        }\n        hasSeparators = true;\n      } else if (this.peek === $PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    let str = this.input.substring(start, this.index);\n    if (hasSeparators) {\n      str = str.replace(/_/g, '');\n    }\n    const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, this.index, value);\n  }\n  scanString() {\n    const start = this.index;\n    const quote = this.peek;\n    this.advance();\n    let buffer = '';\n    let marker = this.index;\n    const input = this.input;\n    while (this.peek != quote) {\n      if (this.peek == $BACKSLASH) {\n        const result = this.scanStringBackslash(buffer, marker);\n        if (typeof result !== 'string') {\n          return result;\n        }\n        buffer = result;\n        marker = this.index;\n      } else if (this.peek == $EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n    const last = input.substring(marker, this.index);\n    this.advance();\n    return new StringToken(start, this.index, buffer + last, StringTokenKind.Plain);\n  }\n  scanQuestion(start) {\n    this.advance();\n    let operator = '?';\n    if (this.peek === $QUESTION) {\n      operator += '?';\n      this.advance();\n      if (this.peek === $EQ) {\n        operator += '=';\n        this.advance();\n      }\n    } else if (this.peek === $PERIOD) {\n      operator += '.';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, operator);\n  }\n  scanTemplateLiteralPart(start) {\n    let buffer = '';\n    let marker = this.index;\n    while (this.peek !== $BT) {\n      if (this.peek === $BACKSLASH) {\n        const result = this.scanStringBackslash(buffer, marker);\n        if (typeof result !== 'string') {\n          return result;\n        }\n        buffer = result;\n        marker = this.index;\n      } else if (this.peek === $$) {\n        const dollar = this.index;\n        this.advance();\n        if (this.peek === $LBRACE) {\n          this.braceStack.push('interpolation');\n          this.tokens.push(new StringToken(start, dollar, buffer + this.input.substring(marker, dollar), StringTokenKind.TemplateLiteralPart));\n          this.advance();\n          return newOperatorToken(dollar, this.index, this.input.substring(dollar, this.index));\n        }\n      } else if (this.peek === $EOF) {\n        return this.error('Unterminated template literal', 0);\n      } else {\n        this.advance();\n      }\n    }\n    const last = this.input.substring(marker, this.index);\n    this.advance();\n    return new StringToken(start, this.index, buffer + last, StringTokenKind.TemplateLiteralEnd);\n  }\n  error(message, offset) {\n    const position = this.index + offset;\n    return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n  scanStringBackslash(buffer, marker) {\n    buffer += this.input.substring(marker, this.index);\n    let unescapedCode;\n    this.advance();\n    if (this.peek === $u) {\n      const hex = this.input.substring(this.index + 1, this.index + 5);\n      if (/^[0-9a-f]+$/i.test(hex)) {\n        unescapedCode = parseInt(hex, 16);\n      } else {\n        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n      }\n      for (let i = 0; i < 5; i++) {\n        this.advance();\n      }\n    } else {\n      unescapedCode = unescape(this.peek);\n      this.advance();\n    }\n    buffer += String.fromCharCode(unescapedCode);\n    return buffer;\n  }\n  scanStar(start) {\n    this.advance();\n    let operator = '*';\n    if (this.peek === $STAR) {\n      operator += '*';\n      this.advance();\n      if (this.peek === $EQ) {\n        operator += '=';\n        this.advance();\n      }\n    } else if (this.peek === $EQ) {\n      operator += '=';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, operator);\n  }\n  isStartOfRegex() {\n    if (this.tokens.length === 0) {\n      return true;\n    }\n    const prevToken = this.tokens[this.tokens.length - 1];\n    if (prevToken.isOperator('!')) {\n      const beforePrevToken = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;\n      const isNegation = beforePrevToken === null || beforePrevToken.type !== TokenType.Identifier && !beforePrevToken.isCharacter($RPAREN) && !beforePrevToken.isCharacter($RBRACKET);\n      return isNegation;\n    }\n    return prevToken.type === TokenType.Operator || prevToken.isCharacter($LPAREN) || prevToken.isCharacter($LBRACKET) || prevToken.isCharacter($COMMA) || prevToken.isCharacter($COLON);\n  }\n  scanRegex(tokenStart) {\n    this.advance();\n    const textStart = this.index;\n    let inEscape = false;\n    let inCharacterClass = false;\n    while (true) {\n      const peek = this.peek;\n      if (peek === $EOF) {\n        return this.error('Unterminated regular expression', 0);\n      }\n      if (inEscape) {\n        inEscape = false;\n      } else if (peek === $BACKSLASH) {\n        inEscape = true;\n      } else if (peek === $LBRACKET) {\n        inCharacterClass = true;\n      } else if (peek === $RBRACKET) {\n        inCharacterClass = false;\n      } else if (peek === $SLASH && !inCharacterClass) {\n        break;\n      }\n      this.advance();\n    }\n    const value = this.input.substring(textStart, this.index);\n    this.advance();\n    const bodyToken = newRegExpBodyToken(tokenStart, this.index, value);\n    const flagsToken = this.scanRegexFlags(this.index);\n    if (flagsToken !== null) {\n      this.tokens.push(bodyToken);\n      return flagsToken;\n    }\n    return bodyToken;\n  }\n  scanRegexFlags(start) {\n    if (!isAsciiLetter(this.peek)) {\n      return null;\n    }\n    while (isAsciiLetter(this.peek)) {\n      this.advance();\n    }\n    return newRegExpFlagsToken(start, this.index, this.input.substring(start, this.index));\n  }\n}\nfunction isIdentifierStart(code) {\n  return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;\n}\nfunction isIdentifierPart(code) {\n  return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;\n}\nfunction isExponentStart(code) {\n  return code == $e || code == $E;\n}\nfunction isExponentSign(code) {\n  return code == $MINUS || code == $PLUS;\n}\nfunction unescape(code) {\n  switch (code) {\n    case $n:\n      return $LF;\n    case $f:\n      return $FF;\n    case $r:\n      return $CR;\n    case $t:\n      return $TAB;\n    case $v:\n      return $VTAB;\n    default:\n      return code;\n  }\n}\nfunction parseIntAutoRadix(text) {\n  const result = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\nclass SplitInterpolation {\n  strings;\n  expressions;\n  offsets;\n  constructor(strings, expressions, offsets) {\n    this.strings = strings;\n    this.expressions = expressions;\n    this.offsets = offsets;\n  }\n}\nclass TemplateBindingParseResult {\n  templateBindings;\n  warnings;\n  errors;\n  constructor(templateBindings, warnings, errors) {\n    this.templateBindings = templateBindings;\n    this.warnings = warnings;\n    this.errors = errors;\n  }\n}\nfunction getLocation(span) {\n  return span.start.toString() || '(unknown)';\n}\nclass Parser {\n  _lexer;\n  _supportsDirectPipeReferences;\n  constructor(_lexer, _supportsDirectPipeReferences = false) {\n    this._lexer = _lexer;\n    this._supportsDirectPipeReferences = _supportsDirectPipeReferences;\n  }\n  parseAction(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    this._checkNoInterpolation(errors, input, parseSourceSpan);\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast = new _ParseAST(input, parseSourceSpan, absoluteOffset, tokens, 1, errors, 0, this._supportsDirectPipeReferences).parseChain();\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  parseBinding(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    const ast = this._parseBindingAst(input, parseSourceSpan, absoluteOffset, errors);\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  checkSimpleExpression(ast) {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n  parseSimpleBinding(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    const ast = this._parseBindingAst(input, parseSourceSpan, absoluteOffset, errors);\n    const simplExpressionErrors = this.checkSimpleExpression(ast);\n    if (simplExpressionErrors.length > 0) {\n      errors.push(getParseError(`Host binding expression cannot contain ${simplExpressionErrors.join(' ')}`, input, '', parseSourceSpan));\n    }\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  _parseBindingAst(input, parseSourceSpan, absoluteOffset, errors) {\n    this._checkNoInterpolation(errors, input, parseSourceSpan);\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(input, parseSourceSpan, absoluteOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences).parseChain();\n  }\n  parseTemplateBindings(templateKey, templateValue, parseSourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n    const tokens = this._lexer.tokenize(templateValue);\n    const errors = [];\n    const parser = new _ParseAST(templateValue, parseSourceSpan, absoluteValueOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences);\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)\n    });\n  }\n  parseInterpolation(input, parseSourceSpan, absoluteOffset, interpolatedTokens) {\n    const errors = [];\n    const {\n      strings,\n      expressions,\n      offsets\n    } = this.splitInterpolation(input, parseSourceSpan, errors, interpolatedTokens);\n    if (expressions.length === 0) return null;\n    const expressionNodes = [];\n    for (let i = 0; i < expressions.length; ++i) {\n      const expressionSpan = interpolatedTokens?.[i * 2 + 1]?.sourceSpan;\n      const expressionText = expressions[i].text;\n      const {\n        stripped: sourceToLex,\n        hasComments\n      } = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      if (hasComments && sourceToLex.trim().length === 0 && tokens.length === 0) {\n        errors.push(getParseError('Interpolation expression cannot only contain a comment', input, `at column ${expressions[i].start} in`, parseSourceSpan));\n        continue;\n      }\n      const ast = new _ParseAST(expressionSpan ? expressionText : input, expressionSpan || parseSourceSpan, absoluteOffset, tokens, 0, errors, offsets[i], this._supportsDirectPipeReferences).parseChain();\n      expressionNodes.push(ast);\n    }\n    return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  parseInterpolationExpression(expression, parseSourceSpan, absoluteOffset) {\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const errors = [];\n    const ast = new _ParseAST(expression, parseSourceSpan, absoluteOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences).parseChain();\n    const strings = ['', ''];\n    return this.createInterpolationAst(strings, [ast], expression, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  createInterpolationAst(strings, expressions, input, location, absoluteOffset, errors) {\n    const span = new ParseSpan(0, input.length);\n    const interpolation = new Interpolation$1(span, span.toAbsolute(absoluteOffset), strings, expressions);\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, errors);\n  }\n  splitInterpolation(input, parseSourceSpan, errors, interpolatedTokens) {\n    const strings = [];\n    const expressions = [];\n    const offsets = [];\n    const inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    const interpStart = '{{';\n    const interpEnd = '}}';\n    while (i < input.length) {\n      if (!atInterpolation) {\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({\n          text,\n          start,\n          end: i\n        });\n        atInterpolation = true;\n      } else {\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          errors.push(getParseError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, parseSourceSpan));\n        }\n        expressions.push({\n          text,\n          start: fullStart,\n          end: fullEnd\n        });\n        const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;\n        const offset = startInOriginalTemplate + interpStart.length;\n        offsets.push(offset);\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({\n          text: input.substring(i),\n          start: i,\n          end: input.length\n        });\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n  wrapLiteralPrimitive(input, sourceSpanOrLocation, absoluteOffset) {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, typeof sourceSpanOrLocation === 'string' ? sourceSpanOrLocation : getLocation(sourceSpanOrLocation), absoluteOffset, []);\n  }\n  _stripComments(input) {\n    const i = this._commentStart(input);\n    return i != null ? {\n      stripped: input.substring(0, i),\n      hasComments: true\n    } : {\n      stripped: input,\n      hasComments: false\n    };\n  }\n  _commentStart(input) {\n    let outerQuote = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n      if (char === $SLASH && nextChar == $SLASH && outerQuote == null) return i;\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n  _checkNoInterpolation(errors, input, parseSourceSpan) {\n    let startIndex = -1;\n    let endIndex = -1;\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith('{{')) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, '}}', charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n    if (startIndex > -1 && endIndex > -1) {\n      errors.push(getParseError(`Got interpolation ({{}}) where expression was expected`, input, `at column ${startIndex} in`, parseSourceSpan));\n    }\n  }\n  _getInterpolationEndIndex(input, expressionEnd, start) {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n    return -1;\n  }\n  *_forEachUnquotedChar(input, start) {\n    let currentQuote = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\nvar ParseContextFlags = /*#__PURE__*/function (ParseContextFlags) {\n  ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\n  ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\n  return ParseContextFlags;\n}(ParseContextFlags || {});\nconst SUPPORTED_REGEX_FLAGS = new Set(['d', 'g', 'i', 'm', 's', 'u', 'v', 'y']);\nclass _ParseAST {\n  input;\n  parseSourceSpan;\n  absoluteOffset;\n  tokens;\n  parseFlags;\n  errors;\n  offset;\n  supportsDirectPipeReferences;\n  rparensExpected = 0;\n  rbracketsExpected = 0;\n  rbracesExpected = 0;\n  context = ParseContextFlags.None;\n  sourceSpanCache = new Map();\n  index = 0;\n  constructor(input, parseSourceSpan, absoluteOffset, tokens, parseFlags, errors, offset, supportsDirectPipeReferences) {\n    this.input = input;\n    this.parseSourceSpan = parseSourceSpan;\n    this.absoluteOffset = absoluteOffset;\n    this.tokens = tokens;\n    this.parseFlags = parseFlags;\n    this.errors = errors;\n    this.offset = offset;\n    this.supportsDirectPipeReferences = supportsDirectPipeReferences;\n  }\n  peek(offset) {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n  get next() {\n    return this.peek(0);\n  }\n  get atEOF() {\n    return this.index >= this.tokens.length;\n  }\n  get inputIndex() {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n  get currentEndIndex() {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n  get currentAbsoluteOffset() {\n    return this.absoluteOffset + this.inputIndex;\n  }\n  span(start, artificialEndIndex) {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n    return new ParseSpan(start, endIndex);\n  }\n  sourceSpan(start, artificialEndIndex) {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n    }\n    return this.sourceSpanCache.get(serial);\n  }\n  advance() {\n    this.index++;\n  }\n  withContext(context, cb) {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n  consumeOptionalCharacter(code) {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  peekKeywordLet() {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs() {\n    return this.next.isKeywordAs();\n  }\n  expectCharacter(code) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n  consumeOptionalOperator(op) {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  isAssignmentOperator(token) {\n    return token.type === TokenType.Operator && Binary.isAssignmentOperation(token.strValue);\n  }\n  expectOperator(operator) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n  prettyPrintToken(tok) {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n  expectIdentifierOrKeyword() {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      }\n      return null;\n    }\n    this.advance();\n    return n.toString();\n  }\n  expectIdentifierOrKeywordOrString() {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n      }\n      return '';\n    }\n    this.advance();\n    return n.toString();\n  }\n  parseChain() {\n    const exprs = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n      if (this.consumeOptionalCharacter($SEMICOLON)) {\n        if (!(this.parseFlags & 1)) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter($SEMICOLON)) {}\n      } else if (this.index < this.tokens.length) {\n        const errorIndex = this.index;\n        this.error(`Unexpected token '${this.next}'`);\n        if (this.index === errorIndex) {\n          break;\n        }\n      }\n    }\n    if (exprs.length === 0) {\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.input.length;\n      return new EmptyExpr$1(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n  parsePipe() {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseFlags & 1) {\n        this.error(`Cannot have a pipe in an action expression`);\n      }\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan;\n        let fullSpanEnd = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          nameId = '';\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n        const args = [];\n        while (this.consumeOptionalCharacter($COLON)) {\n          args.push(this.parseExpression());\n        }\n        let type;\n        if (this.supportsDirectPipeReferences) {\n          const charCode = nameId.charCodeAt(0);\n          type = charCode === $_ || charCode >= $A && charCode <= $Z ? BindingPipeType.ReferencedDirectly : BindingPipeType.ReferencedByName;\n        } else {\n          type = BindingPipeType.ReferencedByName;\n        }\n        result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, type, nameSpan);\n      } while (this.consumeOptionalOperator('|'));\n    }\n    return result;\n  }\n  parseExpression() {\n    return this.parseConditional();\n  }\n  parseConditional() {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no;\n      if (!this.consumeOptionalCharacter($COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n  parseLogicalOr() {\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n  parseLogicalAnd() {\n    const start = this.inputIndex;\n    let result = this.parseNullishCoalescing();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseNullishCoalescing();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n  parseNullishCoalescing() {\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('??')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n    }\n    return result;\n  }\n  parseEquality() {\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseRelational() {\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator || this.next.isKeywordIn) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'in':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseAdditive() {\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseMultiplicative() {\n    const start = this.inputIndex;\n    let result = this.parseExponentiation();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          const right = this.parseExponentiation();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseExponentiation() {\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator && this.next.strValue === '**') {\n      if (result instanceof Unary || result instanceof PrefixNot || result instanceof TypeofExpression || result instanceof VoidExpression) {\n        this.error('Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence');\n      }\n      this.advance();\n      const right = this.parseExponentiation();\n      result = new Binary(this.span(start), this.sourceSpan(start), '**', result, right);\n    }\n    return result;\n  }\n  parsePrefix() {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    } else if (this.next.isKeywordTypeof()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new TypeofExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordVoid()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new VoidExpression(this.span(start), this.sourceSpan(start), result);\n    }\n    return this.parseCallChain();\n  }\n  parseCallChain() {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter($PERIOD)) {\n        result = this.parseAccessMember(result, start, false);\n      } else if (this.consumeOptionalOperator('?.')) {\n        if (this.consumeOptionalCharacter($LPAREN)) {\n          result = this.parseCall(result, start, true);\n        } else {\n          result = this.consumeOptionalCharacter($LBRACKET) ? this.parseKeyedReadOrWrite(result, start, true) : this.parseAccessMember(result, start, true);\n        }\n      } else if (this.consumeOptionalCharacter($LBRACKET)) {\n        result = this.parseKeyedReadOrWrite(result, start, false);\n      } else if (this.consumeOptionalCharacter($LPAREN)) {\n        result = this.parseCall(result, start, false);\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n      } else if (this.next.isTemplateLiteralEnd()) {\n        result = this.parseNoInterpolationTaggedTemplateLiteral(result, start);\n      } else if (this.next.isTemplateLiteralPart()) {\n        result = this.parseTaggedTemplateLiteral(result, start);\n      } else {\n        return result;\n      }\n    }\n  }\n  parsePrimary() {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter($LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      if (!this.consumeOptionalCharacter($RPAREN)) {\n        this.error('Missing closing parentheses');\n        this.consumeOptionalCharacter($RPAREN);\n      }\n      this.rparensExpected--;\n      return new ParenthesizedExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n    } else if (this.next.isKeywordIn()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), 'in');\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter($LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList($RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter($RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n    } else if (this.next.isCharacter($LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMember(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n    } else if (this.next.isTemplateLiteralEnd()) {\n      return this.parseNoInterpolationTemplateLiteral();\n    } else if (this.next.isTemplateLiteralPart()) {\n      return this.parseTemplateLiteral();\n    } else if (this.next.isString() && this.next.kind === StringTokenKind.Plain) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n    } else if (this.next.isPrivateIdentifier()) {\n      this._reportErrorForPrivateIdentifier(this.next, null);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    } else if (this.next.isRegExpBody()) {\n      return this.parseRegularExpressionLiteral();\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    }\n  }\n  parseExpressionList(terminator) {\n    const result = [];\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter($COMMA));\n    return result;\n  }\n  parseLiteralMap() {\n    const keys = [];\n    const values = [];\n    const start = this.inputIndex;\n    this.expectCharacter($LBRACE);\n    if (!this.consumeOptionalCharacter($RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const keyStart = this.inputIndex;\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        const literalMapKey = {\n          key,\n          quoted\n        };\n        keys.push(literalMapKey);\n        if (quoted) {\n          this.expectCharacter($COLON);\n          values.push(this.parsePipe());\n        } else if (this.consumeOptionalCharacter($COLON)) {\n          values.push(this.parsePipe());\n        } else {\n          literalMapKey.isShorthandInitialized = true;\n          const span = this.span(keyStart);\n          const sourceSpan = this.sourceSpan(keyStart);\n          values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n        }\n      } while (this.consumeOptionalCharacter($COMMA) && !this.next.isCharacter($RBRACE));\n      this.rbracesExpected--;\n      this.expectCharacter($RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n  parseAccessMember(readReceiver, start, isSafe) {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, readReceiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n    if (isSafe) {\n      if (this.isAssignmentOperator(this.next)) {\n        this.advance();\n        this.error(\"The '?.' operator cannot be used in the assignment\");\n        return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n      } else {\n        return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    } else {\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n        if (!(this.parseFlags & 1)) {\n          this.advance();\n          this.error('Bindings cannot contain assignments');\n          return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n        }\n        const receiver = new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n        this.advance();\n        const value = this.parseConditional();\n        return new Binary(this.span(start), this.sourceSpan(start), operation, receiver, value);\n      } else {\n        return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    }\n  }\n  parseCall(receiver, start, isSafe) {\n    const argumentStart = this.inputIndex;\n    this.rparensExpected++;\n    const args = this.parseCallArguments();\n    const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n    this.expectCharacter($RPAREN);\n    this.rparensExpected--;\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) : new Call(span, sourceSpan, receiver, args, argumentSpan);\n  }\n  parseCallArguments() {\n    if (this.next.isCharacter($RPAREN)) return [];\n    const positionals = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter($COMMA));\n    return positionals;\n  }\n  expectTemplateBindingKey() {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length)\n    };\n  }\n  parseTemplateBindings(templateKey) {\n    const bindings = [];\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n    while (this.index < this.tokens.length) {\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        const key = this.expectTemplateBindingKey();\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n    return new TemplateBindingParseResult(bindings, [], this.errors);\n  }\n  parseKeyedReadOrWrite(receiver, start, isSafe) {\n    return this.withContext(ParseContextFlags.Writable, () => {\n      this.rbracketsExpected++;\n      const key = this.parsePipe();\n      if (key instanceof EmptyExpr$1) {\n        this.error(`Key access cannot be empty`);\n      }\n      this.rbracketsExpected--;\n      this.expectCharacter($RBRACKET);\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n        if (isSafe) {\n          this.advance();\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n        } else {\n          const binaryReceiver = new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n          this.advance();\n          const value = this.parseConditional();\n          return new Binary(this.span(start), this.sourceSpan(start), operation, binaryReceiver, value);\n        }\n      } else {\n        return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) : new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n      }\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    });\n  }\n  parseDirectiveKeywordBindings(key) {\n    const bindings = [];\n    this.consumeOptionalCharacter($COLON);\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n  getDirectiveBoundTarget() {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe();\n    const {\n      start,\n      end\n    } = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(ast, value, getLocation(this.parseSourceSpan), this.absoluteOffset + start, this.errors);\n  }\n  parseAsBinding(value) {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance();\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n  parseLetBinding() {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance();\n    const key = this.expectTemplateBindingKey();\n    let value = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n  parseNoInterpolationTaggedTemplateLiteral(tag, start) {\n    const template = this.parseNoInterpolationTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n  parseNoInterpolationTemplateLiteral() {\n    const text = this.next.strValue;\n    const start = this.inputIndex;\n    this.advance();\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return new TemplateLiteral(span, sourceSpan, [new TemplateLiteralElement(span, sourceSpan, text)], []);\n  }\n  parseTaggedTemplateLiteral(tag, start) {\n    const template = this.parseTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n  parseTemplateLiteral() {\n    const elements = [];\n    const expressions = [];\n    const start = this.inputIndex;\n    while (this.next !== EOF) {\n      const token = this.next;\n      if (token.isTemplateLiteralPart() || token.isTemplateLiteralEnd()) {\n        const partStart = this.inputIndex;\n        this.advance();\n        elements.push(new TemplateLiteralElement(this.span(partStart), this.sourceSpan(partStart), token.strValue));\n        if (token.isTemplateLiteralEnd()) {\n          break;\n        }\n      } else if (token.isTemplateLiteralInterpolationStart()) {\n        this.advance();\n        this.rbracesExpected++;\n        const expression = this.parsePipe();\n        if (expression instanceof EmptyExpr$1) {\n          this.error('Template literal interpolation cannot be empty');\n        } else {\n          expressions.push(expression);\n        }\n        this.rbracesExpected--;\n      } else {\n        this.advance();\n      }\n    }\n    return new TemplateLiteral(this.span(start), this.sourceSpan(start), elements, expressions);\n  }\n  parseRegularExpressionLiteral() {\n    const bodyToken = this.next;\n    this.advance();\n    if (!bodyToken.isRegExpBody()) {\n      return new EmptyExpr$1(this.span(this.inputIndex), this.sourceSpan(this.inputIndex));\n    }\n    let flagsToken = null;\n    if (this.next.isRegExpFlags()) {\n      flagsToken = this.next;\n      this.advance();\n      const seenFlags = new Set();\n      for (let i = 0; i < flagsToken.strValue.length; i++) {\n        const char = flagsToken.strValue[i];\n        if (!SUPPORTED_REGEX_FLAGS.has(char)) {\n          this.error(`Unsupported regular expression flag \"${char}\". The supported flags are: ` + Array.from(SUPPORTED_REGEX_FLAGS, f => `\"${f}\"`).join(', '), flagsToken.index + i);\n        } else if (seenFlags.has(char)) {\n          this.error(`Duplicate regular expression flag \"${char}\"`, flagsToken.index + i);\n        } else {\n          seenFlags.add(char);\n        }\n      }\n    }\n    const start = bodyToken.index;\n    const end = flagsToken ? flagsToken.end : bodyToken.end;\n    return new RegularExpressionLiteral(this.span(start, end), this.sourceSpan(start, end), bodyToken.strValue, flagsToken ? flagsToken.strValue : null);\n  }\n  consumeStatementTerminator() {\n    this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n  }\n  error(message, index = this.index) {\n    this.errors.push(getParseError(message, this.input, this.getErrorLocationText(index), this.parseSourceSpan));\n    this.skip();\n  }\n  getErrorLocationText(index) {\n    return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;\n  }\n  _reportErrorForPrivateIdentifier(token, extraMessage) {\n    let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n    if (extraMessage !== null) {\n      errorMessage += `, ${extraMessage}`;\n    }\n    this.error(errorMessage);\n  }\n  skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !this.isAssignmentOperator(n))) {\n      if (this.next.isError()) {\n        this.errors.push(getParseError(this.next.toString(), this.input, this.getErrorLocationText(this.next.index), this.parseSourceSpan));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\nfunction getParseError(message, input, locationText, parseSourceSpan) {\n  if (locationText.length > 0) {\n    locationText = ` ${locationText} `;\n  }\n  const location = getLocation(parseSourceSpan);\n  const error = `Parser Error: ${message}${locationText}[${input}] in ${location}`;\n  return new ParseError(parseSourceSpan, error);\n}\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n  errors = [];\n  visitPipe() {\n    this.errors.push('pipes');\n  }\n}\nfunction getIndexMapForOriginalTemplate(interpolatedTokens) {\n  let offsetMap = new Map();\n  let consumedInOriginalTemplate = 0;\n  let consumedInInput = 0;\n  let tokenIndex = 0;\n  while (tokenIndex < interpolatedTokens.length) {\n    const currentToken = interpolatedTokens[tokenIndex];\n    if (currentToken.type === 9) {\n      const [decoded, encoded] = currentToken.parts;\n      consumedInOriginalTemplate += encoded.length;\n      consumedInInput += decoded.length;\n    } else {\n      const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n      consumedInInput += lengthOfParts;\n      consumedInOriginalTemplate += lengthOfParts;\n    }\n    offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n    tokenIndex++;\n  }\n  return offsetMap;\n}\nfunction serialize(expression) {\n  return expression.visit(new SerializeExpressionVisitor());\n}\nclass SerializeExpressionVisitor {\n  visitUnary(ast, context) {\n    return `${ast.operator}${ast.expr.visit(this, context)}`;\n  }\n  visitBinary(ast, context) {\n    return `${ast.left.visit(this, context)} ${ast.operation} ${ast.right.visit(this, context)}`;\n  }\n  visitChain(ast, context) {\n    return ast.expressions.map(e => e.visit(this, context)).join('; ');\n  }\n  visitConditional(ast, context) {\n    return `${ast.condition.visit(this, context)} ? ${ast.trueExp.visit(this, context)} : ${ast.falseExp.visit(this, context)}`;\n  }\n  visitThisReceiver() {\n    return 'this';\n  }\n  visitImplicitReceiver() {\n    return '';\n  }\n  visitInterpolation(ast, context) {\n    return interleave(ast.strings, ast.expressions.map(e => e.visit(this, context))).join('');\n  }\n  visitKeyedRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}[${ast.key.visit(this, context)}]`;\n  }\n  visitLiteralArray(ast, context) {\n    return `[${ast.expressions.map(e => e.visit(this, context)).join(', ')}]`;\n  }\n  visitLiteralMap(ast, context) {\n    return `{${zip(ast.keys.map(literal => literal.quoted ? `'${literal.key}'` : literal.key), ast.values.map(value => value.visit(this, context))).map(([key, value]) => `${key}: ${value}`).join(', ')}}`;\n  }\n  visitLiteralPrimitive(ast) {\n    if (ast.value === null) return 'null';\n    switch (typeof ast.value) {\n      case 'number':\n      case 'boolean':\n        return ast.value.toString();\n      case 'undefined':\n        return 'undefined';\n      case 'string':\n        return `'${ast.value.replace(/'/g, `\\\\'`)}'`;\n      default:\n        throw new Error(`Unsupported primitive type: ${ast.value}`);\n    }\n  }\n  visitPipe(ast, context) {\n    return `${ast.exp.visit(this, context)} | ${ast.name}`;\n  }\n  visitPrefixNot(ast, context) {\n    return `!${ast.expression.visit(this, context)}`;\n  }\n  visitNonNullAssert(ast, context) {\n    return `${ast.expression.visit(this, context)}!`;\n  }\n  visitPropertyRead(ast, context) {\n    if (ast.receiver instanceof ImplicitReceiver) {\n      return ast.name;\n    } else {\n      return `${ast.receiver.visit(this, context)}.${ast.name}`;\n    }\n  }\n  visitSafePropertyRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.${ast.name}`;\n  }\n  visitSafeKeyedRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.[${ast.key.visit(this, context)}]`;\n  }\n  visitCall(ast, context) {\n    return `${ast.receiver.visit(this, context)}(${ast.args.map(e => e.visit(this, context)).join(', ')})`;\n  }\n  visitSafeCall(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.(${ast.args.map(e => e.visit(this, context)).join(', ')})`;\n  }\n  visitTypeofExpression(ast, context) {\n    return `typeof ${ast.expression.visit(this, context)}`;\n  }\n  visitVoidExpression(ast, context) {\n    return `void ${ast.expression.visit(this, context)}`;\n  }\n  visitRegularExpressionLiteral(ast, context) {\n    return `/${ast.body}/${ast.flags || ''}`;\n  }\n  visitASTWithSource(ast, context) {\n    return ast.ast.visit(this, context);\n  }\n  visitTemplateLiteral(ast, context) {\n    let result = '';\n    for (let i = 0; i < ast.elements.length; i++) {\n      result += ast.elements[i].visit(this, context);\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        result += '${' + expression.visit(this, context) + '}';\n      }\n    }\n    return '`' + result + '`';\n  }\n  visitTemplateLiteralElement(ast, context) {\n    return ast.text;\n  }\n  visitTaggedTemplateLiteral(ast, context) {\n    return ast.tag.visit(this, context) + ast.template.visit(this, context);\n  }\n  visitParenthesizedExpression(ast, context) {\n    return '(' + ast.expression.visit(this, context) + ')';\n  }\n}\nfunction zip(left, right) {\n  if (left.length !== right.length) throw new Error('Array lengths must match');\n  return left.map((l, i) => [l, right[i]]);\n}\nfunction interleave(left, right) {\n  const result = [];\n  for (let index = 0; index < Math.max(left.length, right.length); index++) {\n    if (index < left.length) result.push(left[index]);\n    if (index < right.length) result.push(right[index]);\n  }\n  return result;\n}\nlet _SECURITY_SCHEMA;\nfunction SECURITY_SCHEMA() {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {};\n    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);\n    registerContext(SecurityContext.STYLE, ['*|style']);\n    registerContext(SecurityContext.URL, ['*|formAction', 'area|href', 'a|href', 'a|xlink:href', 'form|action', 'annotation|href', 'annotation|xlink:href', 'annotation-xml|href', 'annotation-xml|xlink:href', 'maction|href', 'maction|xlink:href', 'malignmark|href', 'malignmark|xlink:href', 'math|href', 'math|xlink:href', 'mroot|href', 'mroot|xlink:href', 'msqrt|href', 'msqrt|xlink:href', 'merror|href', 'merror|xlink:href', 'mfrac|href', 'mfrac|xlink:href', 'mglyph|href', 'mglyph|xlink:href', 'msub|href', 'msub|xlink:href', 'msup|href', 'msup|xlink:href', 'msubsup|href', 'msubsup|xlink:href', 'mmultiscripts|href', 'mmultiscripts|xlink:href', 'mprescripts|href', 'mprescripts|xlink:href', 'mi|href', 'mi|xlink:href', 'mn|href', 'mn|xlink:href', 'mo|href', 'mo|xlink:href', 'mpadded|href', 'mpadded|xlink:href', 'mphantom|href', 'mphantom|xlink:href', 'mrow|href', 'mrow|xlink:href', 'ms|href', 'ms|xlink:href', 'mspace|href', 'mspace|xlink:href', 'mstyle|href', 'mstyle|xlink:href', 'mtable|href', 'mtable|xlink:href', 'mtd|href', 'mtd|xlink:href', 'mtr|href', 'mtr|xlink:href', 'mtext|href', 'mtext|xlink:href', 'mover|href', 'mover|xlink:href', 'munder|href', 'munder|xlink:href', 'munderover|href', 'munderover|xlink:href', 'semantics|href', 'semantics|xlink:href', 'none|href', 'none|xlink:href', 'img|src', 'video|src']);\n    registerContext(SecurityContext.RESOURCE_URL, ['base|href', 'embed|src', 'frame|src', 'iframe|src', 'link|href', 'object|codebase', 'object|data', 'script|src']);\n    registerContext(SecurityContext.ATTRIBUTE_NO_BINDING, ['animate|attributeName', 'set|attributeName', 'animateMotion|attributeName', 'animateTransform|attributeName', 'unknown|attributeName', 'iframe|sandbox', 'iframe|allow', 'iframe|allowFullscreen', 'iframe|referrerPolicy', 'iframe|csp', 'iframe|fetchPriority', 'unknown|sandbox', 'unknown|allow', 'unknown|allowFullscreen', 'unknown|referrerPolicy', 'unknown|csp', 'unknown|fetchPriority']);\n  }\n  return _SECURITY_SCHEMA;\n}\nfunction registerContext(ctx, specs) {\n  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\nclass ElementSchemaRegistry {}\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\nconst SCHEMA = ['[Element]|textContent,%ariaActiveDescendantElement,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColIndexText,%ariaColSpan,%ariaControlsElements,%ariaCurrent,%ariaDescribedByElements,%ariaDescription,%ariaDetailsElements,%ariaDisabled,%ariaErrorMessageElements,%ariaExpanded,%ariaFlowToElements,%ariaHasPopup,%ariaHidden,%ariaInvalid,%ariaKeyShortcuts,%ariaLabel,%ariaLabelledByElements,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaOwnsElements,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowIndexText,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot' + ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,search,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume', ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'data^[HTMLElement]|value', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,media,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type', 'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'selectedcontent^[HTMLElement]|', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'search^[HTMLELement]|', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'time^[HTMLElement]|dateTime', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|decoding', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|', ':math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':math:math^:math:|', ':math:maction^:math:|', ':math:menclose^:math:|', ':math:merror^:math:|', ':math:mfenced^:math:|', ':math:mfrac^:math:|', ':math:mi^:math:|', ':math:mmultiscripts^:math:|', ':math:mn^:math:|', ':math:mo^:math:|', ':math:mover^:math:|', ':math:mpadded^:math:|', ':math:mphantom^:math:|', ':math:mroot^:math:|', ':math:mrow^:math:|', ':math:ms^:math:|', ':math:mspace^:math:|', ':math:msqrt^:math:|', ':math:mstyle^:math:|', ':math:msub^:math:|', ':math:msubsup^:math:|', ':math:msup^:math:|', ':math:mtable^:math:|', ':math:mtd^:math:|', ':math:mtext^:math:|', ':math:mtr^:math:|', ':math:munder^:math:|', ':math:munderover^:math:|', ':math:semantics^:math:|'];\nconst _ATTR_TO_PROP = new Map(Object.entries({\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n  'aria-activedescendant': 'ariaActiveDescendantElement',\n  'aria-atomic': 'ariaAtomic',\n  'aria-autocomplete': 'ariaAutoComplete',\n  'aria-busy': 'ariaBusy',\n  'aria-checked': 'ariaChecked',\n  'aria-colcount': 'ariaColCount',\n  'aria-colindex': 'ariaColIndex',\n  'aria-colindextext': 'ariaColIndexText',\n  'aria-colspan': 'ariaColSpan',\n  'aria-controls': 'ariaControlsElements',\n  'aria-current': 'ariaCurrent',\n  'aria-describedby': 'ariaDescribedByElements',\n  'aria-description': 'ariaDescription',\n  'aria-details': 'ariaDetailsElements',\n  'aria-disabled': 'ariaDisabled',\n  'aria-errormessage': 'ariaErrorMessageElements',\n  'aria-expanded': 'ariaExpanded',\n  'aria-flowto': 'ariaFlowToElements',\n  'aria-haspopup': 'ariaHasPopup',\n  'aria-hidden': 'ariaHidden',\n  'aria-invalid': 'ariaInvalid',\n  'aria-keyshortcuts': 'ariaKeyShortcuts',\n  'aria-label': 'ariaLabel',\n  'aria-labelledby': 'ariaLabelledByElements',\n  'aria-level': 'ariaLevel',\n  'aria-live': 'ariaLive',\n  'aria-modal': 'ariaModal',\n  'aria-multiline': 'ariaMultiLine',\n  'aria-multiselectable': 'ariaMultiSelectable',\n  'aria-orientation': 'ariaOrientation',\n  'aria-owns': 'ariaOwnsElements',\n  'aria-placeholder': 'ariaPlaceholder',\n  'aria-posinset': 'ariaPosInSet',\n  'aria-pressed': 'ariaPressed',\n  'aria-readonly': 'ariaReadOnly',\n  'aria-required': 'ariaRequired',\n  'aria-roledescription': 'ariaRoleDescription',\n  'aria-rowcount': 'ariaRowCount',\n  'aria-rowindex': 'ariaRowIndex',\n  'aria-rowindextext': 'ariaRowIndexText',\n  'aria-rowspan': 'ariaRowSpan',\n  'aria-selected': 'ariaSelected',\n  'aria-setsize': 'ariaSetSize',\n  'aria-sort': 'ariaSort',\n  'aria-valuemax': 'ariaValueMax',\n  'aria-valuemin': 'ariaValueMin',\n  'aria-valuenow': 'ariaValueNow',\n  'aria-valuetext': 'ariaValueText'\n}));\nconst _PROP_TO_ATTR = Array.from(_ATTR_TO_PROP).reduce((inverted, [propertyName, attributeName]) => {\n  inverted.set(propertyName, attributeName);\n  return inverted;\n}, new Map());\nclass DomElementSchemaRegistry extends ElementSchemaRegistry {\n  _schema = new Map();\n  _eventSchema = new Map();\n  constructor() {\n    super();\n    SCHEMA.forEach(encodedType => {\n      const type = new Map();\n      const events = new Set();\n      const [strType, strProperties] = encodedType.split('|');\n      const properties = strProperties.split(',');\n      const [typeNames, superName] = strType.split('^');\n      typeNames.split(',').forEach(tag => {\n        this._schema.set(tag.toLowerCase(), type);\n        this._eventSchema.set(tag.toLowerCase(), events);\n      });\n      const superType = superName && this._schema.get(superName.toLowerCase());\n      if (superType) {\n        for (const [prop, value] of superType) {\n          type.set(prop, value);\n        }\n        for (const superEvent of this._eventSchema.get(superName.toLowerCase())) {\n          events.add(superEvent);\n        }\n      }\n      properties.forEach(property => {\n        if (property.length > 0) {\n          switch (property[0]) {\n            case '*':\n              events.add(property.substring(1));\n              break;\n            case '!':\n              type.set(property.substring(1), BOOLEAN);\n              break;\n            case '#':\n              type.set(property.substring(1), NUMBER);\n              break;\n            case '%':\n              type.set(property.substring(1), OBJECT);\n              break;\n            default:\n              type.set(property, STRING);\n          }\n        }\n      });\n    });\n  }\n  hasProperty(tagName, propName, schemaMetas) {\n    if (schemaMetas.some(schema => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return false;\n      }\n      if (schemaMetas.some(schema => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        return true;\n      }\n    }\n    const elementProperties = this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown');\n    return elementProperties.has(propName);\n  }\n  hasElement(tagName, schemaMetas) {\n    if (schemaMetas.some(schema => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return true;\n      }\n      if (schemaMetas.some(schema => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        return true;\n      }\n    }\n    return this._schema.has(tagName.toLowerCase());\n  }\n  securityContext(tagName, propName, isAttribute) {\n    if (isAttribute) {\n      propName = this.getMappedPropName(propName);\n    }\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n    if (ctx) {\n      return ctx;\n    }\n    ctx = SECURITY_SCHEMA()['*|' + propName];\n    return ctx ? ctx : SecurityContext.NONE;\n  }\n  getMappedPropName(propName) {\n    return _ATTR_TO_PROP.get(propName) ?? propName;\n  }\n  getDefaultComponentElementName() {\n    return 'ng-component';\n  }\n  validateProperty(name) {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;\n      return {\n        error: true,\n        msg: msg\n      };\n    } else {\n      return {\n        error: false\n      };\n    }\n  }\n  validateAttribute(name) {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;\n      return {\n        error: true,\n        msg: msg\n      };\n    } else {\n      return {\n        error: false\n      };\n    }\n  }\n  allKnownElementNames() {\n    return Array.from(this._schema.keys());\n  }\n  allKnownAttributesOfElement(tagName) {\n    const elementProperties = this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown');\n    return Array.from(elementProperties.keys()).map(prop => _PROP_TO_ATTR.get(prop) ?? prop);\n  }\n  allKnownEventsOfElement(tagName) {\n    return Array.from(this._eventSchema.get(tagName.toLowerCase()) ?? []);\n  }\n  normalizeAnimationStyleProperty(propName) {\n    return dashCaseToCamelCase(propName);\n  }\n  normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n    let unit = '';\n    const strVal = val.toString().trim();\n    let errorMsg = null;\n    if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n      if (typeof val === 'number') {\n        unit = 'px';\n      } else {\n        const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n        }\n      }\n    }\n    return {\n      error: errorMsg,\n      value: strVal + unit\n    };\n  }\n}\nfunction _isPixelDimensionStyle(prop) {\n  switch (prop) {\n    case 'width':\n    case 'height':\n    case 'minWidth':\n    case 'minHeight':\n    case 'maxWidth':\n    case 'maxHeight':\n    case 'left':\n    case 'top':\n    case 'bottom':\n    case 'right':\n    case 'fontSize':\n    case 'outlineWidth':\n    case 'outlineOffset':\n    case 'paddingTop':\n    case 'paddingLeft':\n    case 'paddingBottom':\n    case 'paddingRight':\n    case 'marginTop':\n    case 'marginLeft':\n    case 'marginBottom':\n    case 'marginRight':\n    case 'borderRadius':\n    case 'borderWidth':\n    case 'borderTopWidth':\n    case 'borderLeftWidth':\n    case 'borderRightWidth':\n    case 'borderBottomWidth':\n    case 'textIndent':\n      return true;\n    default:\n      return false;\n  }\n}\nclass HtmlTagDefinition {\n  closedByChildren = {};\n  contentType;\n  closedByParent = false;\n  implicitNamespacePrefix;\n  isVoid;\n  ignoreFirstLf;\n  canSelfClose;\n  preventNamespaceInheritance;\n  constructor({\n    closedByChildren,\n    implicitNamespacePrefix,\n    contentType = TagContentType.PARSABLE_DATA,\n    closedByParent = false,\n    isVoid = false,\n    ignoreFirstLf = false,\n    preventNamespaceInheritance = false,\n    canSelfClose = false\n  } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n    this.preventNamespaceInheritance = preventNamespaceInheritance;\n    this.canSelfClose = canSelfClose ?? isVoid;\n  }\n  isClosedByChild(name) {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n  getContentType(prefix) {\n    if (typeof this.contentType === 'object') {\n      const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n      return overrideType ?? this.contentType.default;\n    }\n    return this.contentType;\n  }\n}\nlet DEFAULT_TAG_DEFINITION;\nlet TAG_DEFINITIONS;\nfunction getHtmlTagDefinition(tagName) {\n  if (!TAG_DEFINITIONS) {\n    DEFAULT_TAG_DEFINITION = new HtmlTagDefinition({\n      canSelfClose: true\n    });\n    TAG_DEFINITIONS = Object.assign(Object.create(null), {\n      'base': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'meta': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'area': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'embed': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'link': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'img': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'input': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'param': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'hr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'br': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'source': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'track': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'wbr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'p': new HtmlTagDefinition({\n        closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot']\n      }),\n      'tbody': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot'],\n        closedByParent: true\n      }),\n      'tfoot': new HtmlTagDefinition({\n        closedByChildren: ['tbody'],\n        closedByParent: true\n      }),\n      'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        closedByParent: true\n      }),\n      'td': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'th': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'col': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'svg': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'svg'\n      }),\n      'foreignObject': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'svg',\n        preventNamespaceInheritance: true\n      }),\n      'math': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'math'\n      }),\n      'li': new HtmlTagDefinition({\n        closedByChildren: ['li'],\n        closedByParent: true\n      }),\n      'dt': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd']\n      }),\n      'dd': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd'],\n        closedByParent: true\n      }),\n      'rb': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rt': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rtc': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rp': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'optgroup': new HtmlTagDefinition({\n        closedByChildren: ['optgroup'],\n        closedByParent: true\n      }),\n      'option': new HtmlTagDefinition({\n        closedByChildren: ['option', 'optgroup'],\n        closedByParent: true\n      }),\n      'pre': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'listing': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'style': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'script': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'title': new HtmlTagDefinition({\n        contentType: {\n          default: TagContentType.ESCAPABLE_RAW_TEXT,\n          svg: TagContentType.PARSABLE_DATA\n        }\n      }),\n      'textarea': new HtmlTagDefinition({\n        contentType: TagContentType.ESCAPABLE_RAW_TEXT,\n        ignoreFirstLf: true\n      })\n    });\n    new DomElementSchemaRegistry().allKnownElementNames().forEach(knownTagName => {\n      if (!TAG_DEFINITIONS[knownTagName] && getNsPrefix(knownTagName) === null) {\n        TAG_DEFINITIONS[knownTagName] = new HtmlTagDefinition({\n          canSelfClose: false\n        });\n      }\n    });\n  }\n  return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ?? DEFAULT_TAG_DEFINITION;\n}\nconst TAG_TO_PLACEHOLDER_NAMES = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST'\n};\nclass PlaceholderRegistry {\n  _placeHolderNameCounts = {};\n  _signatureToName = {};\n  getStartTagPlaceholderName(tag, attrs, isVoid) {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n    this._signatureToName[signature] = name;\n    return name;\n  }\n  getCloseTagPlaceholderName(tag) {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n    this._signatureToName[signature] = name;\n    return name;\n  }\n  getPlaceholderName(name, content) {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n    return uniqueName;\n  }\n  getUniquePlaceholder(name) {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n  getStartBlockPlaceholderName(name, parameters) {\n    const signature = this._hashBlock(name, parameters);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const placeholder = this._generateUniqueName(`START_BLOCK_${this._toSnakeCase(name)}`);\n    this._signatureToName[signature] = placeholder;\n    return placeholder;\n  }\n  getCloseBlockPlaceholderName(name) {\n    const signature = this._hashClosingBlock(name);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const placeholder = this._generateUniqueName(`CLOSE_BLOCK_${this._toSnakeCase(name)}`);\n    this._signatureToName[signature] = placeholder;\n    return placeholder;\n  }\n  _hashTag(tag, attrs, isVoid) {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs).sort().map(name => ` ${name}=${attrs[name]}`).join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n    return start + strAttrs + end;\n  }\n  _hashClosingTag(tag) {\n    return this._hashTag(`/${tag}`, {}, false);\n  }\n  _hashBlock(name, parameters) {\n    const params = parameters.length === 0 ? '' : ` (${parameters.sort().join('; ')})`;\n    return `@${name}${params} {}`;\n  }\n  _hashClosingBlock(name) {\n    return this._hashBlock(`close_${name}`, []);\n  }\n  _toSnakeCase(name) {\n    return name.toUpperCase().replace(/[^A-Z0-9]/g, '_');\n  }\n  _generateUniqueName(base) {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\nconst _expParser = new Parser(new Lexer());\nfunction createI18nMessageFactory(retainEmptyTokens, preserveExpressionWhitespace) {\n  const visitor = new _I18nVisitor(_expParser, retainEmptyTokens, preserveExpressionWhitespace);\n  return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\nfunction noopVisitNodeFn(_html, i18n) {\n  return i18n;\n}\nclass _I18nVisitor {\n  _expressionParser;\n  _retainEmptyTokens;\n  _preserveExpressionWhitespace;\n  constructor(_expressionParser, _retainEmptyTokens, _preserveExpressionWhitespace) {\n    this._expressionParser = _expressionParser;\n    this._retainEmptyTokens = _retainEmptyTokens;\n    this._preserveExpressionWhitespace = _preserveExpressionWhitespace;\n  }\n  toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {\n    const context = {\n      isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n      icuDepth: 0,\n      placeholderRegistry: new PlaceholderRegistry(),\n      placeholderToContent: {},\n      placeholderToMessage: {},\n      visitNodeFn: visitNodeFn || noopVisitNodeFn\n    };\n    const i18nodes = visitAll(this, nodes, context);\n    return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n  }\n  visitElement(el, context) {\n    return this._visitElementLike(el, context);\n  }\n  visitComponent(component, context) {\n    return this._visitElementLike(component, context);\n  }\n  visitDirective(directive, context) {\n    throw new Error('Unreachable code');\n  }\n  visitAttribute(attribute, context) {\n    const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ? new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) : this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n    return context.visitNodeFn(attribute, node);\n  }\n  visitText(text, context) {\n    const node = text.tokens.length === 1 ? new Text$2(text.value, text.sourceSpan) : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n    return context.visitNodeFn(text, node);\n  }\n  visitComment(comment, context) {\n    return null;\n  }\n  visitExpansion(icu, context) {\n    context.icuDepth++;\n    const i18nIcuCases = {};\n    const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach(caze => {\n      i18nIcuCases[caze.value] = new Container(caze.expression.map(node => node.visit(this, context)), caze.expSourceSpan);\n    });\n    context.icuDepth--;\n    if (context.isIcu || context.icuDepth > 0) {\n      const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      context.placeholderToContent[expPh] = {\n        text: icu.switchValue,\n        sourceSpan: icu.switchValueSourceSpan\n      };\n      return context.visitNodeFn(icu, i18nIcu);\n    }\n    const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n    const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    return context.visitNodeFn(icu, node);\n  }\n  visitExpansionCase(_icuCase, _context) {\n    throw new Error('Unreachable code');\n  }\n  visitBlock(block, context) {\n    const children = visitAll(this, block.children, context);\n    if (block.name === 'switch') {\n      return new Container(children, block.sourceSpan);\n    }\n    const parameters = block.parameters.map(param => param.expression);\n    const startPhName = context.placeholderRegistry.getStartBlockPlaceholderName(block.name, parameters);\n    const closePhName = context.placeholderRegistry.getCloseBlockPlaceholderName(block.name);\n    context.placeholderToContent[startPhName] = {\n      text: block.startSourceSpan.toString(),\n      sourceSpan: block.startSourceSpan\n    };\n    context.placeholderToContent[closePhName] = {\n      text: block.endSourceSpan ? block.endSourceSpan.toString() : '}',\n      sourceSpan: block.endSourceSpan ?? block.sourceSpan\n    };\n    const node = new BlockPlaceholder(block.name, parameters, startPhName, closePhName, children, block.sourceSpan, block.startSourceSpan, block.endSourceSpan);\n    return context.visitNodeFn(block, node);\n  }\n  visitBlockParameter(_parameter, _context) {\n    throw new Error('Unreachable code');\n  }\n  visitLetDeclaration(decl, context) {\n    return null;\n  }\n  _visitElementLike(node, context) {\n    const children = visitAll(this, node.children, context);\n    const attrs = {};\n    const visitAttribute = attr => {\n      attrs[attr.name] = attr.value;\n    };\n    let nodeName;\n    let isVoid;\n    if (node instanceof Element) {\n      nodeName = node.name;\n      isVoid = getHtmlTagDefinition(node.name).isVoid;\n    } else {\n      nodeName = node.fullName;\n      isVoid = node.tagName ? getHtmlTagDefinition(node.tagName).isVoid : false;\n    }\n    node.attrs.forEach(visitAttribute);\n    node.directives.forEach(dir => dir.attrs.forEach(visitAttribute));\n    const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(nodeName, attrs, isVoid);\n    context.placeholderToContent[startPhName] = {\n      text: node.startSourceSpan.toString(),\n      sourceSpan: node.startSourceSpan\n    };\n    let closePhName = '';\n    if (!isVoid) {\n      closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(nodeName);\n      context.placeholderToContent[closePhName] = {\n        text: `</${nodeName}>`,\n        sourceSpan: node.endSourceSpan ?? node.sourceSpan\n      };\n    }\n    const i18nNode = new TagPlaceholder(nodeName, attrs, startPhName, closePhName, children, isVoid, node.sourceSpan, node.startSourceSpan, node.endSourceSpan);\n    return context.visitNodeFn(node, i18nNode);\n  }\n  _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {\n    const nodes = [];\n    let hasInterpolation = false;\n    for (const token of tokens) {\n      switch (token.type) {\n        case 8:\n        case 17:\n          hasInterpolation = true;\n          const [startMarker, expression, endMarker] = token.parts;\n          const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n          const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n          if (this._preserveExpressionWhitespace) {\n            context.placeholderToContent[phName] = {\n              text: token.parts.join(''),\n              sourceSpan: token.sourceSpan\n            };\n            nodes.push(new Placeholder(expression, phName, token.sourceSpan));\n          } else {\n            const normalized = this.normalizeExpression(token);\n            context.placeholderToContent[phName] = {\n              text: `${startMarker}${normalized}${endMarker}`,\n              sourceSpan: token.sourceSpan\n            };\n            nodes.push(new Placeholder(normalized, phName, token.sourceSpan));\n          }\n          break;\n        default:\n          if (token.parts[0].length > 0 || this._retainEmptyTokens) {\n            const previous = nodes[nodes.length - 1];\n            if (previous instanceof Text$2) {\n              previous.value += token.parts[0];\n              previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);\n            } else {\n              nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n            }\n          } else {\n            if (this._retainEmptyTokens) {\n              nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n            }\n          }\n          break;\n      }\n    }\n    if (hasInterpolation) {\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new Container(nodes, sourceSpan);\n    } else {\n      return nodes[0];\n    }\n  }\n  normalizeExpression(token) {\n    const expression = token.parts[1];\n    const expr = this._expressionParser.parseBinding(expression, token.sourceSpan, token.sourceSpan.start.offset);\n    return serialize(expr);\n  }\n}\nfunction reusePreviousSourceSpans(nodes, previousI18n) {\n  if (previousI18n instanceof Message) {\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n  if (previousI18n instanceof Container) {\n    assertEquivalentNodes(previousI18n.children, nodes);\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\nfunction assertSingleContainerMessage(message) {\n  const nodes = message.nodes;\n  if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {\n    throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n  }\n}\nfunction assertEquivalentNodes(previousNodes, nodes) {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error(`\nThe number of i18n message children changed between first and second pass.\n\nFirst pass (${previousNodes.length} tokens):\n${previousNodes.map(node => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n\nSecond pass (${nodes.length} tokens):\n${nodes.map(node => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n    `.trim());\n  }\n  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n    throw new Error('The types of the i18n message children changed between first and second pass.');\n  }\n}\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\nfunction extractPlaceholderName(input) {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\nconst TRUSTED_TYPES_SINKS = new Set(['iframe|srcdoc', '*|innerhtml', '*|outerhtml', 'embed|src', 'object|codebase', 'object|data']);\nfunction isTrustedTypesSink(tagName, propName) {\n  tagName = tagName.toLowerCase();\n  propName = propName.toLowerCase();\n  return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) || TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\nconst setI18nRefs = originalNodeMap => {\n  return (trimmedNode, i18nNode) => {\n    const originalNode = originalNodeMap.get(trimmedNode) ?? trimmedNode;\n    if (originalNode instanceof NodeWithI18n) {\n      if (i18nNode instanceof IcuPlaceholder && originalNode.i18n instanceof Message) {\n        i18nNode.previousMessage = originalNode.i18n;\n      }\n      originalNode.i18n = i18nNode;\n    }\n    return i18nNode;\n  };\n};\nclass I18nMetaVisitor {\n  keepI18nAttrs;\n  enableI18nLegacyMessageIdFormat;\n  preserveSignificantWhitespace;\n  retainEmptyTokens;\n  hasI18nMeta = false;\n  _errors = [];\n  constructor(keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false, preserveSignificantWhitespace = true, retainEmptyTokens = !preserveSignificantWhitespace) {\n    this.keepI18nAttrs = keepI18nAttrs;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n    this.preserveSignificantWhitespace = preserveSignificantWhitespace;\n    this.retainEmptyTokens = retainEmptyTokens;\n  }\n  _generateI18nMessage(nodes, meta = '', visitNodeFn) {\n    const {\n      meaning,\n      description,\n      customId\n    } = this._parseMetadata(meta);\n    const createI18nMessage = createI18nMessageFactory(this.retainEmptyTokens, this.preserveSignificantWhitespace);\n    const message = createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    this._setMessageId(message, meta);\n    this._setLegacyIds(message, meta);\n    return message;\n  }\n  visitAllWithErrors(nodes) {\n    const result = nodes.map(node => node.visit(this, null));\n    return new ParseTreeResult(result, this._errors);\n  }\n  visitElement(element) {\n    this._visitElementLike(element);\n    return element;\n  }\n  visitComponent(component, context) {\n    this._visitElementLike(component);\n    return component;\n  }\n  visitExpansion(expansion, currentMessage) {\n    let message;\n    const meta = expansion.i18n;\n    this.hasI18nMeta = true;\n    if (meta instanceof IcuPlaceholder) {\n      const name = meta.name;\n      message = this._generateI18nMessage([expansion], meta);\n      const icu = icuFromI18nMessage(message);\n      icu.name = name;\n      if (currentMessage !== null) {\n        currentMessage.placeholderToMessage[name] = message;\n      }\n    } else {\n      message = this._generateI18nMessage([expansion], currentMessage || meta);\n    }\n    expansion.i18n = message;\n    return expansion;\n  }\n  visitText(text) {\n    return text;\n  }\n  visitAttribute(attribute) {\n    return attribute;\n  }\n  visitComment(comment) {\n    return comment;\n  }\n  visitExpansionCase(expansionCase) {\n    return expansionCase;\n  }\n  visitBlock(block, context) {\n    visitAll(this, block.children, context);\n    return block;\n  }\n  visitBlockParameter(parameter, context) {\n    return parameter;\n  }\n  visitLetDeclaration(decl, context) {\n    return decl;\n  }\n  visitDirective(directive, context) {\n    return directive;\n  }\n  _visitElementLike(node) {\n    let message = undefined;\n    if (hasI18nAttrs(node)) {\n      this.hasI18nMeta = true;\n      const attrs = [];\n      const attrsMeta = {};\n      for (const attr of node.attrs) {\n        if (attr.name === I18N_ATTR) {\n          const i18n = node.i18n || attr.value;\n          const originalNodeMap = new Map();\n          const trimmedNodes = this.preserveSignificantWhitespace ? node.children : visitAllWithSiblings(new WhitespaceVisitor(false, originalNodeMap), node.children);\n          message = this._generateI18nMessage(trimmedNodes, i18n, setI18nRefs(originalNodeMap));\n          if (message.nodes.length === 0) {\n            message = undefined;\n          }\n          node.i18n = message;\n        } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n          const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n          let isTrustedType;\n          if (node instanceof Component) {\n            isTrustedType = node.tagName === null ? false : isTrustedTypesSink(node.tagName, name);\n          } else {\n            isTrustedType = isTrustedTypesSink(node.name, name);\n          }\n          if (isTrustedType) {\n            this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n          } else {\n            attrsMeta[name] = attr.value;\n          }\n        } else {\n          attrs.push(attr);\n        }\n      }\n      if (Object.keys(attrsMeta).length) {\n        for (const attr of attrs) {\n          const meta = attrsMeta[attr.name];\n          if (meta !== undefined && attr.value) {\n            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n          }\n        }\n      }\n      if (!this.keepI18nAttrs) {\n        node.attrs = attrs;\n      }\n    }\n    visitAll(this, node.children, message);\n  }\n  _parseMetadata(meta) {\n    return typeof meta === 'string' ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};\n  }\n  _setMessageId(message, meta) {\n    if (!message.id) {\n      message.id = meta instanceof Message && meta.id || decimalDigest(message);\n    }\n  }\n  _setLegacyIds(message, meta) {\n    if (this.enableI18nLegacyMessageIdFormat) {\n      message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n    } else if (typeof meta !== 'string') {\n      const previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;\n      message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n    }\n  }\n  _reportError(node, msg) {\n    this._errors.push(new ParseError(node.sourceSpan, msg));\n  }\n}\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\nfunction parseI18nMeta(meta = '') {\n  let customId;\n  let meaning;\n  let description;\n  meta = meta.trim();\n  if (meta) {\n    const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    let meaningAndDesc;\n    [meaningAndDesc, customId] = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n    [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];\n  }\n  return {\n    customId,\n    meaning,\n    description\n  };\n}\nfunction i18nMetaToJSDoc(meta) {\n  const tags = [];\n  if (meta.description) {\n    tags.push({\n      tagName: \"desc\",\n      text: meta.description\n    });\n  } else {\n    tags.push({\n      tagName: \"suppress\",\n      text: '{msgDescriptions}'\n    });\n  }\n  if (meta.meaning) {\n    tags.push({\n      tagName: \"meaning\",\n      text: meta.meaning\n    });\n  }\n  return jsDocComment(tags);\n}\nconst GOOG_GET_MSG = 'goog.getMsg';\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, placeholderValues) {\n  const messageString = serializeI18nMessageForGetMsg(message);\n  const args = [literal(messageString)];\n  if (Object.keys(placeholderValues).length) {\n    args.push(mapLiteral(formatI18nPlaceholderNamesInMap(placeholderValues, true), true));\n    args.push(mapLiteral({\n      original_code: literalMap(Object.keys(placeholderValues).map(param => ({\n        key: formatI18nPlaceholderName(param),\n        quoted: true,\n        value: message.placeholders[param] ? literal(message.placeholders[param].sourceSpan.toString()) : literal(message.placeholderToMessage[param].nodes.map(node => node.sourceSpan.toString()).join(''))\n      })))\n    }));\n  }\n  const googGetMsgStmt = new DeclareVarStmt(closureVar.name, variable(GOOG_GET_MSG).callFn(args), INFERRED_TYPE, StmtModifier.Final);\n  googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));\n  const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));\n  return [googGetMsgStmt, i18nAssignmentStmt];\n}\nclass GetMsgSerializerVisitor {\n  formatPh(value) {\n    return `{$${formatI18nPlaceholderName(value)}}`;\n  }\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    return serializeIcuNode(icu);\n  }\n  visitTagPlaceholder(ph) {\n    return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitPlaceholder(ph) {\n    return this.formatPh(ph.name);\n  }\n  visitBlockPlaceholder(ph) {\n    return `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this.formatPh(ph.name);\n  }\n}\nconst serializerVisitor = new GetMsgSerializerVisitor();\nfunction serializeI18nMessageForGetMsg(message) {\n  return message.nodes.map(node => node.visit(serializerVisitor, null)).join('');\n}\nfunction createLocalizeStatements(variable, message, params) {\n  const {\n    messageParts,\n    placeHolders\n  } = serializeI18nMessageForLocalize(message);\n  const sourceSpan = getSourceSpan(message);\n  const expressions = placeHolders.map(ph => params[ph.text]);\n  const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n  const variableInitialization = variable.set(localizedString$1);\n  return [new ExpressionStatement(variableInitialization)];\n}\nclass LocalizeSerializerVisitor {\n  placeholderToMessage;\n  pieces;\n  constructor(placeholderToMessage, pieces) {\n    this.placeholderToMessage = placeholderToMessage;\n    this.pieces = pieces;\n  }\n  visitText(text) {\n    if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {\n      this.pieces[this.pieces.length - 1].text += text.value;\n    } else {\n      const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);\n      this.pieces.push(new LiteralPiece(text.value, sourceSpan));\n    }\n  }\n  visitContainer(container) {\n    container.children.forEach(child => child.visit(this));\n  }\n  visitIcu(icu) {\n    this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n  }\n  visitTagPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    if (!ph.isVoid) {\n      ph.children.forEach(child => child.visit(this));\n      this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n    }\n  }\n  visitPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n  }\n  visitBlockPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    ph.children.forEach(child => child.visit(this));\n    this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n  }\n  visitIcuPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));\n  }\n  createPlaceholderPiece(name, sourceSpan, associatedMessage) {\n    return new PlaceholderPiece(formatI18nPlaceholderName(name, false), sourceSpan, associatedMessage);\n  }\n}\nfunction serializeI18nMessageForLocalize(message) {\n  const pieces = [];\n  const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n  message.nodes.forEach(node => node.visit(serializerVisitor));\n  return processMessagePieces(pieces);\n}\nfunction getSourceSpan(message) {\n  const startNode = message.nodes[0];\n  const endNode = message.nodes[message.nodes.length - 1];\n  return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\n}\nfunction processMessagePieces(pieces) {\n  const messageParts = [];\n  const placeHolders = [];\n  if (pieces[0] instanceof PlaceholderPiece) {\n    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n  }\n  for (let i = 0; i < pieces.length; i++) {\n    const part = pieces[i];\n    if (part instanceof LiteralPiece) {\n      messageParts.push(part);\n    } else {\n      placeHolders.push(part);\n      if (pieces[i - 1] instanceof PlaceholderPiece) {\n        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n      }\n    }\n  }\n  if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n  }\n  return {\n    messageParts,\n    placeHolders\n  };\n}\nfunction createEmptyMessagePart(location) {\n  return new LiteralPiece('', new ParseSourceSpan(location, location));\n}\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\nconst I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\nconst ESCAPE = '\\uFFFD';\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\nfunction getTranslationConstPrefix(extra) {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\nfunction declareI18nVariable(variable) {\n  return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);\n}\nfunction collectI18nConsts(job) {\n  const fileBasedI18nSuffix = job.relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_').toUpperCase() + '_';\n  const extractedAttributesByI18nContext = new Map();\n  const i18nAttributesByElement = new Map();\n  const i18nExpressionsByElement = new Map();\n  const messages = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.ExtractedAttribute && op.i18nContext !== null) {\n        const attributes = extractedAttributesByI18nContext.get(op.i18nContext) ?? [];\n        attributes.push(op);\n        extractedAttributesByI18nContext.set(op.i18nContext, attributes);\n      } else if (op.kind === OpKind.I18nAttributes) {\n        i18nAttributesByElement.set(op.target, op);\n      } else if (op.kind === OpKind.I18nExpression && op.usage === I18nExpressionFor.I18nAttribute) {\n        const expressions = i18nExpressionsByElement.get(op.target) ?? [];\n        expressions.push(op);\n        i18nExpressionsByElement.set(op.target, expressions);\n      } else if (op.kind === OpKind.I18nMessage) {\n        messages.set(op.xref, op);\n      }\n    }\n  }\n  const i18nValuesByContext = new Map();\n  const messageConstIndices = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nMessage) {\n        if (op.messagePlaceholder === null) {\n          const {\n            mainVar,\n            statements\n          } = collectMessage(job, fileBasedI18nSuffix, messages, op);\n          if (op.i18nBlock !== null) {\n            const i18nConst = job.addConst(mainVar, statements);\n            messageConstIndices.set(op.i18nBlock, i18nConst);\n          } else {\n            job.constsInitializers.push(...statements);\n            i18nValuesByContext.set(op.i18nContext, mainVar);\n            const attributesForMessage = extractedAttributesByI18nContext.get(op.i18nContext);\n            if (attributesForMessage !== undefined) {\n              for (const attr of attributesForMessage) {\n                attr.expression = mainVar.clone();\n              }\n            }\n          }\n        }\n        OpList.remove(op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const elem of unit.create) {\n      if (isElementOrContainerOp(elem)) {\n        const i18nAttributes = i18nAttributesByElement.get(elem.xref);\n        if (i18nAttributes === undefined) {\n          continue;\n        }\n        let i18nExpressions = i18nExpressionsByElement.get(elem.xref);\n        if (i18nExpressions === undefined) {\n          throw new Error('AssertionError: Could not find any i18n expressions associated with an I18nAttributes instruction');\n        }\n        const seenPropertyNames = new Set();\n        i18nExpressions = i18nExpressions.filter(i18nExpr => {\n          const seen = seenPropertyNames.has(i18nExpr.name);\n          seenPropertyNames.add(i18nExpr.name);\n          return !seen;\n        });\n        const i18nAttributeConfig = i18nExpressions.flatMap(i18nExpr => {\n          const i18nExprValue = i18nValuesByContext.get(i18nExpr.context);\n          if (i18nExprValue === undefined) {\n            throw new Error(\"AssertionError: Could not find i18n expression's value\");\n          }\n          return [literal(i18nExpr.name), i18nExprValue];\n        });\n        i18nAttributes.i18nAttributesConfig = job.addConst(new LiteralArrayExpr(i18nAttributeConfig));\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nStart) {\n        const msgIndex = messageConstIndices.get(op.root);\n        if (msgIndex === undefined) {\n          throw new Error('AssertionError: Could not find corresponding i18n block index for an i18n message op; was an i18n message incorrectly assumed to correspond to an attribute?');\n        }\n        op.messageIndex = msgIndex;\n      }\n    }\n  }\n}\nfunction collectMessage(job, fileBasedI18nSuffix, messages, messageOp) {\n  const statements = [];\n  const subMessagePlaceholders = new Map();\n  for (const subMessageId of messageOp.subMessages) {\n    const subMessage = messages.get(subMessageId);\n    const {\n      mainVar: subMessageVar,\n      statements: subMessageStatements\n    } = collectMessage(job, fileBasedI18nSuffix, messages, subMessage);\n    statements.push(...subMessageStatements);\n    const subMessages = subMessagePlaceholders.get(subMessage.messagePlaceholder) ?? [];\n    subMessages.push(subMessageVar);\n    subMessagePlaceholders.set(subMessage.messagePlaceholder, subMessages);\n  }\n  addSubMessageParams(messageOp, subMessagePlaceholders);\n  messageOp.params = new Map([...messageOp.params.entries()].sort());\n  const mainVar = variable(job.pool.uniqueName(TRANSLATION_VAR_PREFIX));\n  const closureVar = i18nGenerateClosureVar(job.pool, messageOp.message.id, fileBasedI18nSuffix, job.i18nUseExternalIds);\n  let transformFn = undefined;\n  if (messageOp.needsPostprocessing || messageOp.postprocessingParams.size > 0) {\n    const postprocessingParams = Object.fromEntries([...messageOp.postprocessingParams.entries()].sort());\n    const formattedPostprocessingParams = formatI18nPlaceholderNamesInMap(postprocessingParams, false);\n    const extraTransformFnParams = [];\n    if (messageOp.postprocessingParams.size > 0) {\n      extraTransformFnParams.push(mapLiteral(formattedPostprocessingParams, true));\n    }\n    transformFn = expr => importExpr(Identifiers.i18nPostprocess).callFn([expr, ...extraTransformFnParams]);\n  }\n  statements.push(...getTranslationDeclStmts(messageOp.message, mainVar, closureVar, messageOp.params, transformFn));\n  return {\n    mainVar,\n    statements\n  };\n}\nfunction addSubMessageParams(messageOp, subMessagePlaceholders) {\n  for (const [placeholder, subMessages] of subMessagePlaceholders) {\n    if (subMessages.length === 1) {\n      messageOp.params.set(placeholder, subMessages[0]);\n    } else {\n      messageOp.params.set(placeholder, literal(`${ESCAPE}${I18N_ICU_MAPPING_PREFIX}${placeholder}${ESCAPE}`));\n      messageOp.postprocessingParams.set(placeholder, literalArr(subMessages));\n    }\n  }\n}\nfunction getTranslationDeclStmts(message, variable, closureVar, params, transformFn) {\n  const paramsObject = Object.fromEntries(params);\n  const statements = [declareI18nVariable(variable), ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, paramsObject), createLocalizeStatements(variable, message, formatI18nPlaceholderNamesInMap(paramsObject, false)))];\n  if (transformFn) {\n    statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n  }\n  return statements;\n}\nfunction createClosureModeGuard() {\n  return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal('undefined', STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));\n}\nfunction i18nGenerateClosureVar(pool, messageId, fileBasedI18nSuffix, useExternalIds) {\n  let name;\n  const suffix = fileBasedI18nSuffix;\n  if (useExternalIds) {\n    const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n    const uniqueSuffix = pool.uniqueName(suffix);\n    name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n  } else {\n    const prefix = getTranslationConstPrefix(suffix);\n    name = pool.uniqueName(prefix);\n  }\n  return variable(name);\n}\nfunction convertI18nText(job) {\n  for (const unit of job.units) {\n    let currentI18n = null;\n    let currentIcu = null;\n    const textNodeI18nBlocks = new Map();\n    const textNodeIcus = new Map();\n    const icuPlaceholderByText = new Map();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          if (op.context === null) {\n            throw Error('I18n op should have its context set.');\n          }\n          currentI18n = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18n = null;\n          break;\n        case OpKind.IcuStart:\n          if (op.context === null) {\n            throw Error('Icu op should have its context set.');\n          }\n          currentIcu = op;\n          break;\n        case OpKind.IcuEnd:\n          currentIcu = null;\n          break;\n        case OpKind.Text:\n          if (currentI18n !== null) {\n            textNodeI18nBlocks.set(op.xref, currentI18n);\n            textNodeIcus.set(op.xref, currentIcu);\n            if (op.icuPlaceholder !== null) {\n              const icuPlaceholderOp = createIcuPlaceholderOp(job.allocateXrefId(), op.icuPlaceholder, [op.initialValue]);\n              OpList.replace(op, icuPlaceholderOp);\n              icuPlaceholderByText.set(op.xref, icuPlaceholderOp);\n            } else {\n              OpList.remove(op);\n            }\n          }\n          break;\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.InterpolateText:\n          if (!textNodeI18nBlocks.has(op.target)) {\n            continue;\n          }\n          const i18nOp = textNodeI18nBlocks.get(op.target);\n          const icuOp = textNodeIcus.get(op.target);\n          const icuPlaceholder = icuPlaceholderByText.get(op.target);\n          const contextId = icuOp ? icuOp.context : i18nOp.context;\n          const resolutionTime = icuOp ? I18nParamResolutionTime.Postproccessing : I18nParamResolutionTime.Creation;\n          const ops = [];\n          for (let i = 0; i < op.interpolation.expressions.length; i++) {\n            const expr = op.interpolation.expressions[i];\n            ops.push(createI18nExpressionOp(contextId, i18nOp.xref, i18nOp.xref, i18nOp.handle, expr, icuPlaceholder?.xref ?? null, op.interpolation.i18nPlaceholders[i] ?? null, resolutionTime, I18nExpressionFor.I18nText, '', expr.sourceSpan ?? op.sourceSpan));\n          }\n          OpList.replaceWithMany(op, ops);\n          if (icuPlaceholder !== undefined) {\n            icuPlaceholder.strings = op.interpolation.strings;\n          }\n          break;\n      }\n    }\n  }\n}\nfunction liftLocalRefs(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.ElementStart:\n        case OpKind.ConditionalCreate:\n        case OpKind.ConditionalBranchCreate:\n        case OpKind.Template:\n          if (!Array.isArray(op.localRefs)) {\n            throw new Error(`AssertionError: expected localRefs to be an array still`);\n          }\n          op.numSlotsUsed += op.localRefs.length;\n          if (op.localRefs.length > 0) {\n            const localRefs = serializeLocalRefs(op.localRefs);\n            op.localRefs = job.addConst(localRefs);\n          } else {\n            op.localRefs = null;\n          }\n          break;\n      }\n    }\n  }\n}\nfunction serializeLocalRefs(refs) {\n  const constRefs = [];\n  for (const ref of refs) {\n    constRefs.push(literal(ref.name), literal(ref.target));\n  }\n  return literalArr(constRefs);\n}\nfunction emitNamespaceChanges(job) {\n  for (const unit of job.units) {\n    let activeNamespace = Namespace.HTML;\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.ElementStart) {\n        continue;\n      }\n      if (op.namespace !== activeNamespace) {\n        OpList.insertBefore(createNamespaceOp(op.namespace), op);\n        activeNamespace = op.namespace;\n      }\n    }\n  }\n}\nfunction parse(value) {\n  const styles = [];\n  let i = 0;\n  let parenDepth = 0;\n  let quote = 0;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp = null;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++);\n    switch (token) {\n      case 40:\n        parenDepth++;\n        break;\n      case 41:\n        parenDepth--;\n        break;\n      case 39:\n        if (quote === 0) {\n          quote = 39;\n        } else if (quote === 39 && value.charCodeAt(i - 1) !== 92) {\n          quote = 0;\n        }\n        break;\n      case 34:\n        if (quote === 0) {\n          quote = 34;\n        } else if (quote === 34 && value.charCodeAt(i - 1) !== 92) {\n          quote = 0;\n        }\n        break;\n      case 58:\n        if (!currentProp && parenDepth === 0 && quote === 0) {\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case 59:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n        }\n        break;\n    }\n  }\n  if (currentProp && valueStart) {\n    const styleVal = value.slice(valueStart).trim();\n    styles.push(currentProp, styleVal);\n  }\n  return styles;\n}\nfunction hyphenate(value) {\n  return value.replace(/[a-z][A-Z]/g, v => {\n    return v.charAt(0) + '-' + v.charAt(1);\n  }).toLowerCase();\n}\nfunction parseExtractedStyles(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (isElementOrContainerOp(op)) {\n        elements.set(op.xref, op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ExtractedAttribute && op.bindingKind === BindingKind.Attribute && isStringLiteral(op.expression)) {\n        const target = elements.get(op.target);\n        if (target !== undefined && (target.kind === OpKind.Template || target.kind === OpKind.ConditionalCreate || target.kind === OpKind.ConditionalBranchCreate) && target.templateKind === TemplateKind.Structural) {\n          continue;\n        }\n        if (op.name === 'style') {\n          const parsedStyles = parse(op.expression.value);\n          for (let i = 0; i < parsedStyles.length - 1; i += 2) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.StyleProperty, null, parsedStyles[i], literal(parsedStyles[i + 1]), null, null, SecurityContext.STYLE), op);\n          }\n          OpList.remove(op);\n        } else if (op.name === 'class') {\n          const parsedClasses = op.expression.value.trim().split(/\\s+/g);\n          for (const parsedClass of parsedClasses) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.ClassName, null, parsedClass, null, null, null, SecurityContext.NONE), op);\n          }\n          OpList.remove(op);\n        }\n      }\n    }\n  }\n}\nfunction nameFunctionsAndVariables(job) {\n  addNamesToView(job.root, job.componentName, {\n    index: 0\n  }, job.compatibility === CompatibilityMode.TemplateDefinitionBuilder);\n}\nfunction addNamesToView(unit, baseName, state, compatibility) {\n  if (unit.fnName === null) {\n    unit.fnName = unit.job.pool.uniqueName(sanitizeIdentifier(`${baseName}_${unit.job.fnSuffix}`), false);\n  }\n  const varNames = new Map();\n  for (const op of unit.ops()) {\n    switch (op.kind) {\n      case OpKind.Property:\n      case OpKind.DomProperty:\n        if (op.bindingKind === BindingKind.LegacyAnimation) {\n          op.name = '@' + op.name;\n        }\n        break;\n      case OpKind.Animation:\n        if (op.handlerFnName === null) {\n          const animationKind = op.name.replace('.', '');\n          op.handlerFnName = `${unit.fnName}_${animationKind}_cb`;\n          op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        }\n        break;\n      case OpKind.AnimationListener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (!op.hostListener && op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        const animationKind = op.name.replace('.', '');\n        if (op.hostListener) {\n          op.handlerFnName = `${baseName}_${animationKind}_HostBindingHandler`;\n        } else {\n          op.handlerFnName = `${unit.fnName}_${op.tag.replace('-', '_')}_${animationKind}_${op.targetSlot.slot}_listener`;\n        }\n        op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        break;\n      case OpKind.Listener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (!op.hostListener && op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        let animation = '';\n        if (op.isLegacyAnimationListener) {\n          op.name = `@${op.name}.${op.legacyAnimationPhase}`;\n          animation = 'animation';\n        }\n        if (op.hostListener) {\n          op.handlerFnName = `${baseName}_${animation}${op.name}_HostBindingHandler`;\n        } else {\n          op.handlerFnName = `${unit.fnName}_${op.tag.replace('-', '_')}_${animation}${op.name}_${op.targetSlot.slot}_listener`;\n        }\n        op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        break;\n      case OpKind.TwoWayListener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        op.handlerFnName = sanitizeIdentifier(`${unit.fnName}_${op.tag.replace('-', '_')}_${op.name}_${op.targetSlot.slot}_listener`);\n        break;\n      case OpKind.Variable:\n        varNames.set(op.xref, getVariableName(unit, op.variable, state));\n        break;\n      case OpKind.RepeaterCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        if (op.emptyView !== null) {\n          const emptyView = unit.job.views.get(op.emptyView);\n          addNamesToView(emptyView, `${baseName}_${op.functionNameSuffix}Empty_${op.handle.slot + 2}`, state, compatibility);\n        }\n        addNamesToView(unit.job.views.get(op.xref), `${baseName}_${op.functionNameSuffix}_${op.handle.slot + 1}`, state, compatibility);\n        break;\n      case OpKind.Projection:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        if (op.fallbackView !== null) {\n          const fallbackView = unit.job.views.get(op.fallbackView);\n          addNamesToView(fallbackView, `${baseName}_ProjectionFallback_${op.handle.slot}`, state, compatibility);\n        }\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        const childView = unit.job.views.get(op.xref);\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        const suffix = op.functionNameSuffix.length === 0 ? '' : `_${op.functionNameSuffix}`;\n        addNamesToView(childView, `${baseName}${suffix}_${op.handle.slot}`, state, compatibility);\n        break;\n      case OpKind.StyleProp:\n        op.name = normalizeStylePropName(op.name);\n        if (compatibility) {\n          op.name = stripImportant(op.name);\n        }\n        break;\n      case OpKind.ClassProp:\n        if (compatibility) {\n          op.name = stripImportant(op.name);\n        }\n        break;\n    }\n  }\n  for (const op of unit.ops()) {\n    visitExpressionsInOp(op, expr => {\n      if (!(expr instanceof ReadVariableExpr) || expr.name !== null) {\n        return;\n      }\n      if (!varNames.has(expr.xref)) {\n        throw new Error(`Variable ${expr.xref} not yet named`);\n      }\n      expr.name = varNames.get(expr.xref);\n    });\n  }\n}\nfunction getVariableName(unit, variable, state) {\n  if (variable.name === null) {\n    switch (variable.kind) {\n      case SemanticVariableKind.Context:\n        variable.name = `ctx_r${state.index++}`;\n        break;\n      case SemanticVariableKind.Identifier:\n        if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n          const compatPrefix = variable.identifier === 'ctx' ? 'i' : '';\n          variable.name = `${variable.identifier}_${compatPrefix}r${++state.index}`;\n        } else {\n          variable.name = `${variable.identifier}_i${state.index++}`;\n        }\n        break;\n      default:\n        variable.name = `_r${++state.index}`;\n        break;\n    }\n  }\n  return variable.name;\n}\nfunction normalizeStylePropName(name) {\n  return name.startsWith('--') ? name : hyphenate(name);\n}\nfunction stripImportant(name) {\n  const importantIndex = name.indexOf('!important');\n  if (importantIndex > -1) {\n    return name.substring(0, importantIndex);\n  }\n  return name;\n}\nfunction mergeNextContextExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        mergeNextContextsInOps(op.handlerOps);\n      }\n    }\n    mergeNextContextsInOps(unit.update);\n  }\n}\nfunction mergeNextContextsInOps(ops) {\n  for (const op of ops) {\n    if (op.kind !== OpKind.Statement || !(op.statement instanceof ExpressionStatement) || !(op.statement.expr instanceof NextContextExpr)) {\n      continue;\n    }\n    const mergeSteps = op.statement.expr.steps;\n    let tryToMerge = true;\n    for (let candidate = op.next; candidate.kind !== OpKind.ListEnd && tryToMerge; candidate = candidate.next) {\n      visitExpressionsInOp(candidate, (expr, flags) => {\n        if (!isIrExpression(expr)) {\n          return expr;\n        }\n        if (!tryToMerge) {\n          return;\n        }\n        if (flags & VisitorContextFlag.InChildOperation) {\n          return;\n        }\n        switch (expr.kind) {\n          case ExpressionKind.NextContext:\n            expr.steps += mergeSteps;\n            OpList.remove(op);\n            tryToMerge = false;\n            break;\n          case ExpressionKind.GetCurrentView:\n          case ExpressionKind.Reference:\n          case ExpressionKind.ContextLetReference:\n            tryToMerge = false;\n            break;\n        }\n        return;\n      });\n    }\n  }\n}\nconst CONTAINER_TAG = 'ng-container';\nfunction generateNgContainerOps(job) {\n  for (const unit of job.units) {\n    const updatedElementXrefs = new Set();\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ElementStart && op.tag === CONTAINER_TAG) {\n        op.kind = OpKind.ContainerStart;\n        updatedElementXrefs.add(op.xref);\n      }\n      if (op.kind === OpKind.ElementEnd && updatedElementXrefs.has(op.xref)) {\n        op.kind = OpKind.ContainerEnd;\n      }\n    }\n  }\n}\nfunction lookupElement(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction disableBindings$1(job) {\n  const elements = new Map();\n  for (const view of job.units) {\n    for (const op of view.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if ((op.kind === OpKind.ElementStart || op.kind === OpKind.ContainerStart) && op.nonBindable) {\n        OpList.insertAfter(createDisableBindingsOp(op.xref), op);\n      }\n      if ((op.kind === OpKind.ElementEnd || op.kind === OpKind.ContainerEnd) && lookupElement(elements, op.xref).nonBindable) {\n        OpList.insertBefore(createEnableBindingsOp(op.xref), op);\n      }\n    }\n  }\n}\nfunction kindTest(kind) {\n  return op => op.kind === kind;\n}\nfunction kindWithInterpolationTest(kind, interpolation) {\n  return op => {\n    return op.kind === kind && interpolation === op.expression instanceof Interpolation;\n  };\n}\nfunction basicListenerKindTest(op) {\n  return op.kind === OpKind.Listener && !(op.hostListener && op.isLegacyAnimationListener) || op.kind === OpKind.TwoWayListener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener;\n}\nfunction nonInterpolationPropertyKindTest(op) {\n  return (op.kind === OpKind.Property || op.kind === OpKind.TwoWayProperty) && !(op.expression instanceof Interpolation);\n}\nconst CREATE_ORDERING = [{\n  test: op => op.kind === OpKind.Listener && op.hostListener && op.isLegacyAnimationListener\n}, {\n  test: basicListenerKindTest\n}];\nconst UPDATE_ORDERING = [{\n  test: kindTest(OpKind.StyleMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.ClassMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.StyleProp)\n}, {\n  test: kindTest(OpKind.ClassProp)\n}, {\n  test: kindWithInterpolationTest(OpKind.Attribute, true)\n}, {\n  test: kindWithInterpolationTest(OpKind.Property, true)\n}, {\n  test: nonInterpolationPropertyKindTest\n}, {\n  test: kindWithInterpolationTest(OpKind.Attribute, false)\n}];\nconst UPDATE_HOST_ORDERING = [{\n  test: kindWithInterpolationTest(OpKind.DomProperty, true)\n}, {\n  test: kindWithInterpolationTest(OpKind.DomProperty, false)\n}, {\n  test: kindTest(OpKind.Attribute)\n}, {\n  test: kindTest(OpKind.StyleMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.ClassMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.StyleProp)\n}, {\n  test: kindTest(OpKind.ClassProp)\n}];\nconst handledOpKinds = new Set([OpKind.Listener, OpKind.TwoWayListener, OpKind.AnimationListener, OpKind.StyleMap, OpKind.ClassMap, OpKind.StyleProp, OpKind.ClassProp, OpKind.Property, OpKind.TwoWayProperty, OpKind.DomProperty, OpKind.Attribute, OpKind.Animation]);\nfunction orderOps(job) {\n  for (const unit of job.units) {\n    orderWithin(unit.create, CREATE_ORDERING);\n    const ordering = unit.job.kind === CompilationJobKind.Host ? UPDATE_HOST_ORDERING : UPDATE_ORDERING;\n    orderWithin(unit.update, ordering);\n  }\n}\nfunction orderWithin(opList, ordering) {\n  let opsToOrder = [];\n  let firstTargetInGroup = null;\n  for (const op of opList) {\n    const currentTarget = hasDependsOnSlotContextTrait(op) ? op.target : null;\n    if (!handledOpKinds.has(op.kind) || currentTarget !== firstTargetInGroup && firstTargetInGroup !== null && currentTarget !== null) {\n      OpList.insertBefore(reorder(opsToOrder, ordering), op);\n      opsToOrder = [];\n      firstTargetInGroup = null;\n    }\n    if (handledOpKinds.has(op.kind)) {\n      opsToOrder.push(op);\n      OpList.remove(op);\n      firstTargetInGroup = currentTarget ?? firstTargetInGroup;\n    }\n  }\n  opList.push(reorder(opsToOrder, ordering));\n}\nfunction reorder(ops, ordering) {\n  const groups = Array.from(ordering, () => new Array());\n  for (const op of ops) {\n    const groupIndex = ordering.findIndex(o => o.test(op));\n    groups[groupIndex].push(op);\n  }\n  return groups.flatMap((group, i) => {\n    const transform = ordering[i].transform;\n    return transform ? transform(group) : group;\n  });\n}\nfunction keepLast(ops) {\n  return ops.slice(ops.length - 1);\n}\nfunction removeContentSelectors(job) {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Binding:\n          const target = lookupInXrefMap(elements, op.target);\n          if (isSelectAttribute(op.name) && target.kind === OpKind.Projection) {\n            OpList.remove(op);\n          }\n          break;\n      }\n    }\n  }\n}\nfunction isSelectAttribute(name) {\n  return name.toLowerCase() === 'select';\n}\nfunction lookupInXrefMap(map, xref) {\n  const el = map.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an slottable target.');\n  }\n  return el;\n}\nfunction createPipes(job) {\n  for (const unit of job.units) {\n    processPipeBindingsInView(unit);\n  }\n}\nfunction processPipeBindingsInView(unit) {\n  for (const updateOp of unit.update) {\n    visitExpressionsInOp(updateOp, (expr, flags) => {\n      if (!isIrExpression(expr)) {\n        return;\n      }\n      if (expr.kind !== ExpressionKind.PipeBinding) {\n        return;\n      }\n      if (flags & VisitorContextFlag.InChildOperation) {\n        throw new Error(`AssertionError: pipe bindings should not appear in child expressions`);\n      }\n      if (unit.job.compatibility) {\n        const slotHandle = updateOp.target;\n        if (slotHandle == undefined) {\n          throw new Error(`AssertionError: expected slot handle to be assigned for pipe creation`);\n        }\n        addPipeToCreationBlock(unit, updateOp.target, expr);\n      } else {\n        unit.create.push(createPipeOp(expr.target, expr.targetSlot, expr.name));\n      }\n    });\n  }\n}\nfunction addPipeToCreationBlock(unit, afterTargetXref, binding) {\n  for (let op = unit.create.head.next; op.kind !== OpKind.ListEnd; op = op.next) {\n    if (!hasConsumesSlotTrait(op)) {\n      continue;\n    }\n    if (op.xref !== afterTargetXref) {\n      continue;\n    }\n    while (op.next.kind === OpKind.Pipe) {\n      op = op.next;\n    }\n    const pipe = createPipeOp(binding.target, binding.targetSlot, binding.name);\n    OpList.insertBefore(pipe, op.next);\n    return;\n  }\n  throw new Error(`AssertionError: unable to find insertion point for pipe ${binding.name}`);\n}\nfunction createVariadicPipes(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, expr => {\n        if (!(expr instanceof PipeBindingExpr)) {\n          return expr;\n        }\n        if (expr.args.length <= 4) {\n          return expr;\n        }\n        return new PipeBindingVariadicExpr(expr.target, expr.targetSlot, expr.name, literalArr(expr.args), expr.args.length);\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction propagateI18nBlocks(job) {\n  propagateI18nBlocksToTemplates(job.root, 0);\n}\nfunction propagateI18nBlocksToTemplates(unit, subTemplateIndex) {\n  let i18nBlock = null;\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case OpKind.I18nStart:\n        op.subTemplateIndex = subTemplateIndex === 0 ? null : subTemplateIndex;\n        i18nBlock = op;\n        break;\n      case OpKind.I18nEnd:\n        if (i18nBlock.subTemplateIndex === null) {\n          subTemplateIndex = 0;\n        }\n        i18nBlock = null;\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.xref), i18nBlock, op.i18nPlaceholder, subTemplateIndex);\n        break;\n      case OpKind.RepeaterCreate:\n        const forView = unit.job.views.get(op.xref);\n        subTemplateIndex = propagateI18nBlocksForView(forView, i18nBlock, op.i18nPlaceholder, subTemplateIndex);\n        if (op.emptyView !== null) {\n          subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.emptyView), i18nBlock, op.emptyI18nPlaceholder, subTemplateIndex);\n        }\n        break;\n      case OpKind.Projection:\n        if (op.fallbackView !== null) {\n          subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.fallbackView), i18nBlock, op.fallbackViewI18nPlaceholder, subTemplateIndex);\n        }\n        break;\n    }\n  }\n  return subTemplateIndex;\n}\nfunction propagateI18nBlocksForView(view, i18nBlock, i18nPlaceholder, subTemplateIndex) {\n  if (i18nPlaceholder !== undefined) {\n    if (i18nBlock === null) {\n      throw Error('Expected template with i18n placeholder to be in an i18n block.');\n    }\n    subTemplateIndex++;\n    wrapTemplateWithI18n(view, i18nBlock);\n  }\n  return propagateI18nBlocksToTemplates(view, subTemplateIndex);\n}\nfunction wrapTemplateWithI18n(unit, parentI18n) {\n  if (unit.create.head.next?.kind !== OpKind.I18nStart) {\n    const id = unit.job.allocateXrefId();\n    OpList.insertAfter(createI18nStartOp(id, parentI18n.message, parentI18n.root, null), unit.create.head);\n    OpList.insertBefore(createI18nEndOp(id, null), unit.create.tail);\n  }\n}\nfunction extractPureFunctions(job) {\n  for (const view of job.units) {\n    for (const op of view.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (!(expr instanceof PureFunctionExpr) || expr.body === null) {\n          return;\n        }\n        const constantDef = new PureFunctionConstant(expr.args.length);\n        expr.fn = job.pool.getSharedConstant(constantDef, expr.body);\n        expr.body = null;\n      });\n    }\n  }\n}\nclass PureFunctionConstant extends GenericKeyFn {\n  numArgs;\n  constructor(numArgs) {\n    super();\n    this.numArgs = numArgs;\n  }\n  keyOf(expr) {\n    if (expr instanceof PureFunctionParameterExpr) {\n      return `param(${expr.index})`;\n    } else {\n      return super.keyOf(expr);\n    }\n  }\n  toSharedConstantDeclaration(declName, keyExpr) {\n    const fnParams = [];\n    for (let idx = 0; idx < this.numArgs; idx++) {\n      fnParams.push(new FnParam('a' + idx));\n    }\n    const returnExpr = transformExpressionsInExpression(keyExpr, expr => {\n      if (!(expr instanceof PureFunctionParameterExpr)) {\n        return expr;\n      }\n      return variable('a' + expr.index);\n    }, VisitorContextFlag.None);\n    return new DeclareVarStmt(declName, new ArrowFunctionExpr(fnParams, returnExpr), undefined, StmtModifier.Final);\n  }\n}\nfunction generatePureLiteralStructures(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, (expr, flags) => {\n        if (flags & VisitorContextFlag.InChildOperation) {\n          return expr;\n        }\n        if (expr instanceof LiteralArrayExpr) {\n          return transformLiteralArray(expr);\n        } else if (expr instanceof LiteralMapExpr) {\n          return transformLiteralMap(expr);\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction transformLiteralArray(expr) {\n  const derivedEntries = [];\n  const nonConstantArgs = [];\n  for (const entry of expr.entries) {\n    if (entry.isConstant()) {\n      derivedEntries.push(entry);\n    } else {\n      const idx = nonConstantArgs.length;\n      nonConstantArgs.push(entry);\n      derivedEntries.push(new PureFunctionParameterExpr(idx));\n    }\n  }\n  return new PureFunctionExpr(literalArr(derivedEntries), nonConstantArgs);\n}\nfunction transformLiteralMap(expr) {\n  let derivedEntries = [];\n  const nonConstantArgs = [];\n  for (const entry of expr.entries) {\n    if (entry.value.isConstant()) {\n      derivedEntries.push(entry);\n    } else {\n      const idx = nonConstantArgs.length;\n      nonConstantArgs.push(entry.value);\n      derivedEntries.push(new LiteralMapEntry(entry.key, new PureFunctionParameterExpr(idx), entry.quoted));\n    }\n  }\n  return new PureFunctionExpr(literalMap(derivedEntries), nonConstantArgs);\n}\nfunction optimizeRegularExpressions(job) {\n  for (const view of job.units) {\n    for (const op of view.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof RegularExpressionLiteralExpr && (expr.flags === null || !expr.flags.includes('g'))) {\n          return job.pool.getSharedConstant(new RegularExpressionConstant(), expr);\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nclass RegularExpressionConstant extends GenericKeyFn {\n  toSharedConstantDeclaration(declName, keyExpr) {\n    return new DeclareVarStmt(declName, keyExpr, undefined, StmtModifier.Final);\n  }\n}\nfunction element(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.element, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementStart(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementStart, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementOrContainerBase(instruction, slot, tag, constIndex, localRefIndex, sourceSpan) {\n  const args = [literal(slot)];\n  if (tag !== null) {\n    args.push(literal(tag));\n  }\n  if (localRefIndex !== null) {\n    args.push(literal(constIndex), literal(localRefIndex));\n  } else if (constIndex !== null) {\n    args.push(literal(constIndex));\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction templateBase(instruction, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction propertyBase(instruction, name, expression, sanitizer, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction elementEnd(sourceSpan) {\n  return call(Identifiers.elementEnd, [], sourceSpan);\n}\nfunction elementContainerStart(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementContainerStart, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementContainer(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementContainer, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementContainerEnd() {\n  return call(Identifiers.elementContainerEnd, [], null);\n}\nfunction template(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  return templateBase(Identifiers.templateCreate, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan);\n}\nfunction disableBindings() {\n  return call(Identifiers.disableBindings, [], null);\n}\nfunction enableBindings() {\n  return call(Identifiers.enableBindings, [], null);\n}\nfunction listener(name, handlerFn, eventTargetResolver, syntheticHost, sourceSpan) {\n  const args = [literal(name), handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(importExpr(eventTargetResolver));\n  }\n  return call(syntheticHost ? Identifiers.syntheticHostListener : Identifiers.listener, args, sourceSpan);\n}\nfunction twoWayBindingSet(target, value) {\n  return importExpr(Identifiers.twoWayBindingSet).callFn([target, value]);\n}\nfunction twoWayListener(name, handlerFn, sourceSpan) {\n  return call(Identifiers.twoWayListener, [literal(name), handlerFn], sourceSpan);\n}\nfunction pipe(slot, name) {\n  return call(Identifiers.pipe, [literal(slot), literal(name)], null);\n}\nfunction namespaceHTML() {\n  return call(Identifiers.namespaceHTML, [], null);\n}\nfunction namespaceSVG() {\n  return call(Identifiers.namespaceSVG, [], null);\n}\nfunction namespaceMath() {\n  return call(Identifiers.namespaceMathML, [], null);\n}\nfunction advance(delta, sourceSpan) {\n  return call(Identifiers.advance, delta > 1 ? [literal(delta)] : [], sourceSpan);\n}\nfunction reference(slot) {\n  return importExpr(Identifiers.reference).callFn([literal(slot)]);\n}\nfunction nextContext(steps) {\n  return importExpr(Identifiers.nextContext).callFn(steps === 1 ? [] : [literal(steps)]);\n}\nfunction getCurrentView() {\n  return importExpr(Identifiers.getCurrentView).callFn([]);\n}\nfunction restoreView(savedView) {\n  return importExpr(Identifiers.restoreView).callFn([savedView]);\n}\nfunction resetView(returnValue) {\n  return importExpr(Identifiers.resetView).callFn([returnValue]);\n}\nfunction text(slot, initialValue, sourceSpan) {\n  const args = [literal(slot, null)];\n  if (initialValue !== '') {\n    args.push(literal(initialValue));\n  }\n  return call(Identifiers.text, args, sourceSpan);\n}\nfunction defer(selfSlot, primarySlot, dependencyResolverFn, loadingSlot, placeholderSlot, errorSlot, loadingConfig, placeholderConfig, enableTimerScheduling, sourceSpan, flags) {\n  const args = [literal(selfSlot), literal(primarySlot), dependencyResolverFn ?? literal(null), literal(loadingSlot), literal(placeholderSlot), literal(errorSlot), loadingConfig ?? literal(null), placeholderConfig ?? literal(null), enableTimerScheduling ? importExpr(Identifiers.deferEnableTimerScheduling) : literal(null), literal(flags)];\n  let expr;\n  while ((expr = args[args.length - 1]) !== null && expr instanceof LiteralExpr && expr.value === null) {\n    args.pop();\n  }\n  return call(Identifiers.defer, args, sourceSpan);\n}\nconst deferTriggerToR3TriggerInstructionsMap = new Map([[DeferTriggerKind.Idle, {\n  [\"none\"]: Identifiers.deferOnIdle,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnIdle,\n  [\"hydrate\"]: Identifiers.deferHydrateOnIdle\n}], [DeferTriggerKind.Immediate, {\n  [\"none\"]: Identifiers.deferOnImmediate,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnImmediate,\n  [\"hydrate\"]: Identifiers.deferHydrateOnImmediate\n}], [DeferTriggerKind.Timer, {\n  [\"none\"]: Identifiers.deferOnTimer,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnTimer,\n  [\"hydrate\"]: Identifiers.deferHydrateOnTimer\n}], [DeferTriggerKind.Hover, {\n  [\"none\"]: Identifiers.deferOnHover,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnHover,\n  [\"hydrate\"]: Identifiers.deferHydrateOnHover\n}], [DeferTriggerKind.Interaction, {\n  [\"none\"]: Identifiers.deferOnInteraction,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnInteraction,\n  [\"hydrate\"]: Identifiers.deferHydrateOnInteraction\n}], [DeferTriggerKind.Viewport, {\n  [\"none\"]: Identifiers.deferOnViewport,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnViewport,\n  [\"hydrate\"]: Identifiers.deferHydrateOnViewport\n}], [DeferTriggerKind.Never, {\n  [\"none\"]: Identifiers.deferHydrateNever,\n  [\"prefetch\"]: Identifiers.deferHydrateNever,\n  [\"hydrate\"]: Identifiers.deferHydrateNever\n}]]);\nfunction deferOn(trigger, args, modifier, sourceSpan) {\n  const instructionToCall = deferTriggerToR3TriggerInstructionsMap.get(trigger)?.[modifier];\n  if (instructionToCall === undefined) {\n    throw new Error(`Unable to determine instruction for trigger ${trigger}`);\n  }\n  return call(instructionToCall, args, sourceSpan);\n}\nfunction projectionDef(def) {\n  return call(Identifiers.projectionDef, def ? [def] : [], null);\n}\nfunction projection(slot, projectionSlotIndex, attributes, fallbackFnName, fallbackDecls, fallbackVars, sourceSpan) {\n  const args = [literal(slot)];\n  if (projectionSlotIndex !== 0 || attributes !== null || fallbackFnName !== null) {\n    args.push(literal(projectionSlotIndex));\n    if (attributes !== null) {\n      args.push(attributes);\n    }\n    if (fallbackFnName !== null) {\n      if (attributes === null) {\n        args.push(literal(null));\n      }\n      args.push(variable(fallbackFnName), literal(fallbackDecls), literal(fallbackVars));\n    }\n  }\n  return call(Identifiers.projection, args, sourceSpan);\n}\nfunction i18nStart(slot, constIndex, subTemplateIndex, sourceSpan) {\n  const args = [literal(slot), literal(constIndex)];\n  if (subTemplateIndex !== null) {\n    args.push(literal(subTemplateIndex));\n  }\n  return call(Identifiers.i18nStart, args, sourceSpan);\n}\nfunction conditionalCreate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(Identifiers.conditionalCreate, args, sourceSpan);\n}\nfunction conditionalBranchCreate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(Identifiers.conditionalBranchCreate, args, sourceSpan);\n}\nfunction repeaterCreate(slot, viewFnName, decls, vars, tag, constIndex, trackByFn, trackByUsesComponentInstance, emptyViewFnName, emptyDecls, emptyVars, emptyTag, emptyConstIndex, sourceSpan) {\n  const args = [literal(slot), variable(viewFnName), literal(decls), literal(vars), literal(tag), literal(constIndex), trackByFn];\n  if (trackByUsesComponentInstance || emptyViewFnName !== null) {\n    args.push(literal(trackByUsesComponentInstance));\n    if (emptyViewFnName !== null) {\n      args.push(variable(emptyViewFnName), literal(emptyDecls), literal(emptyVars));\n      if (emptyTag !== null || emptyConstIndex !== null) {\n        args.push(literal(emptyTag));\n      }\n      if (emptyConstIndex !== null) {\n        args.push(literal(emptyConstIndex));\n      }\n    }\n  }\n  return call(Identifiers.repeaterCreate, args, sourceSpan);\n}\nfunction repeater(collection, sourceSpan) {\n  return call(Identifiers.repeater, [collection], sourceSpan);\n}\nfunction deferWhen(modifier, expr, sourceSpan) {\n  if (modifier === \"prefetch\") {\n    return call(Identifiers.deferPrefetchWhen, [expr], sourceSpan);\n  } else if (modifier === \"hydrate\") {\n    return call(Identifiers.deferHydrateWhen, [expr], sourceSpan);\n  }\n  return call(Identifiers.deferWhen, [expr], sourceSpan);\n}\nfunction declareLet(slot, sourceSpan) {\n  return call(Identifiers.declareLet, [literal(slot)], sourceSpan);\n}\nfunction storeLet(value, sourceSpan) {\n  return importExpr(Identifiers.storeLet).callFn([value], sourceSpan);\n}\nfunction readContextLet(slot) {\n  return importExpr(Identifiers.readContextLet).callFn([literal(slot)]);\n}\nfunction i18n(slot, constIndex, subTemplateIndex, sourceSpan) {\n  const args = [literal(slot), literal(constIndex)];\n  if (subTemplateIndex) {\n    args.push(literal(subTemplateIndex));\n  }\n  return call(Identifiers.i18n, args, sourceSpan);\n}\nfunction i18nEnd(endSourceSpan) {\n  return call(Identifiers.i18nEnd, [], endSourceSpan);\n}\nfunction i18nAttributes(slot, i18nAttributesConfig) {\n  const args = [literal(slot), literal(i18nAttributesConfig)];\n  return call(Identifiers.i18nAttributes, args, null);\n}\nfunction ariaProperty(name, expression, sourceSpan) {\n  return propertyBase(Identifiers.ariaProperty, name, expression, null, sourceSpan);\n}\nfunction property(name, expression, sanitizer, sourceSpan) {\n  return propertyBase(Identifiers.property, name, expression, sanitizer, sourceSpan);\n}\nfunction control(expression, sanitizer, sourceSpan) {\n  const args = [];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(Identifiers.control, args, sourceSpan);\n}\nfunction controlCreate(sourceSpan) {\n  return call(Identifiers.controlCreate, [], sourceSpan);\n}\nfunction twoWayProperty(name, expression, sanitizer, sourceSpan) {\n  const args = [literal(name), expression];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(Identifiers.twoWayProperty, args, sourceSpan);\n}\nfunction attribute(name, expression, sanitizer, namespace, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null || namespace !== null) {\n    args.push(sanitizer ?? literal(null));\n  }\n  if (namespace !== null) {\n    args.push(literal(namespace));\n  }\n  return call(Identifiers.attribute, args, null);\n}\nfunction styleProp(name, expression, unit, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (unit !== null) {\n    args.push(literal(unit));\n  }\n  return call(Identifiers.styleProp, args, sourceSpan);\n}\nfunction classProp(name, expression, sourceSpan) {\n  return call(Identifiers.classProp, [literal(name), expression], sourceSpan);\n}\nfunction styleMap(expression, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  return call(Identifiers.styleMap, [value], sourceSpan);\n}\nfunction classMap(expression, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  return call(Identifiers.classMap, [value], sourceSpan);\n}\nfunction domElement(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElement, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementStart(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementStart, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementEnd(sourceSpan) {\n  return call(Identifiers.domElementEnd, [], sourceSpan);\n}\nfunction domElementContainerStart(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementContainerStart, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementContainer(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementContainer, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementContainerEnd() {\n  return call(Identifiers.domElementContainerEnd, [], null);\n}\nfunction domListener(name, handlerFn, eventTargetResolver, sourceSpan) {\n  const args = [literal(name), handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(importExpr(eventTargetResolver));\n  }\n  return call(Identifiers.domListener, args, sourceSpan);\n}\nfunction domTemplate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  return templateBase(Identifiers.domTemplate, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan);\n}\nconst PIPE_BINDINGS = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];\nfunction pipeBind(slot, varOffset, args) {\n  if (args.length < 1 || args.length > PIPE_BINDINGS.length) {\n    throw new Error(`pipeBind() argument count out of bounds`);\n  }\n  const instruction = PIPE_BINDINGS[args.length - 1];\n  return importExpr(instruction).callFn([literal(slot), literal(varOffset), ...args]);\n}\nfunction pipeBindV(slot, varOffset, args) {\n  return importExpr(Identifiers.pipeBindV).callFn([literal(slot), literal(varOffset), args]);\n}\nfunction textInterpolate(strings, expressions, sourceSpan) {\n  const interpolationArgs = collateInterpolationArgs(strings, expressions);\n  return callVariadicInstruction(TEXT_INTERPOLATE_CONFIG, [], interpolationArgs, [], sourceSpan);\n}\nfunction i18nExp(expr, sourceSpan) {\n  return call(Identifiers.i18nExp, [expr], sourceSpan);\n}\nfunction i18nApply(slot, sourceSpan) {\n  return call(Identifiers.i18nApply, [literal(slot)], sourceSpan);\n}\nfunction domProperty(name, expression, sanitizer, sourceSpan) {\n  return propertyBase(Identifiers.domProperty, name, expression, sanitizer, sourceSpan);\n}\nfunction animation(animationKind, handlerFn, sanitizer, sourceSpan) {\n  const args = [handlerFn];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnter : Identifiers.animationLeave;\n  return call(identifier, args, sourceSpan);\n}\nfunction animationString(animationKind, expression, sanitizer, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  const args = [value];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnter : Identifiers.animationLeave;\n  return call(identifier, args, sourceSpan);\n}\nfunction animationListener(animationKind, handlerFn, eventTargetResolver, sourceSpan) {\n  const args = [handlerFn];\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnterListener : Identifiers.animationLeaveListener;\n  return call(identifier, args, sourceSpan);\n}\nfunction syntheticHostProperty(name, expression, sourceSpan) {\n  return call(Identifiers.syntheticHostProperty, [literal(name), expression], sourceSpan);\n}\nfunction pureFunction(varOffset, fn, args) {\n  return callVariadicInstructionExpr(PURE_FUNCTION_CONFIG, [literal(varOffset), fn], args, [], null);\n}\nfunction attachSourceLocation(templatePath, locations) {\n  return call(Identifiers.attachSourceLocations, [literal(templatePath), locations], null);\n}\nfunction collateInterpolationArgs(strings, expressions) {\n  if (strings.length < 1 || expressions.length !== strings.length - 1) {\n    throw new Error(`AssertionError: expected specific shape of args for strings/expressions in interpolation`);\n  }\n  const interpolationArgs = [];\n  if (expressions.length === 1 && strings[0] === '' && strings[1] === '') {\n    interpolationArgs.push(expressions[0]);\n  } else {\n    let idx;\n    for (idx = 0; idx < expressions.length; idx++) {\n      interpolationArgs.push(literal(strings[idx]), expressions[idx]);\n    }\n    interpolationArgs.push(literal(strings[idx]));\n  }\n  return interpolationArgs;\n}\nfunction interpolationToExpression(interpolation, sourceSpan) {\n  const interpolationArgs = collateInterpolationArgs(interpolation.strings, interpolation.expressions);\n  return callVariadicInstructionExpr(VALUE_INTERPOLATE_CONFIG, [], interpolationArgs, [], sourceSpan);\n}\nfunction call(instruction, args, sourceSpan) {\n  const expr = importExpr(instruction).callFn(args, sourceSpan);\n  return createStatementOp(new ExpressionStatement(expr, sourceSpan));\n}\nfunction conditional(condition, contextValue, sourceSpan) {\n  const args = [condition];\n  if (contextValue !== null) {\n    args.push(contextValue);\n  }\n  return call(Identifiers.conditional, args, sourceSpan);\n}\nconst TEXT_INTERPOLATE_CONFIG = {\n  constant: [Identifiers.textInterpolate, Identifiers.textInterpolate1, Identifiers.textInterpolate2, Identifiers.textInterpolate3, Identifiers.textInterpolate4, Identifiers.textInterpolate5, Identifiers.textInterpolate6, Identifiers.textInterpolate7, Identifiers.textInterpolate8],\n  variable: Identifiers.textInterpolateV,\n  mapping: n => {\n    if (n % 2 === 0) {\n      throw new Error(`Expected odd number of arguments`);\n    }\n    return (n - 1) / 2;\n  }\n};\nconst VALUE_INTERPOLATE_CONFIG = {\n  constant: [Identifiers.interpolate, Identifiers.interpolate1, Identifiers.interpolate2, Identifiers.interpolate3, Identifiers.interpolate4, Identifiers.interpolate5, Identifiers.interpolate6, Identifiers.interpolate7, Identifiers.interpolate8],\n  variable: Identifiers.interpolateV,\n  mapping: n => {\n    if (n % 2 === 0) {\n      throw new Error(`Expected odd number of arguments`);\n    }\n    return (n - 1) / 2;\n  }\n};\nconst PURE_FUNCTION_CONFIG = {\n  constant: [Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4, Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8],\n  variable: Identifiers.pureFunctionV,\n  mapping: n => n\n};\nfunction callVariadicInstructionExpr(config, baseArgs, interpolationArgs, extraArgs, sourceSpan) {\n  const n = config.mapping(interpolationArgs.length);\n  const lastInterpolationArg = interpolationArgs.at(-1);\n  if (extraArgs.length === 0 && interpolationArgs.length > 1 && lastInterpolationArg instanceof LiteralExpr && lastInterpolationArg.value === '') {\n    interpolationArgs.pop();\n  }\n  if (n < config.constant.length) {\n    return importExpr(config.constant[n]).callFn([...baseArgs, ...interpolationArgs, ...extraArgs], sourceSpan);\n  } else if (config.variable !== null) {\n    return importExpr(config.variable).callFn([...baseArgs, literalArr(interpolationArgs), ...extraArgs], sourceSpan);\n  } else {\n    throw new Error(`AssertionError: unable to call variadic function`);\n  }\n}\nfunction callVariadicInstruction(config, baseArgs, interpolationArgs, extraArgs, sourceSpan) {\n  return createStatementOp(callVariadicInstructionExpr(config, baseArgs, interpolationArgs, extraArgs, sourceSpan).toStmt());\n}\nconst GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);\nconst DOM_PROPERTY_REMAPPING = new Map([['class', 'className'], ['for', 'htmlFor'], ['formaction', 'formAction'], ['innerHtml', 'innerHTML'], ['readonly', 'readOnly'], ['tabindex', 'tabIndex']]);\nfunction reify(job) {\n  for (const unit of job.units) {\n    reifyCreateOperations(unit, unit.create);\n    reifyUpdateOperations(unit, unit.update);\n  }\n}\nfunction reifyCreateOperations(unit, ops) {\n  for (const op of ops) {\n    transformExpressionsInOp(op, reifyIrExpression, VisitorContextFlag.None);\n    switch (op.kind) {\n      case OpKind.Text:\n        OpList.replace(op, text(op.handle.slot, op.initialValue, op.sourceSpan));\n        break;\n      case OpKind.ElementStart:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementStart(op.handle.slot, op.tag, op.attributes, op.localRefs, op.startSourceSpan) : elementStart(op.handle.slot, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.Element:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElement(op.handle.slot, op.tag, op.attributes, op.localRefs, op.wholeSourceSpan) : element(op.handle.slot, op.tag, op.attributes, op.localRefs, op.wholeSourceSpan));\n        break;\n      case OpKind.ElementEnd:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementEnd(op.sourceSpan) : elementEnd(op.sourceSpan));\n        break;\n      case OpKind.ContainerStart:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainerStart(op.handle.slot, op.attributes, op.localRefs, op.startSourceSpan) : elementContainerStart(op.handle.slot, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.Container:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainer(op.handle.slot, op.attributes, op.localRefs, op.wholeSourceSpan) : elementContainer(op.handle.slot, op.attributes, op.localRefs, op.wholeSourceSpan));\n        break;\n      case OpKind.ContainerEnd:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainerEnd() : elementContainerEnd());\n        break;\n      case OpKind.I18nStart:\n        OpList.replace(op, i18nStart(op.handle.slot, op.messageIndex, op.subTemplateIndex, op.sourceSpan));\n        break;\n      case OpKind.I18nEnd:\n        OpList.replace(op, i18nEnd(op.sourceSpan));\n        break;\n      case OpKind.I18n:\n        OpList.replace(op, i18n(op.handle.slot, op.messageIndex, op.subTemplateIndex, op.sourceSpan));\n        break;\n      case OpKind.I18nAttributes:\n        if (op.i18nAttributesConfig === null) {\n          throw new Error(`AssertionError: i18nAttributesConfig was not set`);\n        }\n        OpList.replace(op, i18nAttributes(op.handle.slot, op.i18nAttributesConfig));\n        break;\n      case OpKind.Template:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const childView = unit.job.views.get(op.xref);\n        OpList.replace(op, op.templateKind === TemplateKind.Block || unit.job.mode === TemplateCompilationMode.DomOnly ? domTemplate(op.handle.slot, variable(childView.fnName), childView.decls, childView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan) : template(op.handle.slot, variable(childView.fnName), childView.decls, childView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.DisableBindings:\n        OpList.replace(op, disableBindings());\n        break;\n      case OpKind.EnableBindings:\n        OpList.replace(op, enableBindings());\n        break;\n      case OpKind.Pipe:\n        OpList.replace(op, pipe(op.handle.slot, op.name));\n        break;\n      case OpKind.DeclareLet:\n        OpList.replace(op, declareLet(op.handle.slot, op.sourceSpan));\n        break;\n      case OpKind.AnimationString:\n        OpList.replace(op, animationString(op.animationKind, op.expression, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.Animation:\n        const animationCallbackFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, false);\n        OpList.replace(op, animation(op.animationKind, animationCallbackFn, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.AnimationListener:\n        const animationListenerFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, op.consumesDollarEvent);\n        OpList.replace(op, animationListener(op.animationKind, animationListenerFn, null, op.sourceSpan));\n        break;\n      case OpKind.Listener:\n        const listenerFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, op.consumesDollarEvent);\n        const eventTargetResolver = op.eventTarget ? GLOBAL_TARGET_RESOLVERS.get(op.eventTarget) : null;\n        if (eventTargetResolver === undefined) {\n          throw new Error(`Unexpected global target '${op.eventTarget}' defined for '${op.name}' event. Supported list of global targets: window,document,body.`);\n        }\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly && !op.hostListener && !op.isLegacyAnimationListener ? domListener(op.name, listenerFn, eventTargetResolver, op.sourceSpan) : listener(op.name, listenerFn, eventTargetResolver, op.hostListener && op.isLegacyAnimationListener, op.sourceSpan));\n        break;\n      case OpKind.TwoWayListener:\n        OpList.replace(op, twoWayListener(op.name, reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, true), op.sourceSpan));\n        break;\n      case OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        OpList.replace(op, createStatementOp(new DeclareVarStmt(op.variable.name, op.initializer, undefined, StmtModifier.Final)));\n        break;\n      case OpKind.Namespace:\n        switch (op.active) {\n          case Namespace.HTML:\n            OpList.replace(op, namespaceHTML());\n            break;\n          case Namespace.SVG:\n            OpList.replace(op, namespaceSVG());\n            break;\n          case Namespace.Math:\n            OpList.replace(op, namespaceMath());\n            break;\n        }\n        break;\n      case OpKind.Defer:\n        const timerScheduling = !!op.loadingMinimumTime || !!op.loadingAfterTime || !!op.placeholderMinimumTime;\n        OpList.replace(op, defer(op.handle.slot, op.mainSlot.slot, op.resolverFn, op.loadingSlot?.slot ?? null, op.placeholderSlot?.slot ?? null, op.errorSlot?.slot ?? null, op.loadingConfig, op.placeholderConfig, timerScheduling, op.sourceSpan, op.flags));\n        break;\n      case OpKind.DeferOn:\n        let args = [];\n        switch (op.trigger.kind) {\n          case DeferTriggerKind.Never:\n          case DeferTriggerKind.Idle:\n          case DeferTriggerKind.Immediate:\n            break;\n          case DeferTriggerKind.Timer:\n            args = [literal(op.trigger.delay)];\n            break;\n          case DeferTriggerKind.Viewport:\n            if (op.modifier === \"hydrate\") {\n              args = op.trigger.options ? [op.trigger.options] : [];\n            } else {\n              args = [literal(op.trigger.targetSlot?.slot ?? null)];\n              if (op.trigger.targetSlotViewSteps !== 0) {\n                args.push(literal(op.trigger.targetSlotViewSteps));\n              } else if (op.trigger.options) {\n                args.push(literal(null));\n              }\n              if (op.trigger.options) {\n                args.push(op.trigger.options);\n              }\n            }\n            break;\n          case DeferTriggerKind.Interaction:\n          case DeferTriggerKind.Hover:\n            if (op.modifier === \"hydrate\") {\n              args = [];\n            } else {\n              args = [literal(op.trigger.targetSlot?.slot ?? null)];\n              if (op.trigger.targetSlotViewSteps !== 0) {\n                args.push(literal(op.trigger.targetSlotViewSteps));\n              }\n            }\n            break;\n          default:\n            throw new Error(`AssertionError: Unsupported reification of defer trigger kind ${op.trigger.kind}`);\n        }\n        OpList.replace(op, deferOn(op.trigger.kind, args, op.modifier, op.sourceSpan));\n        break;\n      case OpKind.ProjectionDef:\n        OpList.replace(op, projectionDef(op.def));\n        break;\n      case OpKind.Projection:\n        if (op.handle.slot === null) {\n          throw new Error('No slot was assigned for project instruction');\n        }\n        let fallbackViewFnName = null;\n        let fallbackDecls = null;\n        let fallbackVars = null;\n        if (op.fallbackView !== null) {\n          if (!(unit instanceof ViewCompilationUnit)) {\n            throw new Error(`AssertionError: must be compiling a component`);\n          }\n          const fallbackView = unit.job.views.get(op.fallbackView);\n          if (fallbackView === undefined) {\n            throw new Error('AssertionError: projection had fallback view xref, but fallback view was not found');\n          }\n          if (fallbackView.fnName === null || fallbackView.decls === null || fallbackView.vars === null) {\n            throw new Error(`AssertionError: expected projection fallback view to have been named and counted`);\n          }\n          fallbackViewFnName = fallbackView.fnName;\n          fallbackDecls = fallbackView.decls;\n          fallbackVars = fallbackView.vars;\n        }\n        OpList.replace(op, projection(op.handle.slot, op.projectionSlotIndex, op.attributes, fallbackViewFnName, fallbackDecls, fallbackVars, op.sourceSpan));\n        break;\n      case OpKind.ConditionalCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const conditionalCreateChildView = unit.job.views.get(op.xref);\n        OpList.replace(op, conditionalCreate(op.handle.slot, variable(conditionalCreateChildView.fnName), conditionalCreateChildView.decls, conditionalCreateChildView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.ConditionalBranchCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const conditionalBranchCreateChildView = unit.job.views.get(op.xref);\n        OpList.replace(op, conditionalBranchCreate(op.handle.slot, variable(conditionalBranchCreateChildView.fnName), conditionalBranchCreateChildView.decls, conditionalBranchCreateChildView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.handle.slot === null) {\n          throw new Error('No slot was assigned for repeater instruction');\n        }\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        const repeaterView = unit.job.views.get(op.xref);\n        if (repeaterView.fnName === null) {\n          throw new Error(`AssertionError: expected repeater primary view to have been named`);\n        }\n        let emptyViewFnName = null;\n        let emptyDecls = null;\n        let emptyVars = null;\n        if (op.emptyView !== null) {\n          const emptyView = unit.job.views.get(op.emptyView);\n          if (emptyView === undefined) {\n            throw new Error('AssertionError: repeater had empty view xref, but empty view was not found');\n          }\n          if (emptyView.fnName === null || emptyView.decls === null || emptyView.vars === null) {\n            throw new Error(`AssertionError: expected repeater empty view to have been named and counted`);\n          }\n          emptyViewFnName = emptyView.fnName;\n          emptyDecls = emptyView.decls;\n          emptyVars = emptyView.vars;\n        }\n        OpList.replace(op, repeaterCreate(op.handle.slot, repeaterView.fnName, op.decls, op.vars, op.tag, op.attributes, reifyTrackBy(unit, op), op.usesComponentInstance, emptyViewFnName, emptyDecls, emptyVars, op.emptyTag, op.emptyAttributes, op.wholeSourceSpan));\n        break;\n      case OpKind.SourceLocation:\n        const locationsLiteral = literalArr(op.locations.map(({\n          targetSlot,\n          offset,\n          line,\n          column\n        }) => {\n          if (targetSlot.slot === null) {\n            throw new Error('No slot was assigned for source location');\n          }\n          return literalArr([literal(targetSlot.slot), literal(offset), literal(line), literal(column)]);\n        }));\n        OpList.replace(op, attachSourceLocation(op.templatePath, locationsLiteral));\n        break;\n      case OpKind.ControlCreate:\n        OpList.replace(op, controlCreate(op.sourceSpan));\n        break;\n      case OpKind.Statement:\n        break;\n      default:\n        throw new Error(`AssertionError: Unsupported reification of create op ${OpKind[op.kind]}`);\n    }\n  }\n}\nfunction reifyUpdateOperations(unit, ops) {\n  for (const op of ops) {\n    transformExpressionsInOp(op, reifyIrExpression, VisitorContextFlag.None);\n    switch (op.kind) {\n      case OpKind.Advance:\n        OpList.replace(op, advance(op.delta, op.sourceSpan));\n        break;\n      case OpKind.Property:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly && op.bindingKind !== BindingKind.LegacyAnimation && op.bindingKind !== BindingKind.Animation ? reifyDomProperty(op) : reifyProperty(op));\n        break;\n      case OpKind.Control:\n        OpList.replace(op, reifyControl(op));\n        break;\n      case OpKind.TwoWayProperty:\n        OpList.replace(op, twoWayProperty(op.name, op.expression, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.StyleProp:\n        OpList.replace(op, styleProp(op.name, op.expression, op.unit, op.sourceSpan));\n        break;\n      case OpKind.ClassProp:\n        OpList.replace(op, classProp(op.name, op.expression, op.sourceSpan));\n        break;\n      case OpKind.StyleMap:\n        OpList.replace(op, styleMap(op.expression, op.sourceSpan));\n        break;\n      case OpKind.ClassMap:\n        OpList.replace(op, classMap(op.expression, op.sourceSpan));\n        break;\n      case OpKind.I18nExpression:\n        OpList.replace(op, i18nExp(op.expression, op.sourceSpan));\n        break;\n      case OpKind.I18nApply:\n        OpList.replace(op, i18nApply(op.handle.slot, op.sourceSpan));\n        break;\n      case OpKind.InterpolateText:\n        OpList.replace(op, textInterpolate(op.interpolation.strings, op.interpolation.expressions, op.sourceSpan));\n        break;\n      case OpKind.Attribute:\n        OpList.replace(op, attribute(op.name, op.expression, op.sanitizer, op.namespace, op.sourceSpan));\n        break;\n      case OpKind.DomProperty:\n        if (op.expression instanceof Interpolation) {\n          throw new Error('not yet handled');\n        } else {\n          if (op.bindingKind === BindingKind.LegacyAnimation || op.bindingKind === BindingKind.Animation) {\n            OpList.replace(op, syntheticHostProperty(op.name, op.expression, op.sourceSpan));\n          } else {\n            OpList.replace(op, reifyDomProperty(op));\n          }\n        }\n        break;\n      case OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        OpList.replace(op, createStatementOp(new DeclareVarStmt(op.variable.name, op.initializer, undefined, StmtModifier.Final)));\n        break;\n      case OpKind.Conditional:\n        if (op.processed === null) {\n          throw new Error(`Conditional test was not set.`);\n        }\n        OpList.replace(op, conditional(op.processed, op.contextValue, op.sourceSpan));\n        break;\n      case OpKind.Repeater:\n        OpList.replace(op, repeater(op.collection, op.sourceSpan));\n        break;\n      case OpKind.DeferWhen:\n        OpList.replace(op, deferWhen(op.modifier, op.expr, op.sourceSpan));\n        break;\n      case OpKind.StoreLet:\n        throw new Error(`AssertionError: unexpected storeLet ${op.declaredName}`);\n      case OpKind.Statement:\n        break;\n      default:\n        throw new Error(`AssertionError: Unsupported reification of update op ${OpKind[op.kind]}`);\n    }\n  }\n}\nfunction reifyDomProperty(op) {\n  return domProperty(DOM_PROPERTY_REMAPPING.get(op.name) ?? op.name, op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyProperty(op) {\n  return isAriaAttribute(op.name) ? ariaProperty(op.name, op.expression, op.sourceSpan) : property(op.name, op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyControl(op) {\n  return control(op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyIrExpression(expr) {\n  if (!isIrExpression(expr)) {\n    return expr;\n  }\n  switch (expr.kind) {\n    case ExpressionKind.NextContext:\n      return nextContext(expr.steps);\n    case ExpressionKind.Reference:\n      return reference(expr.targetSlot.slot + 1 + expr.offset);\n    case ExpressionKind.LexicalRead:\n      throw new Error(`AssertionError: unresolved LexicalRead of ${expr.name}`);\n    case ExpressionKind.TwoWayBindingSet:\n      throw new Error(`AssertionError: unresolved TwoWayBindingSet`);\n    case ExpressionKind.RestoreView:\n      if (typeof expr.view === 'number') {\n        throw new Error(`AssertionError: unresolved RestoreView`);\n      }\n      return restoreView(expr.view);\n    case ExpressionKind.ResetView:\n      return resetView(expr.expr);\n    case ExpressionKind.GetCurrentView:\n      return getCurrentView();\n    case ExpressionKind.ReadVariable:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed variable ${expr.xref}`);\n      }\n      return variable(expr.name);\n    case ExpressionKind.ReadTemporaryExpr:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed temporary ${expr.xref}`);\n      }\n      return variable(expr.name);\n    case ExpressionKind.AssignTemporaryExpr:\n      if (expr.name === null) {\n        throw new Error(`Assign of unnamed temporary ${expr.xref}`);\n      }\n      return variable(expr.name).set(expr.expr);\n    case ExpressionKind.PureFunctionExpr:\n      if (expr.fn === null) {\n        throw new Error(`AssertionError: expected PureFunctions to have been extracted`);\n      }\n      return pureFunction(expr.varOffset, expr.fn, expr.args);\n    case ExpressionKind.PureFunctionParameterExpr:\n      throw new Error(`AssertionError: expected PureFunctionParameterExpr to have been extracted`);\n    case ExpressionKind.PipeBinding:\n      return pipeBind(expr.targetSlot.slot, expr.varOffset, expr.args);\n    case ExpressionKind.PipeBindingVariadic:\n      return pipeBindV(expr.targetSlot.slot, expr.varOffset, expr.args);\n    case ExpressionKind.SlotLiteralExpr:\n      return literal(expr.slot.slot);\n    case ExpressionKind.ContextLetReference:\n      return readContextLet(expr.targetSlot.slot);\n    case ExpressionKind.StoreLet:\n      return storeLet(expr.value, expr.sourceSpan);\n    case ExpressionKind.TrackContext:\n      return variable('this');\n    default:\n      throw new Error(`AssertionError: Unsupported reification of ir.Expression kind: ${ExpressionKind[expr.kind]}`);\n  }\n}\nfunction reifyListenerHandler(unit, name, handlerOps, consumesDollarEvent) {\n  reifyUpdateOperations(unit, handlerOps);\n  const handlerStmts = [];\n  for (const op of handlerOps) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected reified statements, but found op ${OpKind[op.kind]}`);\n    }\n    handlerStmts.push(op.statement);\n  }\n  const params = [];\n  if (consumesDollarEvent) {\n    params.push(new FnParam('$event'));\n  }\n  return fn(params, handlerStmts, undefined, undefined, name);\n}\nfunction reifyTrackBy(unit, op) {\n  if (op.trackByFn !== null) {\n    return op.trackByFn;\n  }\n  const params = [new FnParam('$index'), new FnParam('$item')];\n  let fn$1;\n  if (op.trackByOps === null) {\n    fn$1 = op.usesComponentInstance ? fn(params, [new ReturnStatement(op.track)]) : arrowFn(params, op.track);\n  } else {\n    reifyUpdateOperations(unit, op.trackByOps);\n    const statements = [];\n    for (const trackOp of op.trackByOps) {\n      if (trackOp.kind !== OpKind.Statement) {\n        throw new Error(`AssertionError: expected reified statements, but found op ${OpKind[trackOp.kind]}`);\n      }\n      statements.push(trackOp.statement);\n    }\n    fn$1 = op.usesComponentInstance || statements.length !== 1 || !(statements[0] instanceof ReturnStatement) ? fn(params, statements) : arrowFn(params, statements[0].value);\n  }\n  op.trackByFn = unit.job.pool.getSharedFunctionReference(fn$1, '_forTrack');\n  return op.trackByFn;\n}\nfunction removeEmptyBindings(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Attribute:\n        case OpKind.Binding:\n        case OpKind.ClassProp:\n        case OpKind.ClassMap:\n        case OpKind.Property:\n        case OpKind.StyleProp:\n        case OpKind.StyleMap:\n          if (op.expression instanceof EmptyExpr) {\n            OpList.remove(op);\n          }\n          break;\n      }\n    }\n  }\n}\nfunction removeI18nContexts(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          OpList.remove(op);\n          break;\n        case OpKind.I18nStart:\n          op.context = null;\n          break;\n      }\n    }\n  }\n}\nfunction removeIllegalLetReferences(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.Variable || op.variable.kind !== SemanticVariableKind.Identifier || !(op.initializer instanceof StoreLetExpr)) {\n        continue;\n      }\n      const name = op.variable.identifier;\n      let current = op;\n      while (current && current.kind !== OpKind.ListEnd) {\n        transformExpressionsInOp(current, expr => expr instanceof LexicalReadExpr && expr.name === name ? literal(undefined) : expr, VisitorContextFlag.None);\n        current = current.prev;\n      }\n    }\n  }\n}\nfunction removeUnusedI18nAttributesOps(job) {\n  for (const unit of job.units) {\n    const ownersWithI18nExpressions = new Set();\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.I18nExpression:\n          ownersWithI18nExpressions.add(op.i18nOwner);\n      }\n    }\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nAttributes:\n          if (ownersWithI18nExpressions.has(op.xref)) {\n            continue;\n          }\n          OpList.remove(op);\n      }\n    }\n  }\n}\nfunction resolveContexts(job) {\n  for (const unit of job.units) {\n    processLexicalScope$1(unit, unit.create);\n    processLexicalScope$1(unit, unit.update);\n  }\n}\nfunction processLexicalScope$1(view, ops) {\n  const scope = new Map();\n  scope.set(view.xref, variable('ctx'));\n  for (const op of ops) {\n    switch (op.kind) {\n      case OpKind.Variable:\n        switch (op.variable.kind) {\n          case SemanticVariableKind.Context:\n            scope.set(op.variable.view, new ReadVariableExpr(op.xref));\n            break;\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        processLexicalScope$1(view, op.handlerOps);\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope$1(view, op.trackByOps);\n        }\n        break;\n    }\n  }\n  if (view === view.job.root) {\n    scope.set(view.xref, variable('ctx'));\n  }\n  for (const op of ops) {\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof ContextExpr) {\n        if (!scope.has(expr.view)) {\n          throw new Error(`No context found for reference to view ${expr.view} from view ${view.xref}`);\n        }\n        return scope.get(expr.view);\n      } else {\n        return expr;\n      }\n    }, VisitorContextFlag.None);\n  }\n}\nfunction resolveDeferDepsFns(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Defer) {\n        if (op.resolverFn !== null) {\n          continue;\n        }\n        if (op.ownResolverFn !== null) {\n          if (op.handle.slot === null) {\n            throw new Error('AssertionError: slot must be assigned before extracting defer deps functions');\n          }\n          const fullPathName = unit.fnName?.replace('_Template', '');\n          op.resolverFn = job.pool.getSharedFunctionReference(op.ownResolverFn, `${fullPathName}_Defer_${op.handle.slot}_DepsFn`, false);\n        }\n      }\n    }\n  }\n}\nfunction resolveDollarEvent(job) {\n  for (const unit of job.units) {\n    transformDollarEvent(unit.create);\n    transformDollarEvent(unit.update);\n  }\n}\nfunction transformDollarEvent(ops) {\n  for (const op of ops) {\n    if (op.kind === OpKind.Listener || op.kind === OpKind.TwoWayListener || op.kind === OpKind.AnimationListener) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof LexicalReadExpr && expr.name === '$event') {\n          if (op.kind === OpKind.Listener || op.kind === OpKind.AnimationListener) {\n            op.consumesDollarEvent = true;\n          }\n          return new ReadVarExpr(expr.name);\n        }\n        return expr;\n      }, VisitorContextFlag.InChildOperation);\n    }\n  }\n}\nfunction resolveI18nElementPlaceholders(job) {\n  const i18nContexts = new Map();\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.ElementStart:\n          elements.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  resolvePlaceholdersForView(job, job.root, i18nContexts, elements);\n}\nfunction resolvePlaceholdersForView(job, unit, i18nContexts, elements, pendingStructuralDirective) {\n  let currentOps = null;\n  let pendingStructuralDirectiveCloses = new Map();\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case OpKind.I18nStart:\n        if (!op.context) {\n          throw Error('Could not find i18n context for i18n op');\n        }\n        currentOps = {\n          i18nBlock: op,\n          i18nContext: i18nContexts.get(op.context)\n        };\n        break;\n      case OpKind.I18nEnd:\n        currentOps = null;\n        break;\n      case OpKind.ElementStart:\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          if (pendingStructuralDirective && op.i18nPlaceholder.closeName) {\n            pendingStructuralDirectiveCloses.set(op.xref, pendingStructuralDirective);\n          }\n          pendingStructuralDirective = undefined;\n        }\n        break;\n      case OpKind.ElementEnd:\n        const startOp = elements.get(op.xref);\n        if (startOp && startOp.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('AssertionError: i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementClose(startOp, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirectiveCloses.get(op.xref));\n          pendingStructuralDirectiveCloses.delete(op.xref);\n        }\n        break;\n      case OpKind.Projection:\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          recordElementClose(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          pendingStructuralDirective = undefined;\n        }\n        if (op.fallbackView !== null) {\n          const view = job.views.get(op.fallbackView);\n          if (op.fallbackViewI18nPlaceholder === undefined) {\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(job, view, op.handle.slot, op.fallbackViewI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(job, view, op.handle.slot, op.fallbackViewI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        const view = job.views.get(op.xref);\n        if (op.i18nPlaceholder === undefined) {\n          resolvePlaceholdersForView(job, view, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          if (op.templateKind === TemplateKind.Structural) {\n            resolvePlaceholdersForView(job, view, i18nContexts, elements, op);\n          } else {\n            recordTemplateStart(job, view, op.handle.slot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(job, view, op.handle.slot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n      case OpKind.RepeaterCreate:\n        if (pendingStructuralDirective !== undefined) {\n          throw Error('AssertionError: Unexpected structural directive associated with @for block');\n        }\n        const forSlot = op.handle.slot + 1;\n        const forView = job.views.get(op.xref);\n        if (op.i18nPlaceholder === undefined) {\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordTemplateStart(job, forView, forSlot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n          recordTemplateClose(job, forView, forSlot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          pendingStructuralDirective = undefined;\n        }\n        if (op.emptyView !== null) {\n          const emptySlot = op.handle.slot + 2;\n          const emptyView = job.views.get(op.emptyView);\n          if (op.emptyI18nPlaceholder === undefined) {\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(job, emptyView, emptySlot, op.emptyI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n            recordTemplateClose(job, emptyView, emptySlot, op.emptyI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n    }\n  }\n}\nfunction recordElementStart(op, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    startName,\n    closeName\n  } = op.i18nPlaceholder;\n  let flags = I18nParamValueFlags.ElementTag | I18nParamValueFlags.OpenTag;\n  let value = op.handle.slot;\n  if (structuralDirective !== undefined) {\n    flags |= I18nParamValueFlags.TemplateTag;\n    value = {\n      element: value,\n      template: structuralDirective.handle.slot\n    };\n  }\n  if (!closeName) {\n    flags |= I18nParamValueFlags.CloseTag;\n  }\n  addParam(i18nContext.params, startName, value, i18nBlock.subTemplateIndex, flags);\n}\nfunction recordElementClose(op, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    closeName\n  } = op.i18nPlaceholder;\n  if (closeName) {\n    let flags = I18nParamValueFlags.ElementTag | I18nParamValueFlags.CloseTag;\n    let value = op.handle.slot;\n    if (structuralDirective !== undefined) {\n      flags |= I18nParamValueFlags.TemplateTag;\n      value = {\n        element: value,\n        template: structuralDirective.handle.slot\n      };\n    }\n    addParam(i18nContext.params, closeName, value, i18nBlock.subTemplateIndex, flags);\n  }\n}\nfunction recordTemplateStart(job, view, slot, i18nPlaceholder, i18nContext, i18nBlock, structuralDirective) {\n  let {\n    startName,\n    closeName\n  } = i18nPlaceholder;\n  let flags = I18nParamValueFlags.TemplateTag | I18nParamValueFlags.OpenTag;\n  if (!closeName) {\n    flags |= I18nParamValueFlags.CloseTag;\n  }\n  if (structuralDirective !== undefined) {\n    addParam(i18nContext.params, startName, structuralDirective.handle.slot, i18nBlock.subTemplateIndex, flags);\n  }\n  addParam(i18nContext.params, startName, slot, getSubTemplateIndexForTemplateTag(job, i18nBlock, view), flags);\n}\nfunction recordTemplateClose(job, view, slot, i18nPlaceholder, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    closeName\n  } = i18nPlaceholder;\n  const flags = I18nParamValueFlags.TemplateTag | I18nParamValueFlags.CloseTag;\n  if (closeName) {\n    addParam(i18nContext.params, closeName, slot, getSubTemplateIndexForTemplateTag(job, i18nBlock, view), flags);\n    if (structuralDirective !== undefined) {\n      addParam(i18nContext.params, closeName, structuralDirective.handle.slot, i18nBlock.subTemplateIndex, flags);\n    }\n  }\n}\nfunction getSubTemplateIndexForTemplateTag(job, i18nOp, view) {\n  for (const childOp of view.create) {\n    if (childOp.kind === OpKind.I18nStart) {\n      return childOp.subTemplateIndex;\n    }\n  }\n  return i18nOp.subTemplateIndex;\n}\nfunction addParam(params, placeholder, value, subTemplateIndex, flags) {\n  const values = params.get(placeholder) ?? [];\n  values.push({\n    value,\n    subTemplateIndex,\n    flags\n  });\n  params.set(placeholder, values);\n}\nfunction resolveI18nExpressionPlaceholders(job) {\n  const subTemplateIndices = new Map();\n  const i18nContexts = new Map();\n  const icuPlaceholders = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          subTemplateIndices.set(op.xref, op.subTemplateIndex);\n          break;\n        case OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.IcuPlaceholder:\n          icuPlaceholders.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  const expressionIndices = new Map();\n  const referenceIndex = op => op.usage === I18nExpressionFor.I18nText ? op.i18nOwner : op.context;\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind === OpKind.I18nExpression) {\n        const index = expressionIndices.get(referenceIndex(op)) || 0;\n        const subTemplateIndex = subTemplateIndices.get(op.i18nOwner) ?? null;\n        const value = {\n          value: index,\n          subTemplateIndex: subTemplateIndex,\n          flags: I18nParamValueFlags.ExpressionIndex\n        };\n        updatePlaceholder(op, value, i18nContexts, icuPlaceholders);\n        expressionIndices.set(referenceIndex(op), index + 1);\n      }\n    }\n  }\n}\nfunction updatePlaceholder(op, value, i18nContexts, icuPlaceholders) {\n  if (op.i18nPlaceholder !== null) {\n    const i18nContext = i18nContexts.get(op.context);\n    const params = op.resolutionTime === I18nParamResolutionTime.Creation ? i18nContext.params : i18nContext.postprocessingParams;\n    const values = params.get(op.i18nPlaceholder) || [];\n    values.push(value);\n    params.set(op.i18nPlaceholder, values);\n  }\n  if (op.icuPlaceholder !== null) {\n    const icuPlaceholderOp = icuPlaceholders.get(op.icuPlaceholder);\n    icuPlaceholderOp?.expressionPlaceholders.push(value);\n  }\n}\nfunction resolveNames(job) {\n  for (const unit of job.units) {\n    processLexicalScope(unit, unit.create, null);\n    processLexicalScope(unit, unit.update, null);\n  }\n}\nfunction processLexicalScope(unit, ops, savedView) {\n  const scope = new Map();\n  const localDefinitions = new Map();\n  for (const op of ops) {\n    switch (op.kind) {\n      case OpKind.Variable:\n        switch (op.variable.kind) {\n          case SemanticVariableKind.Identifier:\n            if (op.variable.local) {\n              if (localDefinitions.has(op.variable.identifier)) {\n                continue;\n              }\n              localDefinitions.set(op.variable.identifier, op.xref);\n            } else if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case SemanticVariableKind.Alias:\n            if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case SemanticVariableKind.SavedView:\n            savedView = {\n              view: op.variable.view,\n              variable: op.xref\n            };\n            break;\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        processLexicalScope(unit, op.handlerOps, savedView);\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope(unit, op.trackByOps, savedView);\n        }\n        break;\n    }\n  }\n  for (const op of ops) {\n    if (op.kind == OpKind.Listener || op.kind === OpKind.TwoWayListener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener) {\n      continue;\n    }\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof LexicalReadExpr) {\n        if (localDefinitions.has(expr.name)) {\n          return new ReadVariableExpr(localDefinitions.get(expr.name));\n        } else if (scope.has(expr.name)) {\n          return new ReadVariableExpr(scope.get(expr.name));\n        } else {\n          return new ReadPropExpr(new ContextExpr(unit.job.root.xref), expr.name);\n        }\n      } else if (expr instanceof RestoreViewExpr && typeof expr.view === 'number') {\n        if (savedView === null || savedView.view !== expr.view) {\n          throw new Error(`AssertionError: no saved view ${expr.view} from view ${unit.xref}`);\n        }\n        expr.view = new ReadVariableExpr(savedView.variable);\n        return expr;\n      } else {\n        return expr;\n      }\n    }, VisitorContextFlag.None);\n  }\n  for (const op of ops) {\n    visitExpressionsInOp(op, expr => {\n      if (expr instanceof LexicalReadExpr) {\n        throw new Error(`AssertionError: no lexical reads should remain, but found read of ${expr.name}`);\n      }\n    });\n  }\n}\nconst sanitizerFns = new Map([[SecurityContext.HTML, Identifiers.sanitizeHtml], [SecurityContext.RESOURCE_URL, Identifiers.sanitizeResourceUrl], [SecurityContext.SCRIPT, Identifiers.sanitizeScript], [SecurityContext.STYLE, Identifiers.sanitizeStyle], [SecurityContext.URL, Identifiers.sanitizeUrl], [SecurityContext.ATTRIBUTE_NO_BINDING, Identifiers.validateAttribute]]);\nconst trustedValueFns = new Map([[SecurityContext.HTML, Identifiers.trustConstantHtml], [SecurityContext.RESOURCE_URL, Identifiers.trustConstantResourceUrl]]);\nfunction resolveSanitizers(job) {\n  for (const unit of job.units) {\n    if (job.kind !== CompilationJobKind.Host) {\n      for (const op of unit.create) {\n        if (op.kind === OpKind.ExtractedAttribute) {\n          const trustedValueFn = trustedValueFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          op.trustedValueFn = trustedValueFn !== null ? importExpr(trustedValueFn) : null;\n        }\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Property:\n        case OpKind.Attribute:\n        case OpKind.DomProperty:\n          let sanitizerFn = null;\n          if (Array.isArray(op.securityContext) && op.securityContext.length === 2 && op.securityContext.includes(SecurityContext.URL) && op.securityContext.includes(SecurityContext.RESOURCE_URL)) {\n            sanitizerFn = Identifiers.sanitizeUrlOrResourceUrl;\n          } else {\n            sanitizerFn = sanitizerFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          }\n          op.sanitizer = sanitizerFn !== null ? importExpr(sanitizerFn) : null;\n          break;\n      }\n    }\n  }\n}\nfunction getOnlySecurityContext(securityContext) {\n  if (Array.isArray(securityContext)) {\n    if (securityContext.length > 1) {\n      throw Error(`AssertionError: Ambiguous security context`);\n    }\n    return securityContext[0] || SecurityContext.NONE;\n  }\n  return securityContext;\n}\nfunction saveAndRestoreView(job) {\n  for (const unit of job.units) {\n    unit.create.prepend([createVariableOp(unit.job.allocateXrefId(), {\n      kind: SemanticVariableKind.SavedView,\n      name: null,\n      view: unit.xref\n    }, new GetCurrentViewExpr(), VariableFlags.None)]);\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.Listener && op.kind !== OpKind.TwoWayListener && op.kind !== OpKind.Animation && op.kind !== OpKind.AnimationListener) {\n        continue;\n      }\n      let needsRestoreView = unit !== job.root;\n      if (!needsRestoreView) {\n        for (const handlerOp of op.handlerOps) {\n          visitExpressionsInOp(handlerOp, expr => {\n            if (expr instanceof ReferenceExpr || expr instanceof ContextLetReferenceExpr) {\n              needsRestoreView = true;\n            }\n          });\n        }\n      }\n      if (needsRestoreView) {\n        addSaveRestoreViewOperationToListener(unit, op);\n      }\n    }\n  }\n}\nfunction addSaveRestoreViewOperationToListener(unit, op) {\n  op.handlerOps.prepend([createVariableOp(unit.job.allocateXrefId(), {\n    kind: SemanticVariableKind.Context,\n    name: null,\n    view: unit.xref\n  }, new RestoreViewExpr(unit.xref), VariableFlags.None)]);\n  for (const handlerOp of op.handlerOps) {\n    if (handlerOp.kind === OpKind.Statement && handlerOp.statement instanceof ReturnStatement) {\n      handlerOp.statement.value = new ResetViewExpr(handlerOp.statement.value);\n    }\n  }\n}\nfunction allocateSlots(job) {\n  const slotMap = new Map();\n  for (const unit of job.units) {\n    let slotCount = 0;\n    for (const op of unit.create) {\n      if (!hasConsumesSlotTrait(op)) {\n        continue;\n      }\n      op.handle.slot = slotCount;\n      slotMap.set(op.xref, op.handle.slot);\n      slotCount += op.numSlotsUsed;\n    }\n    unit.decls = slotCount;\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.Template || op.kind === OpKind.ConditionalCreate || op.kind === OpKind.ConditionalBranchCreate || op.kind === OpKind.RepeaterCreate) {\n        const childView = job.views.get(op.xref);\n        op.decls = childView.decls;\n      }\n    }\n  }\n}\nfunction optimizeStoreLet(job) {\n  const letUsedExternally = new Set();\n  const declareLetOps = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.DeclareLet) {\n        declareLetOps.set(op.xref, op);\n      }\n      visitExpressionsInOp(op, expr => {\n        if (expr instanceof ContextLetReferenceExpr) {\n          letUsedExternally.add(expr.target);\n        }\n      });\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof StoreLetExpr && !letUsedExternally.has(expr.target)) {\n          if (!hasPipe(expr)) {\n            OpList.remove(declareLetOps.get(expr.target));\n          }\n          return expr.value;\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction hasPipe(root) {\n  let result = false;\n  transformExpressionsInExpression(root, expr => {\n    if (expr instanceof PipeBindingExpr || expr instanceof PipeBindingVariadicExpr) {\n      result = true;\n    }\n    return expr;\n  }, VisitorContextFlag.None);\n  return result;\n}\nfunction stripNonrequiredParentheses(job) {\n  const requiredParens = new Set();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (expr instanceof BinaryOperatorExpr) {\n          switch (expr.operator) {\n            case BinaryOperator.Exponentiation:\n              checkExponentiationParens(expr, requiredParens);\n              break;\n            case BinaryOperator.NullishCoalesce:\n              checkNullishCoalescingParens(expr, requiredParens);\n              break;\n            case BinaryOperator.And:\n            case BinaryOperator.Or:\n              checkAndOrParens(expr, requiredParens);\n          }\n        }\n      });\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof ParenthesizedExpr) {\n          return requiredParens.has(expr) ? expr : expr.expr;\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction checkExponentiationParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && expr.lhs.expr instanceof UnaryOperatorExpr) {\n    requiredParens.add(expr.lhs);\n  }\n}\nfunction checkNullishCoalescingParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && (isLogicalAndOr(expr.lhs.expr) || expr.lhs.expr instanceof ConditionalExpr)) {\n    requiredParens.add(expr.lhs);\n  }\n  if (expr.rhs instanceof ParenthesizedExpr && (isLogicalAndOr(expr.rhs.expr) || expr.rhs.expr instanceof ConditionalExpr)) {\n    requiredParens.add(expr.rhs);\n  }\n}\nfunction checkAndOrParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && expr.lhs.expr instanceof BinaryOperatorExpr && expr.lhs.expr.operator === BinaryOperator.NullishCoalesce) {\n    requiredParens.add(expr.lhs);\n  }\n}\nfunction isLogicalAndOr(expr) {\n  return expr instanceof BinaryOperatorExpr && (expr.operator === BinaryOperator.And || expr.operator === BinaryOperator.Or);\n}\nfunction specializeStyleBindings(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.Binding) {\n        continue;\n      }\n      switch (op.bindingKind) {\n        case BindingKind.ClassName:\n          if (op.expression instanceof Interpolation) {\n            throw new Error(`Unexpected interpolation in ClassName binding`);\n          }\n          OpList.replace(op, createClassPropOp(op.target, op.name, op.expression, op.sourceSpan));\n          break;\n        case BindingKind.StyleProperty:\n          OpList.replace(op, createStylePropOp(op.target, op.name, op.expression, op.unit, op.sourceSpan));\n          break;\n        case BindingKind.Property:\n        case BindingKind.Template:\n          if (op.name === 'style') {\n            OpList.replace(op, createStyleMapOp(op.target, op.expression, op.sourceSpan));\n          } else if (op.name === 'class') {\n            OpList.replace(op, createClassMapOp(op.target, op.expression, op.sourceSpan));\n          }\n          break;\n      }\n    }\n  }\n}\nfunction generateTemporaryVariables(job) {\n  for (const unit of job.units) {\n    unit.create.prepend(generateTemporaries(unit.create));\n    unit.update.prepend(generateTemporaries(unit.update));\n  }\n}\nfunction generateTemporaries(ops) {\n  let opCount = 0;\n  let generatedStatements = [];\n  for (const op of ops) {\n    const finalReads = new Map();\n    visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof ReadTemporaryExpr) {\n        finalReads.set(expr.xref, expr);\n      }\n    });\n    let count = 0;\n    const assigned = new Set();\n    const released = new Set();\n    const defs = new Map();\n    visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof AssignTemporaryExpr) {\n        if (!assigned.has(expr.xref)) {\n          assigned.add(expr.xref);\n          defs.set(expr.xref, `tmp_${opCount}_${count++}`);\n        }\n        assignName(defs, expr);\n      } else if (expr instanceof ReadTemporaryExpr) {\n        if (finalReads.get(expr.xref) === expr) {\n          released.add(expr.xref);\n          count--;\n        }\n        assignName(defs, expr);\n      }\n    });\n    generatedStatements.push(...Array.from(new Set(defs.values())).map(name => createStatementOp(new DeclareVarStmt(name))));\n    opCount++;\n    if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n      op.handlerOps.prepend(generateTemporaries(op.handlerOps));\n    } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n      op.trackByOps.prepend(generateTemporaries(op.trackByOps));\n    }\n  }\n  return generatedStatements;\n}\nfunction assignName(names, expr) {\n  const name = names.get(expr.xref);\n  if (name === undefined) {\n    throw new Error(`Found xref with unassigned name: ${expr.xref}`);\n  }\n  expr.name = name;\n}\nfunction optimizeTrackFns(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.RepeaterCreate) {\n        continue;\n      }\n      if (op.track instanceof ReadVarExpr && op.track.name === '$index') {\n        op.trackByFn = importExpr(Identifiers.repeaterTrackByIndex);\n      } else if (op.track instanceof ReadVarExpr && op.track.name === '$item') {\n        op.trackByFn = importExpr(Identifiers.repeaterTrackByIdentity);\n      } else if (isTrackByFunctionCall(job.root.xref, op.track)) {\n        op.usesComponentInstance = true;\n        if (op.track.receiver.receiver.view === unit.xref) {\n          op.trackByFn = op.track.receiver;\n        } else {\n          op.trackByFn = importExpr(Identifiers.componentInstance).callFn([]).prop(op.track.receiver.name);\n          op.track = op.trackByFn;\n        }\n      } else {\n        op.track = transformExpressionsInExpression(op.track, expr => {\n          if (expr instanceof PipeBindingExpr || expr instanceof PipeBindingVariadicExpr) {\n            throw new Error(`Illegal State: Pipes are not allowed in this context`);\n          } else if (expr instanceof ContextExpr) {\n            op.usesComponentInstance = true;\n            return new TrackContextExpr(expr.view);\n          }\n          return expr;\n        }, VisitorContextFlag.None);\n        const trackOpList = new OpList();\n        trackOpList.push(createStatementOp(new ReturnStatement(op.track, op.track.sourceSpan)));\n        op.trackByOps = trackOpList;\n      }\n    }\n  }\n}\nfunction isTrackByFunctionCall(rootView, expr) {\n  if (!(expr instanceof InvokeFunctionExpr) || expr.args.length === 0 || expr.args.length > 2) {\n    return false;\n  }\n  if (!(expr.receiver instanceof ReadPropExpr && expr.receiver.receiver instanceof ContextExpr) || expr.receiver.receiver.view !== rootView) {\n    return false;\n  }\n  const [arg0, arg1] = expr.args;\n  if (!(arg0 instanceof ReadVarExpr) || arg0.name !== '$index') {\n    return false;\n  } else if (expr.args.length === 1) {\n    return true;\n  }\n  if (!(arg1 instanceof ReadVarExpr) || arg1.name !== '$item') {\n    return false;\n  }\n  return true;\n}\nfunction generateTrackVariables(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.RepeaterCreate) {\n        continue;\n      }\n      op.track = transformExpressionsInExpression(op.track, expr => {\n        if (expr instanceof LexicalReadExpr) {\n          if (op.varNames.$index.has(expr.name)) {\n            return variable('$index');\n          } else if (expr.name === op.varNames.$implicit) {\n            return variable('$item');\n          }\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction transformTwoWayBindingSet(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.TwoWayListener) {\n        transformExpressionsInOp(op, expr => {\n          if (!(expr instanceof TwoWayBindingSetExpr)) {\n            return expr;\n          }\n          const {\n            target,\n            value\n          } = expr;\n          if (target instanceof ReadPropExpr || target instanceof ReadKeyExpr) {\n            return twoWayBindingSet(target, value).or(target.set(value));\n          }\n          if (target instanceof ReadVariableExpr) {\n            return twoWayBindingSet(target, value);\n          }\n          throw new Error(`Unsupported expression in two-way action binding.`);\n        }, VisitorContextFlag.InChildOperation);\n      }\n    }\n  }\n}\nfunction countVariables(job) {\n  for (const unit of job.units) {\n    let varCount = 0;\n    for (const op of unit.ops()) {\n      if (hasConsumesVarsTrait(op)) {\n        varCount += varsUsedByOp(op);\n      }\n    }\n    for (const op of unit.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (!isIrExpression(expr)) {\n          return;\n        }\n        if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder && expr instanceof PureFunctionExpr) {\n          return;\n        }\n        if (hasUsesVarOffsetTrait(expr)) {\n          expr.varOffset = varCount;\n        }\n        if (hasConsumesVarsTrait(expr)) {\n          varCount += varsUsedByIrExpression(expr);\n        }\n      });\n    }\n    if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n      for (const op of unit.ops()) {\n        visitExpressionsInOp(op, expr => {\n          if (!isIrExpression(expr) || !(expr instanceof PureFunctionExpr)) {\n            return;\n          }\n          if (hasUsesVarOffsetTrait(expr)) {\n            expr.varOffset = varCount;\n          }\n          if (hasConsumesVarsTrait(expr)) {\n            varCount += varsUsedByIrExpression(expr);\n          }\n        });\n      }\n    }\n    unit.vars = varCount;\n  }\n  if (job instanceof ComponentCompilationJob) {\n    for (const unit of job.units) {\n      for (const op of unit.create) {\n        if (op.kind !== OpKind.Template && op.kind !== OpKind.RepeaterCreate && op.kind !== OpKind.ConditionalCreate && op.kind !== OpKind.ConditionalBranchCreate) {\n          continue;\n        }\n        const childView = job.views.get(op.xref);\n        op.vars = childView.vars;\n      }\n    }\n  }\n}\nfunction varsUsedByOp(op) {\n  let slots;\n  switch (op.kind) {\n    case OpKind.Attribute:\n      slots = 1;\n      if (op.expression instanceof Interpolation && !isSingletonInterpolation(op.expression)) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.Property:\n    case OpKind.DomProperty:\n      slots = 1;\n      if (op.expression instanceof Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.Control:\n      return 2;\n    case OpKind.TwoWayProperty:\n      return 1;\n    case OpKind.StyleProp:\n    case OpKind.ClassProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassMap:\n      slots = 2;\n      if (op.expression instanceof Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.InterpolateText:\n      return op.interpolation.expressions.length;\n    case OpKind.I18nExpression:\n    case OpKind.Conditional:\n    case OpKind.DeferWhen:\n    case OpKind.StoreLet:\n      return 1;\n    case OpKind.RepeaterCreate:\n      return op.emptyView ? 1 : 0;\n    default:\n      throw new Error(`Unhandled op: ${OpKind[op.kind]}`);\n  }\n}\nfunction varsUsedByIrExpression(expr) {\n  switch (expr.kind) {\n    case ExpressionKind.PureFunctionExpr:\n      return 1 + expr.args.length;\n    case ExpressionKind.PipeBinding:\n      return 1 + expr.args.length;\n    case ExpressionKind.PipeBindingVariadic:\n      return 1 + expr.numArgs;\n    case ExpressionKind.StoreLet:\n      return 1;\n    default:\n      throw new Error(`AssertionError: unhandled ConsumesVarsTrait expression ${expr.constructor.name}`);\n  }\n}\nfunction isSingletonInterpolation(expr) {\n  if (expr.expressions.length !== 1 || expr.strings.length !== 2) {\n    return false;\n  }\n  if (expr.strings[0] !== '' || expr.strings[1] !== '') {\n    return false;\n  }\n  return true;\n}\nfunction optimizeVariables(job) {\n  for (const unit of job.units) {\n    inlineAlwaysInlineVariables(unit.create);\n    inlineAlwaysInlineVariables(unit.update);\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        inlineAlwaysInlineVariables(op.handlerOps);\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        inlineAlwaysInlineVariables(op.trackByOps);\n      }\n    }\n    optimizeVariablesInOpList(unit.create, job.compatibility);\n    optimizeVariablesInOpList(unit.update, job.compatibility);\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        optimizeVariablesInOpList(op.handlerOps, job.compatibility);\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        optimizeVariablesInOpList(op.trackByOps, job.compatibility);\n      }\n    }\n  }\n}\nvar Fence = /*#__PURE__*/function (Fence) {\n  Fence[Fence[\"None\"] = 0] = \"None\";\n  Fence[Fence[\"ViewContextRead\"] = 1] = \"ViewContextRead\";\n  Fence[Fence[\"ViewContextWrite\"] = 2] = \"ViewContextWrite\";\n  Fence[Fence[\"SideEffectful\"] = 4] = \"SideEffectful\";\n  return Fence;\n}(Fence || {});\nfunction inlineAlwaysInlineVariables(ops) {\n  const vars = new Map();\n  for (const op of ops) {\n    if (op.kind === OpKind.Variable && op.flags & VariableFlags.AlwaysInline) {\n      visitExpressionsInOp(op, expr => {\n        if (isIrExpression(expr) && fencesForIrExpression(expr) !== Fence.None) {\n          throw new Error(`AssertionError: A context-sensitive variable was marked AlwaysInline`);\n        }\n      });\n      vars.set(op.xref, op);\n    }\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof ReadVariableExpr && vars.has(expr.xref)) {\n        const varOp = vars.get(expr.xref);\n        return varOp.initializer.clone();\n      }\n      return expr;\n    }, VisitorContextFlag.None);\n  }\n  for (const op of vars.values()) {\n    OpList.remove(op);\n  }\n}\nfunction optimizeVariablesInOpList(ops, compatibility) {\n  const varDecls = new Map();\n  const varUsages = new Map();\n  const varRemoteUsages = new Set();\n  const opMap = new Map();\n  for (const op of ops) {\n    if (op.kind === OpKind.Variable) {\n      if (varDecls.has(op.xref) || varUsages.has(op.xref)) {\n        throw new Error(`Should not see two declarations of the same variable: ${op.xref}`);\n      }\n      varDecls.set(op.xref, op);\n      varUsages.set(op.xref, 0);\n    }\n    opMap.set(op, collectOpInfo(op));\n    countVariableUsages(op, varUsages, varRemoteUsages);\n  }\n  let contextIsUsed = false;\n  for (const op of ops.reversed()) {\n    const opInfo = opMap.get(op);\n    if (op.kind === OpKind.Variable && varUsages.get(op.xref) === 0) {\n      if (contextIsUsed && opInfo.fences & Fence.ViewContextWrite || opInfo.fences & Fence.SideEffectful) {\n        const stmtOp = createStatementOp(op.initializer.toStmt());\n        opMap.set(stmtOp, opInfo);\n        OpList.replace(op, stmtOp);\n      } else {\n        uncountVariableUsages(op, varUsages);\n        OpList.remove(op);\n      }\n      opMap.delete(op);\n      varDecls.delete(op.xref);\n      varUsages.delete(op.xref);\n      continue;\n    }\n    if (opInfo.fences & Fence.ViewContextRead) {\n      contextIsUsed = true;\n    }\n  }\n  const toInline = [];\n  for (const [id, count] of varUsages) {\n    const decl = varDecls.get(id);\n    const isAlwaysInline = !!(decl.flags & VariableFlags.AlwaysInline);\n    if (count !== 1 || isAlwaysInline) {\n      continue;\n    }\n    if (varRemoteUsages.has(id)) {\n      continue;\n    }\n    toInline.push(id);\n  }\n  let candidate;\n  while (candidate = toInline.pop()) {\n    const decl = varDecls.get(candidate);\n    const varInfo = opMap.get(decl);\n    const isAlwaysInline = !!(decl.flags & VariableFlags.AlwaysInline);\n    if (isAlwaysInline) {\n      throw new Error(`AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.`);\n    }\n    for (let targetOp = decl.next; targetOp.kind !== OpKind.ListEnd; targetOp = targetOp.next) {\n      const opInfo = opMap.get(targetOp);\n      if (opInfo.variablesUsed.has(candidate)) {\n        if (compatibility === CompatibilityMode.TemplateDefinitionBuilder && !allowConservativeInlining(decl, targetOp)) {\n          break;\n        }\n        if (tryInlineVariableInitializer(candidate, decl.initializer, targetOp, varInfo.fences)) {\n          opInfo.variablesUsed.delete(candidate);\n          for (const id of varInfo.variablesUsed) {\n            opInfo.variablesUsed.add(id);\n          }\n          opInfo.fences |= varInfo.fences;\n          varDecls.delete(candidate);\n          varUsages.delete(candidate);\n          opMap.delete(decl);\n          OpList.remove(decl);\n        }\n        break;\n      }\n      if (!safeToInlinePastFences(opInfo.fences, varInfo.fences)) {\n        break;\n      }\n    }\n  }\n}\nfunction fencesForIrExpression(expr) {\n  switch (expr.kind) {\n    case ExpressionKind.NextContext:\n      return Fence.ViewContextRead | Fence.ViewContextWrite;\n    case ExpressionKind.RestoreView:\n      return Fence.ViewContextRead | Fence.ViewContextWrite | Fence.SideEffectful;\n    case ExpressionKind.StoreLet:\n      return Fence.SideEffectful;\n    case ExpressionKind.Reference:\n    case ExpressionKind.ContextLetReference:\n      return Fence.ViewContextRead;\n    default:\n      return Fence.None;\n  }\n}\nfunction collectOpInfo(op) {\n  let fences = Fence.None;\n  const variablesUsed = new Set();\n  visitExpressionsInOp(op, expr => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    switch (expr.kind) {\n      case ExpressionKind.ReadVariable:\n        variablesUsed.add(expr.xref);\n        break;\n      default:\n        fences |= fencesForIrExpression(expr);\n    }\n  });\n  return {\n    fences,\n    variablesUsed\n  };\n}\nfunction countVariableUsages(op, varUsages, varRemoteUsage) {\n  visitExpressionsInOp(op, (expr, flags) => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    if (expr.kind !== ExpressionKind.ReadVariable) {\n      return;\n    }\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      return;\n    }\n    varUsages.set(expr.xref, count + 1);\n    if (flags & VisitorContextFlag.InChildOperation) {\n      varRemoteUsage.add(expr.xref);\n    }\n  });\n}\nfunction uncountVariableUsages(op, varUsages) {\n  visitExpressionsInOp(op, expr => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    if (expr.kind !== ExpressionKind.ReadVariable) {\n      return;\n    }\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      return;\n    } else if (count === 0) {\n      throw new Error(`Inaccurate variable count: ${expr.xref} - found another read but count is already 0`);\n    }\n    varUsages.set(expr.xref, count - 1);\n  });\n}\nfunction safeToInlinePastFences(fences, declFences) {\n  if (fences & Fence.ViewContextWrite) {\n    if (declFences & Fence.ViewContextRead) {\n      return false;\n    }\n  } else if (fences & Fence.ViewContextRead) {\n    if (declFences & Fence.ViewContextWrite) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction tryInlineVariableInitializer(id, initializer, target, declFences) {\n  let inlined = false;\n  let inliningAllowed = true;\n  transformExpressionsInOp(target, (expr, flags) => {\n    if (!isIrExpression(expr)) {\n      return expr;\n    }\n    if (inlined || !inliningAllowed) {\n      return expr;\n    } else if (flags & VisitorContextFlag.InChildOperation && declFences & Fence.ViewContextRead) {\n      return expr;\n    }\n    switch (expr.kind) {\n      case ExpressionKind.ReadVariable:\n        if (expr.xref === id) {\n          inlined = true;\n          return initializer;\n        }\n        break;\n      default:\n        const exprFences = fencesForIrExpression(expr);\n        inliningAllowed = inliningAllowed && safeToInlinePastFences(exprFences, declFences);\n        break;\n    }\n    return expr;\n  }, VisitorContextFlag.None);\n  return inlined;\n}\nfunction allowConservativeInlining(decl, target) {\n  switch (decl.variable.kind) {\n    case SemanticVariableKind.Identifier:\n      if (decl.initializer instanceof ReadVarExpr && decl.initializer.name === 'ctx') {\n        return true;\n      }\n      return false;\n    case SemanticVariableKind.Context:\n      return target.kind === OpKind.Variable;\n    default:\n      return true;\n  }\n}\nfunction wrapI18nIcus(job) {\n  for (const unit of job.units) {\n    let currentI18nOp = null;\n    let addedI18nId = null;\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          currentI18nOp = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18nOp = null;\n          break;\n        case OpKind.IcuStart:\n          if (currentI18nOp === null) {\n            addedI18nId = job.allocateXrefId();\n            OpList.insertBefore(createI18nStartOp(addedI18nId, op.message, undefined, null), op);\n          }\n          break;\n        case OpKind.IcuEnd:\n          if (addedI18nId !== null) {\n            OpList.insertAfter(createI18nEndOp(addedI18nId, null), op);\n            addedI18nId = null;\n          }\n          break;\n      }\n    }\n  }\n}\n\n/**\n *\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nconst phases = [{\n  kind: CompilationJobKind.Tmpl,\n  fn: removeContentSelectors\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeRegularExpressions\n}, {\n  kind: CompilationJobKind.Host,\n  fn: parseHostStyleProperties\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: emitNamespaceChanges\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: propagateI18nBlocks\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: wrapI18nIcus\n}, {\n  kind: CompilationJobKind.Both,\n  fn: deduplicateTextBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: specializeStyleBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: specializeBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: convertAnimations\n}, {\n  kind: CompilationJobKind.Both,\n  fn: extractAttributes\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createI18nContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: parseExtractedStyles\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeEmptyBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: collapseSingletonInterpolations\n}, {\n  kind: CompilationJobKind.Both,\n  fn: orderOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateConditionalExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createPipes\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: configureDeferInstructions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createVariadicPipes\n}, {\n  kind: CompilationJobKind.Both,\n  fn: generatePureLiteralStructures\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateProjectionDefs\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateLocalLetReferences\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: saveAndRestoreView\n}, {\n  kind: CompilationJobKind.Both,\n  fn: deleteAnyCasts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveDollarEvent\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateTrackVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeIllegalLetReferences\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveNames\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveDeferTargetNames\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: transformTwoWayBindingSet\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: optimizeTrackFns\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveSanitizers\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: liftLocalRefs\n}, {\n  kind: CompilationJobKind.Both,\n  fn: expandSafeReads\n}, {\n  kind: CompilationJobKind.Both,\n  fn: stripNonrequiredParentheses\n}, {\n  kind: CompilationJobKind.Both,\n  fn: generateTemporaryVariables\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeVariables\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeStoreLet\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: convertI18nText\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: convertI18nBindings\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeUnusedI18nAttributesOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: assignI18nSlotDependencies\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: applyI18nExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: allocateSlots\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveI18nElementPlaceholders\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveI18nExpressionPlaceholders\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: extractI18nMessages\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collectI18nConsts\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collectConstExpressions\n}, {\n  kind: CompilationJobKind.Both,\n  fn: collectElementConsts\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeI18nContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: countVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateAdvance\n}, {\n  kind: CompilationJobKind.Both,\n  fn: nameFunctionsAndVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveDeferDepsFns\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: mergeNextContextExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateNgContainerOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collapseEmptyInstructions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: attachSourceLocations\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: disableBindings$1\n}, {\n  kind: CompilationJobKind.Both,\n  fn: extractPureFunctions\n}, {\n  kind: CompilationJobKind.Both,\n  fn: reify\n}, {\n  kind: CompilationJobKind.Both,\n  fn: chain\n}];\nfunction transform(job, kind) {\n  for (const phase of phases) {\n    if (phase.kind === kind || phase.kind === CompilationJobKind.Both) {\n      phase.fn(job);\n    }\n  }\n}\nfunction emitTemplateFn(tpl, pool) {\n  const rootFn = emitView(tpl.root);\n  emitChildViews(tpl.root, pool);\n  return rootFn;\n}\nfunction emitChildViews(parent, pool) {\n  for (const unit of parent.job.units) {\n    if (unit.parent !== parent.xref) {\n      continue;\n    }\n    emitChildViews(unit, pool);\n    const viewFn = emitView(unit);\n    pool.statements.push(viewFn.toDeclStmt(viewFn.name));\n  }\n}\nfunction emitView(view) {\n  if (view.fnName === null) {\n    throw new Error(`AssertionError: view ${view.xref} is unnamed`);\n  }\n  const createStatements = [];\n  for (const op of view.create) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements = [];\n  for (const op of view.update) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    updateStatements.push(op.statement);\n  }\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return fn([new FnParam('rf'), new FnParam('ctx')], [...createCond, ...updateCond], undefined, undefined, view.fnName);\n}\nfunction maybeGenerateRfBlock(flag, statements) {\n  if (statements.length === 0) {\n    return [];\n  }\n  return [ifStmt(new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, variable('rf'), literal(flag)), statements)];\n}\nfunction emitHostBindingFunction(job) {\n  if (job.root.fnName === null) {\n    throw new Error(`AssertionError: host binding function is unnamed`);\n  }\n  const createStatements = [];\n  for (const op of job.root.create) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements = [];\n  for (const op of job.root.update) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    updateStatements.push(op.statement);\n  }\n  if (createStatements.length === 0 && updateStatements.length === 0) {\n    return null;\n  }\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return fn([new FnParam('rf'), new FnParam('ctx')], [...createCond, ...updateCond], undefined, undefined, job.root.fnName);\n}\nconst compatibilityMode = CompatibilityMode.TemplateDefinitionBuilder;\nconst domSchema = new DomElementSchemaRegistry();\nconst NG_TEMPLATE_TAG_NAME = 'ng-template';\nconst ANIMATE_PREFIX$1 = 'animate.';\nfunction isI18nRootNode(meta) {\n  return meta instanceof Message;\n}\nfunction isSingleI18nIcu(meta) {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;\n}\nfunction ingestComponent(componentName, template, constantPool, compilationMode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations) {\n  const job = new ComponentCompilationJob(componentName, constantPool, compatibilityMode, compilationMode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations);\n  ingestNodes(job.root, template);\n  return job;\n}\nfunction ingestHostBinding(input, bindingParser, constantPool) {\n  const job = new HostBindingCompilationJob(input.componentName, constantPool, compatibilityMode, TemplateCompilationMode.DomOnly);\n  for (const property of input.properties ?? []) {\n    let bindingKind = BindingKind.Property;\n    if (property.name.startsWith('attr.')) {\n      property.name = property.name.substring('attr.'.length);\n      bindingKind = BindingKind.Attribute;\n    }\n    if (property.isLegacyAnimation) {\n      bindingKind = BindingKind.LegacyAnimation;\n    }\n    if (property.isAnimation) {\n      bindingKind = BindingKind.Animation;\n    }\n    const securityContexts = bindingParser.calcPossibleSecurityContexts(input.componentSelector, property.name, bindingKind === BindingKind.Attribute).filter(context => context !== SecurityContext.NONE);\n    ingestDomProperty(job, property, bindingKind, securityContexts);\n  }\n  for (const [name, expr] of Object.entries(input.attributes) ?? []) {\n    const securityContexts = bindingParser.calcPossibleSecurityContexts(input.componentSelector, name, true).filter(context => context !== SecurityContext.NONE);\n    ingestHostAttribute(job, name, expr, securityContexts);\n  }\n  for (const event of input.events ?? []) {\n    ingestHostEvent(job, event);\n  }\n  return job;\n}\nfunction ingestDomProperty(job, property, bindingKind, securityContexts) {\n  let expression;\n  const ast = property.expression.ast;\n  if (ast instanceof Interpolation$1) {\n    expression = new Interpolation(ast.strings, ast.expressions.map(expr => convertAst(expr, job, property.sourceSpan)), []);\n  } else {\n    expression = convertAst(ast, job, property.sourceSpan);\n  }\n  job.root.update.push(createBindingOp(job.root.xref, bindingKind, property.name, expression, null, securityContexts, false, false, null, null, property.sourceSpan));\n}\nfunction ingestHostAttribute(job, name, value, securityContexts) {\n  const attrBinding = createBindingOp(job.root.xref, BindingKind.Attribute, name, value, null, securityContexts, true, false, null, null, value.sourceSpan);\n  job.root.update.push(attrBinding);\n}\nfunction ingestHostEvent(job, event) {\n  let eventBinding;\n  if (event.type === ParsedEventType.Animation) {\n    eventBinding = createAnimationListenerOp(job.root.xref, new SlotHandle(), event.name, null, makeListenerHandlerOps(job.root, event.handler, event.handlerSpan), event.name.endsWith('enter') ? \"enter\" : \"leave\", event.targetOrPhase, true, event.sourceSpan);\n  } else {\n    const [phase, target] = event.type !== ParsedEventType.LegacyAnimation ? [null, event.targetOrPhase] : [event.targetOrPhase, null];\n    eventBinding = createListenerOp(job.root.xref, new SlotHandle(), event.name, null, makeListenerHandlerOps(job.root, event.handler, event.handlerSpan), phase, target, true, event.sourceSpan);\n  }\n  job.root.create.push(eventBinding);\n}\nfunction ingestNodes(unit, template) {\n  for (const node of template) {\n    if (node instanceof Element$1) {\n      ingestElement(unit, node);\n    } else if (node instanceof Template) {\n      ingestTemplate(unit, node);\n    } else if (node instanceof Content) {\n      ingestContent(unit, node);\n    } else if (node instanceof Text$3) {\n      ingestText(unit, node, null);\n    } else if (node instanceof BoundText) {\n      ingestBoundText(unit, node, null);\n    } else if (node instanceof IfBlock) {\n      ingestIfBlock(unit, node);\n    } else if (node instanceof SwitchBlock) {\n      ingestSwitchBlock(unit, node);\n    } else if (node instanceof DeferredBlock) {\n      ingestDeferBlock(unit, node);\n    } else if (node instanceof Icu$1) {\n      ingestIcu(unit, node);\n    } else if (node instanceof ForLoopBlock) {\n      ingestForBlock(unit, node);\n    } else if (node instanceof LetDeclaration$1) {\n      ingestLetDeclaration(unit, node);\n    } else if (node instanceof Component$1) ;else {\n      throw new Error(`Unsupported template node: ${node.constructor.name}`);\n    }\n  }\n}\nfunction ingestElement(unit, element) {\n  if (element.i18n !== undefined && !(element.i18n instanceof Message || element.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for element: ${element.i18n.constructor.name}`);\n  }\n  const id = unit.job.allocateXrefId();\n  const [namespaceKey, elementName] = splitNsName(element.name);\n  const startOp = createElementStartOp(elementName, id, namespaceForKey(namespaceKey), element.i18n instanceof TagPlaceholder ? element.i18n : undefined, element.startSourceSpan, element.sourceSpan);\n  unit.create.push(startOp);\n  ingestElementBindings(unit, startOp, element);\n  ingestReferences(startOp, element);\n  let i18nBlockId = null;\n  if (element.i18n instanceof Message) {\n    i18nBlockId = unit.job.allocateXrefId();\n    unit.create.push(createI18nStartOp(i18nBlockId, element.i18n, undefined, element.startSourceSpan));\n  }\n  ingestNodes(unit, element.children);\n  const endOp = createElementEndOp(id, element.endSourceSpan ?? element.startSourceSpan);\n  unit.create.push(endOp);\n  const fieldInput = element.inputs.find(input => input.name === 'field' && input.type === BindingType.Property);\n  if (fieldInput) {\n    unit.create.push(createControlCreateOp(fieldInput.sourceSpan));\n  }\n  if (i18nBlockId !== null) {\n    OpList.insertBefore(createI18nEndOp(i18nBlockId, element.endSourceSpan ?? element.startSourceSpan), endOp);\n  }\n}\nfunction ingestTemplate(unit, tmpl) {\n  if (tmpl.i18n !== undefined && !(tmpl.i18n instanceof Message || tmpl.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for template: ${tmpl.i18n.constructor.name}`);\n  }\n  const childView = unit.job.allocateView(unit.xref);\n  let tagNameWithoutNamespace = tmpl.tagName;\n  let namespacePrefix = '';\n  if (tmpl.tagName) {\n    [namespacePrefix, tagNameWithoutNamespace] = splitNsName(tmpl.tagName);\n  }\n  const i18nPlaceholder = tmpl.i18n instanceof TagPlaceholder ? tmpl.i18n : undefined;\n  const namespace = namespaceForKey(namespacePrefix);\n  const functionNameSuffix = tagNameWithoutNamespace === null ? '' : prefixWithNamespace(tagNameWithoutNamespace, namespace);\n  const templateKind = isPlainTemplate(tmpl) ? TemplateKind.NgTemplate : TemplateKind.Structural;\n  const templateOp = createTemplateOp(childView.xref, templateKind, tagNameWithoutNamespace, functionNameSuffix, namespace, i18nPlaceholder, tmpl.startSourceSpan, tmpl.sourceSpan);\n  unit.create.push(templateOp);\n  ingestTemplateBindings(unit, templateOp, tmpl, templateKind);\n  ingestReferences(templateOp, tmpl);\n  ingestNodes(childView, tmpl.children);\n  for (const {\n    name,\n    value\n  } of tmpl.variables) {\n    childView.contextVariables.set(name, value !== '' ? value : '$implicit');\n  }\n  if (templateKind === TemplateKind.NgTemplate && tmpl.i18n instanceof Message) {\n    const id = unit.job.allocateXrefId();\n    OpList.insertAfter(createI18nStartOp(id, tmpl.i18n, undefined, tmpl.startSourceSpan), childView.create.head);\n    OpList.insertBefore(createI18nEndOp(id, tmpl.endSourceSpan ?? tmpl.startSourceSpan), childView.create.tail);\n  }\n}\nfunction ingestContent(unit, content) {\n  if (content.i18n !== undefined && !(content.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for element: ${content.i18n.constructor.name}`);\n  }\n  let fallbackView = null;\n  if (content.children.some(child => !(child instanceof Comment$1) && (!(child instanceof Text$3) || child.value.trim().length > 0))) {\n    fallbackView = unit.job.allocateView(unit.xref);\n    ingestNodes(fallbackView, content.children);\n  }\n  const id = unit.job.allocateXrefId();\n  const op = createProjectionOp(id, content.selector, content.i18n, fallbackView?.xref ?? null, content.sourceSpan);\n  for (const attr of content.attributes) {\n    const securityContext = domSchema.securityContext(content.name, attr.name, true);\n    unit.update.push(createBindingOp(op.xref, BindingKind.Attribute, attr.name, literal(attr.value), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n  }\n  unit.create.push(op);\n}\nfunction ingestText(unit, text, icuPlaceholder) {\n  unit.create.push(createTextOp(unit.job.allocateXrefId(), text.value, icuPlaceholder, text.sourceSpan));\n}\nfunction ingestBoundText(unit, text, icuPlaceholder) {\n  let value = text.value;\n  if (value instanceof ASTWithSource) {\n    value = value.ast;\n  }\n  if (!(value instanceof Interpolation$1)) {\n    throw new Error(`AssertionError: expected Interpolation for BoundText node, got ${value.constructor.name}`);\n  }\n  if (text.i18n !== undefined && !(text.i18n instanceof Container)) {\n    throw Error(`Unhandled i18n metadata type for text interpolation: ${text.i18n?.constructor.name}`);\n  }\n  const i18nPlaceholders = text.i18n instanceof Container ? text.i18n.children.filter(node => node instanceof Placeholder).map(placeholder => placeholder.name) : [];\n  if (i18nPlaceholders.length > 0 && i18nPlaceholders.length !== value.expressions.length) {\n    throw Error(`Unexpected number of i18n placeholders (${value.expressions.length}) for BoundText with ${value.expressions.length} expressions`);\n  }\n  const textXref = unit.job.allocateXrefId();\n  unit.create.push(createTextOp(textXref, '', icuPlaceholder, text.sourceSpan));\n  const baseSourceSpan = unit.job.compatibility ? null : text.sourceSpan;\n  unit.update.push(createInterpolateTextOp(textXref, new Interpolation(value.strings, value.expressions.map(expr => convertAst(expr, unit.job, baseSourceSpan)), i18nPlaceholders), text.sourceSpan));\n}\nfunction ingestIfBlock(unit, ifBlock) {\n  let firstXref = null;\n  let conditions = [];\n  for (let i = 0; i < ifBlock.branches.length; i++) {\n    const ifCase = ifBlock.branches[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, ifCase);\n    if (ifCase.expressionAlias !== null) {\n      cView.contextVariables.set(ifCase.expressionAlias.name, CTX_REF);\n    }\n    let ifCaseI18nMeta = undefined;\n    if (ifCase.i18n !== undefined) {\n      if (!(ifCase.i18n instanceof BlockPlaceholder)) {\n        throw Error(`Unhandled i18n metadata type for if block: ${ifCase.i18n?.constructor.name}`);\n      }\n      ifCaseI18nMeta = ifCase.i18n;\n    }\n    const createOp = i === 0 ? createConditionalCreateOp : createConditionalBranchCreateOp;\n    const conditionalCreateOp = createOp(cView.xref, TemplateKind.Block, tagName, 'Conditional', Namespace.HTML, ifCaseI18nMeta, ifCase.startSourceSpan, ifCase.sourceSpan);\n    unit.create.push(conditionalCreateOp);\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n    const caseExpr = ifCase.expression ? convertAst(ifCase.expression, unit.job, null) : null;\n    const conditionalCaseExpr = new ConditionalCaseExpr(caseExpr, conditionalCreateOp.xref, conditionalCreateOp.handle, ifCase.expressionAlias);\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, ifCase.children);\n  }\n  unit.update.push(createConditionalOp(firstXref, null, conditions, ifBlock.sourceSpan));\n}\nfunction ingestSwitchBlock(unit, switchBlock) {\n  if (switchBlock.cases.length === 0) {\n    return;\n  }\n  let firstXref = null;\n  let conditions = [];\n  for (let i = 0; i < switchBlock.cases.length; i++) {\n    const switchCase = switchBlock.cases[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, switchCase);\n    let switchCaseI18nMeta = undefined;\n    if (switchCase.i18n !== undefined) {\n      if (!(switchCase.i18n instanceof BlockPlaceholder)) {\n        throw Error(`Unhandled i18n metadata type for switch block: ${switchCase.i18n?.constructor.name}`);\n      }\n      switchCaseI18nMeta = switchCase.i18n;\n    }\n    const createOp = i === 0 ? createConditionalCreateOp : createConditionalBranchCreateOp;\n    const conditionalCreateOp = createOp(cView.xref, TemplateKind.Block, tagName, 'Case', Namespace.HTML, switchCaseI18nMeta, switchCase.startSourceSpan, switchCase.sourceSpan);\n    unit.create.push(conditionalCreateOp);\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n    const caseExpr = switchCase.expression ? convertAst(switchCase.expression, unit.job, switchBlock.startSourceSpan) : null;\n    const conditionalCaseExpr = new ConditionalCaseExpr(caseExpr, conditionalCreateOp.xref, conditionalCreateOp.handle);\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, switchCase.children);\n  }\n  unit.update.push(createConditionalOp(firstXref, convertAst(switchBlock.expression, unit.job, null), conditions, switchBlock.sourceSpan));\n}\nfunction ingestDeferView(unit, suffix, i18nMeta, children, sourceSpan) {\n  if (i18nMeta !== undefined && !(i18nMeta instanceof BlockPlaceholder)) {\n    throw Error('Unhandled i18n metadata type for defer block');\n  }\n  if (children === undefined) {\n    return null;\n  }\n  const secondaryView = unit.job.allocateView(unit.xref);\n  ingestNodes(secondaryView, children);\n  const templateOp = createTemplateOp(secondaryView.xref, TemplateKind.Block, null, `Defer${suffix}`, Namespace.HTML, i18nMeta, sourceSpan, sourceSpan);\n  unit.create.push(templateOp);\n  return templateOp;\n}\nfunction ingestDeferBlock(unit, deferBlock) {\n  let ownResolverFn = null;\n  if (unit.job.deferMeta.mode === 0) {\n    if (!unit.job.deferMeta.blocks.has(deferBlock)) {\n      throw new Error(`AssertionError: unable to find a dependency function for this deferred block`);\n    }\n    ownResolverFn = unit.job.deferMeta.blocks.get(deferBlock) ?? null;\n  }\n  const main = ingestDeferView(unit, '', deferBlock.i18n, deferBlock.children, deferBlock.sourceSpan);\n  const loading = ingestDeferView(unit, 'Loading', deferBlock.loading?.i18n, deferBlock.loading?.children, deferBlock.loading?.sourceSpan);\n  const placeholder = ingestDeferView(unit, 'Placeholder', deferBlock.placeholder?.i18n, deferBlock.placeholder?.children, deferBlock.placeholder?.sourceSpan);\n  const error = ingestDeferView(unit, 'Error', deferBlock.error?.i18n, deferBlock.error?.children, deferBlock.error?.sourceSpan);\n  const deferXref = unit.job.allocateXrefId();\n  const deferOp = createDeferOp(deferXref, main.xref, main.handle, ownResolverFn, unit.job.allDeferrableDepsFn, deferBlock.sourceSpan);\n  deferOp.placeholderView = placeholder?.xref ?? null;\n  deferOp.placeholderSlot = placeholder?.handle ?? null;\n  deferOp.loadingSlot = loading?.handle ?? null;\n  deferOp.errorSlot = error?.handle ?? null;\n  deferOp.placeholderMinimumTime = deferBlock.placeholder?.minimumTime ?? null;\n  deferOp.loadingMinimumTime = deferBlock.loading?.minimumTime ?? null;\n  deferOp.loadingAfterTime = deferBlock.loading?.afterTime ?? null;\n  deferOp.flags = calcDeferBlockFlags(deferBlock);\n  unit.create.push(deferOp);\n  const deferOnOps = [];\n  const deferWhenOps = [];\n  ingestDeferTriggers(\"hydrate\", deferBlock.hydrateTriggers, deferOnOps, deferWhenOps, unit, deferXref);\n  ingestDeferTriggers(\"none\", deferBlock.triggers, deferOnOps, deferWhenOps, unit, deferXref);\n  ingestDeferTriggers(\"prefetch\", deferBlock.prefetchTriggers, deferOnOps, deferWhenOps, unit, deferXref);\n  const hasConcreteTrigger = deferOnOps.some(op => op.modifier === \"none\") || deferWhenOps.some(op => op.modifier === \"none\");\n  if (!hasConcreteTrigger) {\n    deferOnOps.push(createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Idle\n    }, \"none\", null));\n  }\n  unit.create.push(deferOnOps);\n  unit.update.push(deferWhenOps);\n}\nfunction calcDeferBlockFlags(deferBlockDetails) {\n  if (Object.keys(deferBlockDetails.hydrateTriggers).length > 0) {\n    return 1;\n  }\n  return null;\n}\nfunction ingestDeferTriggers(modifier, triggers, onOps, whenOps, unit, deferXref) {\n  if (triggers.idle !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Idle\n    }, modifier, triggers.idle.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.immediate !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Immediate\n    }, modifier, triggers.immediate.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.timer !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Timer,\n      delay: triggers.timer.delay\n    }, modifier, triggers.timer.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.hover !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Hover,\n      targetName: triggers.hover.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null\n    }, modifier, triggers.hover.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.interaction !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Interaction,\n      targetName: triggers.interaction.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null\n    }, modifier, triggers.interaction.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.viewport !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Viewport,\n      targetName: triggers.viewport.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null,\n      options: triggers.viewport.options ? convertAst(triggers.viewport.options, unit.job, triggers.viewport.sourceSpan) : null\n    }, modifier, triggers.viewport.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.never !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Never\n    }, modifier, triggers.never.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.when !== undefined) {\n    if (triggers.when.value instanceof Interpolation$1) {\n      throw new Error(`Unexpected interpolation in defer block when trigger`);\n    }\n    const deferOnOp = createDeferWhenOp(deferXref, convertAst(triggers.when.value, unit.job, triggers.when.sourceSpan), modifier, triggers.when.sourceSpan);\n    whenOps.push(deferOnOp);\n  }\n}\nfunction ingestIcu(unit, icu) {\n  if (icu.i18n instanceof Message && isSingleI18nIcu(icu.i18n)) {\n    const xref = unit.job.allocateXrefId();\n    unit.create.push(createIcuStartOp(xref, icu.i18n, icuFromI18nMessage(icu.i18n).name, null));\n    for (const [placeholder, text] of Object.entries({\n      ...icu.vars,\n      ...icu.placeholders\n    })) {\n      if (text instanceof BoundText) {\n        ingestBoundText(unit, text, placeholder);\n      } else {\n        ingestText(unit, text, placeholder);\n      }\n    }\n    unit.create.push(createIcuEndOp(xref));\n  } else {\n    throw Error(`Unhandled i18n metadata type for ICU: ${icu.i18n?.constructor.name}`);\n  }\n}\nfunction ingestForBlock(unit, forBlock) {\n  const repeaterView = unit.job.allocateView(unit.xref);\n  const indexName = `Éµ$index_${repeaterView.xref}`;\n  const countName = `Éµ$count_${repeaterView.xref}`;\n  const indexVarNames = new Set();\n  repeaterView.contextVariables.set(forBlock.item.name, forBlock.item.value);\n  for (const variable of forBlock.contextVariables) {\n    if (variable.value === '$index') {\n      indexVarNames.add(variable.name);\n    }\n    if (variable.name === '$index') {\n      repeaterView.contextVariables.set('$index', variable.value).set(indexName, variable.value);\n    } else if (variable.name === '$count') {\n      repeaterView.contextVariables.set('$count', variable.value).set(countName, variable.value);\n    } else {\n      repeaterView.aliases.add({\n        kind: SemanticVariableKind.Alias,\n        name: null,\n        identifier: variable.name,\n        expression: getComputedForLoopVariableExpression(variable, indexName, countName)\n      });\n    }\n  }\n  const sourceSpan = convertSourceSpan(forBlock.trackBy.span, forBlock.sourceSpan);\n  const track = convertAst(forBlock.trackBy, unit.job, sourceSpan);\n  ingestNodes(repeaterView, forBlock.children);\n  let emptyView = null;\n  let emptyTagName = null;\n  if (forBlock.empty !== null) {\n    emptyView = unit.job.allocateView(unit.xref);\n    ingestNodes(emptyView, forBlock.empty.children);\n    emptyTagName = ingestControlFlowInsertionPoint(unit, emptyView.xref, forBlock.empty);\n  }\n  const varNames = {\n    $index: indexVarNames,\n    $implicit: forBlock.item.name\n  };\n  if (forBlock.i18n !== undefined && !(forBlock.i18n instanceof BlockPlaceholder)) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @for');\n  }\n  if (forBlock.empty?.i18n !== undefined && !(forBlock.empty.i18n instanceof BlockPlaceholder)) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @empty');\n  }\n  const i18nPlaceholder = forBlock.i18n;\n  const emptyI18nPlaceholder = forBlock.empty?.i18n;\n  const tagName = ingestControlFlowInsertionPoint(unit, repeaterView.xref, forBlock);\n  const repeaterCreate = createRepeaterCreateOp(repeaterView.xref, emptyView?.xref ?? null, tagName, track, varNames, emptyTagName, i18nPlaceholder, emptyI18nPlaceholder, forBlock.startSourceSpan, forBlock.sourceSpan);\n  unit.create.push(repeaterCreate);\n  const expression = convertAst(forBlock.expression, unit.job, convertSourceSpan(forBlock.expression.span, forBlock.sourceSpan));\n  const repeater = createRepeaterOp(repeaterCreate.xref, repeaterCreate.handle, expression, forBlock.sourceSpan);\n  unit.update.push(repeater);\n}\nfunction getComputedForLoopVariableExpression(variable, indexName, countName) {\n  switch (variable.value) {\n    case '$index':\n      return new LexicalReadExpr(indexName);\n    case '$count':\n      return new LexicalReadExpr(countName);\n    case '$first':\n      return new LexicalReadExpr(indexName).identical(literal(0));\n    case '$last':\n      return new LexicalReadExpr(indexName).identical(new LexicalReadExpr(countName).minus(literal(1)));\n    case '$even':\n      return new LexicalReadExpr(indexName).modulo(literal(2)).identical(literal(0));\n    case '$odd':\n      return new LexicalReadExpr(indexName).modulo(literal(2)).notIdentical(literal(0));\n    default:\n      throw new Error(`AssertionError: unknown @for loop variable ${variable.value}`);\n  }\n}\nfunction ingestLetDeclaration(unit, node) {\n  const target = unit.job.allocateXrefId();\n  unit.create.push(createDeclareLetOp(target, node.name, node.sourceSpan));\n  unit.update.push(createStoreLetOp(target, node.name, convertAst(node.value, unit.job, node.valueSpan), node.sourceSpan));\n}\nfunction convertAst(ast, job, baseSourceSpan) {\n  if (ast instanceof ASTWithSource) {\n    return convertAst(ast.ast, job, baseSourceSpan);\n  } else if (ast instanceof PropertyRead) {\n    const isImplicitReceiver = ast.receiver instanceof ImplicitReceiver && !(ast.receiver instanceof ThisReceiver);\n    if (isImplicitReceiver) {\n      return new LexicalReadExpr(ast.name);\n    } else {\n      return new ReadPropExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.name, null, convertSourceSpan(ast.span, baseSourceSpan));\n    }\n  } else if (ast instanceof Call) {\n    if (ast.receiver instanceof ImplicitReceiver) {\n      throw new Error(`Unexpected ImplicitReceiver`);\n    } else {\n      return new InvokeFunctionExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.args.map(arg => convertAst(arg, job, baseSourceSpan)), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n    }\n  } else if (ast instanceof LiteralPrimitive) {\n    return literal(ast.value, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof Unary) {\n    switch (ast.operator) {\n      case '+':\n        return new UnaryOperatorExpr(UnaryOperator.Plus, convertAst(ast.expr, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n      case '-':\n        return new UnaryOperatorExpr(UnaryOperator.Minus, convertAst(ast.expr, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n      default:\n        throw new Error(`AssertionError: unknown unary operator ${ast.operator}`);\n    }\n  } else if (ast instanceof Binary) {\n    const operator = BINARY_OPERATORS.get(ast.operation);\n    if (operator === undefined) {\n      throw new Error(`AssertionError: unknown binary operator ${ast.operation}`);\n    }\n    return new BinaryOperatorExpr(operator, convertAst(ast.left, job, baseSourceSpan), convertAst(ast.right, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof ThisReceiver) {\n    return new ContextExpr(job.root.xref);\n  } else if (ast instanceof KeyedRead) {\n    return new ReadKeyExpr(convertAst(ast.receiver, job, baseSourceSpan), convertAst(ast.key, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof Chain) {\n    throw new Error(`AssertionError: Chain in unknown context`);\n  } else if (ast instanceof LiteralMap) {\n    const entries = ast.keys.map((key, idx) => {\n      const value = ast.values[idx];\n      return new LiteralMapEntry(key.key, convertAst(value, job, baseSourceSpan), key.quoted);\n    });\n    return new LiteralMapExpr(entries, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof LiteralArray) {\n    return new LiteralArrayExpr(ast.expressions.map(expr => convertAst(expr, job, baseSourceSpan)));\n  } else if (ast instanceof Conditional) {\n    return new ConditionalExpr(convertAst(ast.condition, job, baseSourceSpan), convertAst(ast.trueExp, job, baseSourceSpan), convertAst(ast.falseExp, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof NonNullAssert) {\n    return convertAst(ast.expression, job, baseSourceSpan);\n  } else if (ast instanceof BindingPipe) {\n    return new PipeBindingExpr(job.allocateXrefId(), new SlotHandle(), ast.name, [convertAst(ast.exp, job, baseSourceSpan), ...ast.args.map(arg => convertAst(arg, job, baseSourceSpan))]);\n  } else if (ast instanceof SafeKeyedRead) {\n    return new SafeKeyedReadExpr(convertAst(ast.receiver, job, baseSourceSpan), convertAst(ast.key, job, baseSourceSpan), convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof SafePropertyRead) {\n    return new SafePropertyReadExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.name);\n  } else if (ast instanceof SafeCall) {\n    return new SafeInvokeFunctionExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.args.map(a => convertAst(a, job, baseSourceSpan)));\n  } else if (ast instanceof EmptyExpr$1) {\n    return new EmptyExpr(convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof PrefixNot) {\n    return not(convertAst(ast.expression, job, baseSourceSpan), convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof TypeofExpression) {\n    return typeofExpr(convertAst(ast.expression, job, baseSourceSpan));\n  } else if (ast instanceof VoidExpression) {\n    return new VoidExpr(convertAst(ast.expression, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof TemplateLiteral) {\n    return convertTemplateLiteral(ast, job, baseSourceSpan);\n  } else if (ast instanceof TaggedTemplateLiteral) {\n    return new TaggedTemplateLiteralExpr(convertAst(ast.tag, job, baseSourceSpan), convertTemplateLiteral(ast.template, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof ParenthesizedExpression) {\n    return new ParenthesizedExpr(convertAst(ast.expression, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof RegularExpressionLiteral) {\n    return new RegularExpressionLiteralExpr(ast.body, ast.flags, baseSourceSpan);\n  } else {\n    throw new Error(`Unhandled expression type \"${ast.constructor.name}\" in file \"${baseSourceSpan?.start.file.url}\"`);\n  }\n}\nfunction convertTemplateLiteral(ast, job, baseSourceSpan) {\n  return new TemplateLiteralExpr(ast.elements.map(el => {\n    return new TemplateLiteralElementExpr(el.text, convertSourceSpan(el.span, baseSourceSpan));\n  }), ast.expressions.map(expr => convertAst(expr, job, baseSourceSpan)), convertSourceSpan(ast.span, baseSourceSpan));\n}\nfunction convertAstWithInterpolation(job, value, i18nMeta, sourceSpan) {\n  let expression;\n  if (value instanceof Interpolation$1) {\n    expression = new Interpolation(value.strings, value.expressions.map(e => convertAst(e, job, null)), Object.keys(asMessage(i18nMeta)?.placeholders ?? {}));\n  } else if (value instanceof AST) {\n    expression = convertAst(value, job, null);\n  } else {\n    expression = literal(value);\n  }\n  return expression;\n}\nconst BINDING_KINDS = new Map([[BindingType.Property, BindingKind.Property], [BindingType.TwoWay, BindingKind.TwoWayProperty], [BindingType.Attribute, BindingKind.Attribute], [BindingType.Class, BindingKind.ClassName], [BindingType.Style, BindingKind.StyleProperty], [BindingType.LegacyAnimation, BindingKind.LegacyAnimation], [BindingType.Animation, BindingKind.Animation]]);\nfunction isPlainTemplate(tmpl) {\n  return splitNsName(tmpl.tagName ?? '')[1] === NG_TEMPLATE_TAG_NAME;\n}\nfunction asMessage(i18nMeta) {\n  if (i18nMeta == null) {\n    return null;\n  }\n  if (!(i18nMeta instanceof Message)) {\n    throw Error(`Expected i18n meta to be a Message, but got: ${i18nMeta.constructor.name}`);\n  }\n  return i18nMeta;\n}\nfunction ingestElementBindings(unit, op, element) {\n  let bindings = new Array();\n  let i18nAttributeBindingNames = new Set();\n  for (const attr of element.attributes) {\n    const securityContext = domSchema.securityContext(element.name, attr.name, true);\n    bindings.push(createBindingOp(op.xref, BindingKind.Attribute, attr.name, convertAstWithInterpolation(unit.job, attr.value, attr.i18n), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n    if (attr.i18n) {\n      i18nAttributeBindingNames.add(attr.name);\n    }\n  }\n  for (const input of element.inputs) {\n    if (i18nAttributeBindingNames.has(input.name)) {\n      console.error(`On component ${unit.job.componentName}, the binding ${input.name} is both an i18n attribute and a property. You may want to remove the property binding. This will become a compilation error in future versions of Angular.`);\n    }\n    bindings.push(createBindingOp(op.xref, BINDING_KINDS.get(input.type), input.name, convertAstWithInterpolation(unit.job, astOf(input.value), input.i18n), input.unit, input.securityContext, false, false, null, asMessage(input.i18n) ?? null, input.sourceSpan));\n  }\n  unit.create.push(bindings.filter(b => b?.kind === OpKind.ExtractedAttribute));\n  unit.update.push(bindings.filter(b => b?.kind === OpKind.Binding));\n  for (const output of element.outputs) {\n    if (output.type === ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n    if (output.type === ParsedEventType.TwoWay) {\n      unit.create.push(createTwoWayListenerOp(op.xref, op.handle, output.name, op.tag, makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan), output.sourceSpan));\n    } else if (output.type === ParsedEventType.Animation) {\n      unit.create.push(createAnimationListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.name.endsWith('enter') ? \"enter\" : \"leave\", output.target, false, output.sourceSpan));\n    } else {\n      unit.create.push(createListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.phase, output.target, false, output.sourceSpan));\n    }\n  }\n  if (bindings.some(b => b?.i18nMessage) !== null) {\n    unit.create.push(createI18nAttributesOp(unit.job.allocateXrefId(), new SlotHandle(), op.xref));\n  }\n}\nfunction ingestTemplateBindings(unit, op, template, templateKind) {\n  let bindings = new Array();\n  for (const attr of template.templateAttrs) {\n    if (attr instanceof TextAttribute) {\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n      bindings.push(createTemplateBinding(unit, op.xref, BindingType.Attribute, attr.name, attr.value, null, securityContext, true, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n    } else {\n      bindings.push(createTemplateBinding(unit, op.xref, attr.type, attr.name, astOf(attr.value), attr.unit, attr.securityContext, true, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n    }\n  }\n  for (const attr of template.attributes) {\n    const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n    bindings.push(createTemplateBinding(unit, op.xref, BindingType.Attribute, attr.name, attr.value, null, securityContext, false, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n  }\n  for (const input of template.inputs) {\n    bindings.push(createTemplateBinding(unit, op.xref, input.type, input.name, astOf(input.value), input.unit, input.securityContext, false, templateKind, asMessage(input.i18n), input.sourceSpan));\n  }\n  unit.create.push(bindings.filter(b => b?.kind === OpKind.ExtractedAttribute));\n  unit.update.push(bindings.filter(b => b?.kind === OpKind.Binding));\n  for (const output of template.outputs) {\n    if (output.type === ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n    if (templateKind === TemplateKind.NgTemplate) {\n      if (output.type === ParsedEventType.TwoWay) {\n        unit.create.push(createTwoWayListenerOp(op.xref, op.handle, output.name, op.tag, makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan), output.sourceSpan));\n      } else {\n        unit.create.push(createListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.phase, output.target, false, output.sourceSpan));\n      }\n    }\n    if (templateKind === TemplateKind.Structural && output.type !== ParsedEventType.LegacyAnimation) {\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, output.name, false);\n      unit.create.push(createExtractedAttributeOp(op.xref, BindingKind.Property, null, output.name, null, null, null, securityContext));\n    }\n  }\n  if (bindings.some(b => b?.i18nMessage) !== null) {\n    unit.create.push(createI18nAttributesOp(unit.job.allocateXrefId(), new SlotHandle(), op.xref));\n  }\n}\nfunction createTemplateBinding(view, xref, type, name, value, unit, securityContext, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  const isTextBinding = typeof value === 'string';\n  if (templateKind === TemplateKind.Structural) {\n    if (!isStructuralTemplateAttribute) {\n      switch (type) {\n        case BindingType.Property:\n        case BindingType.Class:\n        case BindingType.Style:\n          return createExtractedAttributeOp(xref, BindingKind.Property, null, name, null, null, i18nMessage, securityContext);\n        case BindingType.TwoWay:\n          return createExtractedAttributeOp(xref, BindingKind.TwoWayProperty, null, name, null, null, i18nMessage, securityContext);\n      }\n    }\n    if (!isTextBinding && (type === BindingType.Attribute || type === BindingType.LegacyAnimation || type === BindingType.Animation)) {\n      return null;\n    }\n  }\n  let bindingType = BINDING_KINDS.get(type);\n  if (templateKind === TemplateKind.NgTemplate) {\n    if (type === BindingType.Class || type === BindingType.Style || type === BindingType.Attribute && !isTextBinding) {\n      bindingType = BindingKind.Property;\n    }\n  }\n  return createBindingOp(xref, bindingType, name, convertAstWithInterpolation(view.job, value, i18nMessage), unit, securityContext, isTextBinding, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan);\n}\nfunction makeListenerHandlerOps(unit, handler, handlerSpan) {\n  handler = astOf(handler);\n  const handlerOps = new Array();\n  let handlerExprs = handler instanceof Chain ? handler.expressions : [handler];\n  if (handlerExprs.length === 0) {\n    throw new Error('Expected listener to have non-empty expression list.');\n  }\n  const expressions = handlerExprs.map(expr => convertAst(expr, unit.job, handlerSpan));\n  const returnExpr = expressions.pop();\n  handlerOps.push(...expressions.map(e => createStatementOp(new ExpressionStatement(e, e.sourceSpan))));\n  handlerOps.push(createStatementOp(new ReturnStatement(returnExpr, returnExpr.sourceSpan)));\n  return handlerOps;\n}\nfunction makeTwoWayListenerHandlerOps(unit, handler, handlerSpan) {\n  handler = astOf(handler);\n  const handlerOps = new Array();\n  if (handler instanceof Chain) {\n    if (handler.expressions.length === 1) {\n      handler = handler.expressions[0];\n    } else {\n      throw new Error('Expected two-way listener to have a single expression.');\n    }\n  }\n  const handlerExpr = convertAst(handler, unit.job, handlerSpan);\n  const eventReference = new LexicalReadExpr('$event');\n  const twoWaySetExpr = new TwoWayBindingSetExpr(handlerExpr, eventReference);\n  handlerOps.push(createStatementOp(new ExpressionStatement(twoWaySetExpr)));\n  handlerOps.push(createStatementOp(new ReturnStatement(eventReference)));\n  return handlerOps;\n}\nfunction astOf(ast) {\n  return ast instanceof ASTWithSource ? ast.ast : ast;\n}\nfunction ingestReferences(op, element) {\n  assertIsArray(op.localRefs);\n  for (const {\n    name,\n    value\n  } of element.references) {\n    op.localRefs.push({\n      name,\n      target: value\n    });\n  }\n}\nfunction assertIsArray(value) {\n  if (!Array.isArray(value)) {\n    throw new Error(`AssertionError: expected an array`);\n  }\n}\nfunction convertSourceSpan(span, baseSourceSpan) {\n  if (baseSourceSpan === null) {\n    return null;\n  }\n  const start = baseSourceSpan.start.moveBy(span.start);\n  const end = baseSourceSpan.start.moveBy(span.end);\n  const fullStart = baseSourceSpan.fullStart.moveBy(span.start);\n  return new ParseSourceSpan(start, end, fullStart);\n}\nfunction ingestControlFlowInsertionPoint(unit, xref, node) {\n  let root = null;\n  for (const child of node.children) {\n    if (child instanceof Comment$1 || child instanceof LetDeclaration$1) {\n      continue;\n    }\n    if (root !== null) {\n      return null;\n    }\n    if (child instanceof Element$1 || child instanceof Template && child.tagName !== null) {\n      root = child;\n    } else {\n      return null;\n    }\n  }\n  if (root !== null) {\n    for (const attr of root.attributes) {\n      if (!attr.name.startsWith(ANIMATE_PREFIX$1)) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.update.push(createBindingOp(xref, BindingKind.Attribute, attr.name, literal(attr.value), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n      }\n    }\n    for (const attr of root.inputs) {\n      if (attr.type !== BindingType.LegacyAnimation && attr.type !== BindingType.Animation && attr.type !== BindingType.Attribute) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.create.push(createExtractedAttributeOp(xref, BindingKind.Property, null, attr.name, null, null, null, securityContext));\n      }\n    }\n    const tagName = root instanceof Element$1 ? root.name : root.tagName;\n    return tagName === NG_TEMPLATE_TAG_NAME ? null : tagName;\n  }\n  return null;\n}\nlet ENABLE_TEMPLATE_SOURCE_LOCATIONS = false;\nfunction setEnableTemplateSourceLocations(value) {\n  ENABLE_TEMPLATE_SOURCE_LOCATIONS = value;\n}\nfunction getTemplateSourceLocationsEnabled() {\n  return ENABLE_TEMPLATE_SOURCE_LOCATIONS;\n}\nfunction renderFlagCheckIfStmt(flags, statements) {\n  return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null), statements);\n}\nfunction toQueryFlags(query) {\n  return (query.descendants ? 1 : 0) | (query.static ? 2 : 0) | (query.emitDistinctChangesOnly ? 4 : 0);\n}\nfunction getQueryPredicate(query, constantPool) {\n  if (Array.isArray(query.predicate)) {\n    let predicate = [];\n    query.predicate.forEach(selector => {\n      const selectors = selector.split(',').map(token => literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(literalArr(predicate), true);\n  } else {\n    switch (query.predicate.forwardRef) {\n      case 0:\n      case 2:\n        return query.predicate.expression;\n      case 1:\n        return importExpr(Identifiers.resolveForwardRef).callFn([query.predicate.expression]);\n    }\n  }\n}\nfunction getQueryCreateParameters(query, constantPool, prependParams) {\n  const parameters = [];\n  if (prependParams !== undefined) {\n    parameters.push(...prependParams);\n  }\n  if (query.isSignal) {\n    parameters.push(new ReadPropExpr(variable(CONTEXT_NAME), query.propertyName));\n  }\n  parameters.push(getQueryPredicate(query, constantPool), literal(toQueryFlags(query)));\n  if (query.read) {\n    parameters.push(query.read);\n  }\n  return parameters;\n}\nconst queryAdvancePlaceholder = Symbol('queryAdvancePlaceholder');\nfunction collapseAdvanceStatements(statements) {\n  const result = [];\n  let advanceCollapseCount = 0;\n  const flushAdvanceCount = () => {\n    if (advanceCollapseCount > 0) {\n      result.unshift(importExpr(Identifiers.queryAdvance).callFn(advanceCollapseCount === 1 ? [] : [literal(advanceCollapseCount)]).toStmt());\n      advanceCollapseCount = 0;\n    }\n  };\n  for (let i = statements.length - 1; i >= 0; i--) {\n    const st = statements[i];\n    if (st === queryAdvancePlaceholder) {\n      advanceCollapseCount++;\n    } else {\n      flushAdvanceCount();\n      result.unshift(st);\n    }\n  }\n  flushAdvanceCount();\n  return result;\n}\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n  const createStatements = [];\n  const updateStatements = [];\n  const tempAllocator = temporaryAllocator(st => updateStatements.push(st), TEMPORARY_NAME);\n  let viewQuerySignalCall = null;\n  let viewQueryCall = null;\n  viewQueries.forEach(query => {\n    const params = getQueryCreateParameters(query, constantPool);\n    if (query.isSignal) {\n      viewQuerySignalCall ??= importExpr(Identifiers.viewQuerySignal);\n      viewQuerySignalCall = viewQuerySignalCall.callFn(params);\n    } else {\n      viewQueryCall ??= importExpr(Identifiers.viewQuery);\n      viewQueryCall = viewQueryCall.callFn(params);\n    }\n    if (query.isSignal) {\n      updateStatements.push(queryAdvancePlaceholder);\n      return;\n    }\n    const temporary = tempAllocator();\n    const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n    const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  });\n  if (viewQuerySignalCall !== null) {\n    createStatements.push(new ExpressionStatement(viewQuerySignalCall));\n  }\n  if (viewQueryCall !== null) {\n    createStatements.push(new ExpressionStatement(viewQueryCall));\n  }\n  const viewQueryFnName = name ? `${name}_Query` : null;\n  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [renderFlagCheckIfStmt(1, createStatements), renderFlagCheckIfStmt(2, collapseAdvanceStatements(updateStatements))], INFERRED_TYPE, null, viewQueryFnName);\n}\nfunction createContentQueriesFunction(queries, constantPool, name) {\n  const createStatements = [];\n  const updateStatements = [];\n  const tempAllocator = temporaryAllocator(st => updateStatements.push(st), TEMPORARY_NAME);\n  let contentQuerySignalCall = null;\n  let contentQueryCall = null;\n  for (const query of queries) {\n    const params = getQueryCreateParameters(query, constantPool, [variable('dirIndex')]);\n    if (query.isSignal) {\n      contentQuerySignalCall ??= importExpr(Identifiers.contentQuerySignal);\n      contentQuerySignalCall = contentQuerySignalCall.callFn(params);\n    } else {\n      contentQueryCall ??= importExpr(Identifiers.contentQuery);\n      contentQueryCall = contentQueryCall.callFn(params);\n    }\n    if (query.isSignal) {\n      updateStatements.push(queryAdvancePlaceholder);\n      continue;\n    }\n    const temporary = tempAllocator();\n    const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n    const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  }\n  if (contentQuerySignalCall !== null) {\n    createStatements.push(new ExpressionStatement(contentQuerySignalCall));\n  }\n  if (contentQueryCall !== null) {\n    createStatements.push(new ExpressionStatement(contentQueryCall));\n  }\n  const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null), new FnParam('dirIndex', null)], [renderFlagCheckIfStmt(1, createStatements), renderFlagCheckIfStmt(2, collapseAdvanceStatements(updateStatements))], INFERRED_TYPE, null, contentQueriesFnName);\n}\nclass HtmlParser extends Parser$1 {\n  constructor() {\n    super(getHtmlTagDefinition);\n  }\n  parse(source, url, options) {\n    return super.parse(source, url, options);\n  }\n}\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst ANIMATE_PREFIX = 'animate';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX$1 = '*';\nconst LEGACY_ANIMATE_PROP_PREFIX = 'animate-';\nclass BindingParser {\n  _exprParser;\n  _schemaRegistry;\n  errors;\n  constructor(_exprParser, _schemaRegistry, errors) {\n    this._exprParser = _exprParser;\n    this._schemaRegistry = _schemaRegistry;\n    this.errors = errors;\n  }\n  createBoundHostProperties(properties, sourceSpan) {\n    const boundProps = [];\n    for (const propName of Object.keys(properties)) {\n      const expression = properties[propName];\n      if (typeof expression === 'string') {\n        this.parsePropertyBinding(propName, expression, true, false, sourceSpan, sourceSpan.start.offset, undefined, [], boundProps, sourceSpan);\n      } else {\n        this._reportError(`Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n      }\n    }\n    return boundProps;\n  }\n  createDirectiveHostEventAsts(hostListeners, sourceSpan) {\n    const targetEvents = [];\n    for (const propName of Object.keys(hostListeners)) {\n      const expression = hostListeners[propName];\n      if (typeof expression === 'string') {\n        this.parseEvent(propName, expression, false, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n      } else {\n        this._reportError(`Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n      }\n    }\n    return targetEvents;\n  }\n  parseInterpolation(value, sourceSpan, interpolatedTokens) {\n    const absoluteOffset = sourceSpan.fullStart.offset;\n    try {\n      const ast = this._exprParser.parseInterpolation(value, sourceSpan, absoluteOffset, interpolatedTokens);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  parseInterpolationExpression(expression, sourceSpan) {\n    const absoluteOffset = sourceSpan.start.offset;\n    try {\n      const ast = this._exprParser.parseInterpolationExpression(expression, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\n    const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;\n    const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n    for (const binding of bindings) {\n      const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n      const key = binding.key.source;\n      const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n      if (binding instanceof VariableBinding) {\n        const value = binding.value ? binding.value.source : '$implicit';\n        const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n        targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n      } else if (binding.value) {\n        const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n        const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n        this._parsePropertyAst(key, binding.value, false, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([key, '']);\n        this.parseLiteralAttr(key, null, keySpan, absoluteValueOffset, undefined, targetMatchableAttrs, targetProps, keySpan);\n      }\n    }\n  }\n  _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n      bindingsResult.errors.forEach(e => this.errors.push(e));\n      bindingsResult.warnings.forEach(warning => {\n        this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n      });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n  parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n    if (isLegacyAnimationLabel(name)) {\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      if (value) {\n        this._reportError(`Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` + ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseLegacyAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n    }\n  }\n  parsePropertyBinding(name, expression, isHost, isPartOfAssignmentBinding, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n    if (name.length === 0) {\n      this._reportError(`Property name is missing in binding`, sourceSpan);\n    }\n    let isLegacyAnimationProp = false;\n    if (name.startsWith(LEGACY_ANIMATE_PROP_PREFIX)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(LEGACY_ANIMATE_PROP_PREFIX.length);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + LEGACY_ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n      }\n    } else if (isLegacyAnimationLabel(name)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n    }\n    if (isLegacyAnimationProp) {\n      this._parseLegacyAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      this._parseAnimation(name, this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(name, this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), isPartOfAssignmentBinding, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    }\n  }\n  parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan, interpolatedTokens) {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n    if (expr) {\n      this._parsePropertyAst(name, expr, false, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n  _parsePropertyAst(name, ast, isPartOfAssignmentBinding, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, isPartOfAssignmentBinding ? ParsedPropertyType.TWO_WAY : ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n  }\n  _parseAnimation(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n  _parseLegacyAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    if (name.length === 0) {\n      this._reportError('Animation trigger is missing', sourceSpan);\n    }\n    const ast = this.parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.LEGACY_ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n  parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\n    try {\n      const ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceSpan, absoluteOffset) : this._exprParser.parseBinding(value, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {\n    if (boundProp.isLegacyAnimation) {\n      return new BoundElementProperty(boundProp.name, BindingType.LegacyAnimation, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n    let unit = null;\n    let bindingType = undefined;\n    let boundPropertyName = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts = undefined;\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      } else if (parts[0] == ANIMATE_PREFIX) {\n        boundPropertyName = boundProp.name;\n        bindingType = BindingType.Animation;\n        securityContexts = [SecurityContext.NONE];\n      }\n    }\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n      bindingType = boundProp.type === ParsedPropertyType.TWO_WAY ? BindingType.TwoWay : BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n    return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n  }\n  parseEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n    if (name.length === 0) {\n      this._reportError(`Event name is missing in binding`, sourceSpan);\n    }\n    if (isLegacyAnimationLabel(name)) {\n      name = name.slice(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      this._parseLegacyAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);\n    } else {\n      this._parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n    }\n  }\n  calcPossibleSecurityContexts(selector, propName, isAttribute) {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n  parseEventListenerName(rawName) {\n    const [target, eventName] = splitAtColon(rawName, [null, rawName]);\n    return {\n      eventName: eventName,\n      target\n    };\n  }\n  parseLegacyAnimationEventName(rawName) {\n    const matches = splitAtPeriod(rawName, [rawName, null]);\n    return {\n      eventName: matches[0],\n      phase: matches[1] === null ? null : matches[1].toLowerCase()\n    };\n  }\n  _parseLegacyAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {\n    const {\n      eventName,\n      phase\n    } = this.parseLegacyAnimationEventName(name);\n    const ast = this._parseAction(expression, handlerSpan);\n    targetEvents.push(new ParsedEvent(eventName, phase, ParsedEventType.LegacyAnimation, ast, sourceSpan, handlerSpan, keySpan));\n    if (eventName.length === 0) {\n      this._reportError(`Animation event name is missing in binding`, sourceSpan);\n    }\n    if (phase) {\n      if (phase !== 'start' && phase !== 'done') {\n        this._reportError(`The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`, sourceSpan);\n      }\n    } else {\n      this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);\n    }\n  }\n  _parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n    const {\n      eventName,\n      target\n    } = this.parseEventListenerName(name);\n    const prevErrorCount = this.errors.length;\n    const ast = this._parseAction(expression, handlerSpan);\n    const isValid = this.errors.length === prevErrorCount;\n    targetMatchableAttrs.push([name, ast.source]);\n    if (isAssignmentEvent && isValid && !this._isAllowedAssignmentEvent(ast)) {\n      this._reportError('Unsupported expression in a two-way binding', sourceSpan);\n    }\n    let eventType = ParsedEventType.Regular;\n    if (isAssignmentEvent) {\n      eventType = ParsedEventType.TwoWay;\n    }\n    if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      eventType = ParsedEventType.Animation;\n    }\n    targetEvents.push(new ParsedEvent(eventName, target, eventType, ast, sourceSpan, handlerSpan, keySpan));\n  }\n  _parseAction(value, sourceSpan) {\n    const absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;\n    try {\n      const ast = this._exprParser.parseAction(value, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr$1) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n  _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n  _isAllowedAssignmentEvent(ast) {\n    if (ast instanceof ASTWithSource) {\n      return this._isAllowedAssignmentEvent(ast.ast);\n    }\n    if (ast instanceof NonNullAssert) {\n      return this._isAllowedAssignmentEvent(ast.expression);\n    }\n    if (ast instanceof Call && ast.args.length === 1 && ast.receiver instanceof PropertyRead && ast.receiver.name === '$any' && ast.receiver.receiver instanceof ImplicitReceiver && !(ast.receiver.receiver instanceof ThisReceiver)) {\n      return this._isAllowedAssignmentEvent(ast.args[0]);\n    }\n    if (ast instanceof PropertyRead || ast instanceof KeyedRead) {\n      if (!hasRecursiveSafeReceiver(ast)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction hasRecursiveSafeReceiver(ast) {\n  if (ast instanceof SafePropertyRead || ast instanceof SafeKeyedRead) {\n    return true;\n  }\n  if (ast instanceof ParenthesizedExpression) {\n    return hasRecursiveSafeReceiver(ast.expression);\n  }\n  if (ast instanceof PropertyRead || ast instanceof KeyedRead || ast instanceof Call) {\n    return hasRecursiveSafeReceiver(ast.receiver);\n  }\n  return false;\n}\nfunction isLegacyAnimationLabel(name) {\n  return name[0] == '@';\n}\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n  let ctxs;\n  const nameToContext = elName => registry.securityContext(elName, propName, isAttribute);\n  if (selector === null) {\n    ctxs = registry.allKnownElementNames().map(nameToContext);\n  } else {\n    ctxs = [];\n    CssSelector.parse(selector).forEach(selector => {\n      const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n      const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector()).map(selector => selector.element));\n      const possibleElementNames = elementNames.filter(elName => !notElementNames.has(elName));\n      ctxs.push(...possibleElementNames.map(nameToContext));\n    });\n  }\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n  const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\nfunction isStyleUrlResolvable(url) {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\nconst NG_CONTENT_SELECT_ATTR = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\nfunction preparseElement(ast) {\n  let selectAttr = null;\n  let hrefAttr = null;\n  let relAttr = null;\n  let nonBindable = false;\n  let projectAs = '';\n  ast.attrs.forEach(attr => {\n    const lcAttrName = attr.name.toLowerCase();\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n      relAttr = attr.value;\n    } else if (attr.name == NG_NON_BINDABLE_ATTR) {\n      nonBindable = true;\n    } else if (attr.name == NG_PROJECT_AS) {\n      if (attr.value.length > 0) {\n        projectAs = attr.value;\n      }\n    }\n  });\n  selectAttr = normalizeNgContentSelect(selectAttr);\n  const nodeName = ast.name.toLowerCase();\n  let type = PreparsedElementType.OTHER;\n  if (isNgContent(nodeName)) {\n    type = PreparsedElementType.NG_CONTENT;\n  } else if (nodeName == STYLE_ELEMENT) {\n    type = PreparsedElementType.STYLE;\n  } else if (nodeName == SCRIPT_ELEMENT) {\n    type = PreparsedElementType.SCRIPT;\n  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n    type = PreparsedElementType.STYLESHEET;\n  }\n  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType = /*#__PURE__*/function (PreparsedElementType) {\n  PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n  PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n  PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n  PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n  return PreparsedElementType;\n}(PreparsedElementType || {});\nclass PreparsedElement {\n  type;\n  selectAttr;\n  hrefAttr;\n  nonBindable;\n  projectAs;\n  constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n    this.type = type;\n    this.selectAttr = selectAttr;\n    this.hrefAttr = hrefAttr;\n    this.nonBindable = nonBindable;\n    this.projectAs = projectAs;\n  }\n}\nfunction normalizeNgContentSelect(selectAttr) {\n  if (selectAttr === null || selectAttr.length === 0) {\n    return '*';\n  }\n  return selectAttr;\n}\nconst FOR_LOOP_EXPRESSION_PATTERN = /^\\s*([0-9A-Za-z_$]*)\\s+of\\s+([\\S\\s]*)/;\nconst FOR_LOOP_TRACK_PATTERN = /^track\\s+([\\S\\s]*)/;\nconst CONDITIONAL_ALIAS_PATTERN = /^(as\\s+)(.*)/;\nconst ELSE_IF_PATTERN = /^else[^\\S\\r\\n]+if/;\nconst FOR_LOOP_LET_PATTERN = /^let\\s+([\\S\\s]*)/;\nconst IDENTIFIER_PATTERN = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN = /(\\s*)(\\S+)(\\s*)/;\nconst ALLOWED_FOR_LOOP_LET_VARIABLES = new Set(['$index', '$first', '$last', '$even', '$odd', '$count']);\nfunction isConnectedForLoopBlock(name) {\n  return name === 'empty';\n}\nfunction isConnectedIfLoopBlock(name) {\n  return name === 'else' || ELSE_IF_PATTERN.test(name);\n}\nfunction createIfBlock(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = validateIfConnectedBlocks(connectedBlocks);\n  const branches = [];\n  const mainBlockParams = parseConditionalBlockParameters(ast, errors, bindingParser);\n  if (mainBlockParams !== null) {\n    branches.push(new IfBlockBranch(mainBlockParams.expression, visitAll(visitor, ast.children, ast.children), mainBlockParams.expressionAlias, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.nameSpan, ast.i18n));\n  }\n  for (const block of connectedBlocks) {\n    if (ELSE_IF_PATTERN.test(block.name)) {\n      const params = parseConditionalBlockParameters(block, errors, bindingParser);\n      if (params !== null) {\n        const children = visitAll(visitor, block.children, block.children);\n        branches.push(new IfBlockBranch(params.expression, children, params.expressionAlias, block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n));\n      }\n    } else if (block.name === 'else') {\n      const children = visitAll(visitor, block.children, block.children);\n      branches.push(new IfBlockBranch(null, children, null, block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n));\n    }\n  }\n  const ifBlockStartSourceSpan = branches.length > 0 ? branches[0].startSourceSpan : ast.startSourceSpan;\n  const ifBlockEndSourceSpan = branches.length > 0 ? branches[branches.length - 1].endSourceSpan : ast.endSourceSpan;\n  let wholeSourceSpan = ast.sourceSpan;\n  const lastBranch = branches[branches.length - 1];\n  if (lastBranch !== undefined) {\n    wholeSourceSpan = new ParseSourceSpan(ifBlockStartSourceSpan.start, lastBranch.sourceSpan.end);\n  }\n  return {\n    node: new IfBlock(branches, wholeSourceSpan, ast.startSourceSpan, ifBlockEndSourceSpan, ast.nameSpan),\n    errors\n  };\n}\nfunction createForLoop(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = [];\n  const params = parseForLoopParameters(ast, errors, bindingParser);\n  let node = null;\n  let empty = null;\n  for (const block of connectedBlocks) {\n    if (block.name === 'empty') {\n      if (empty !== null) {\n        errors.push(new ParseError(block.sourceSpan, '@for loop can only have one @empty block'));\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.sourceSpan, '@empty block cannot have parameters'));\n      } else {\n        empty = new ForLoopBlockEmpty(visitAll(visitor, block.children, block.children), block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n);\n      }\n    } else {\n      errors.push(new ParseError(block.sourceSpan, `Unrecognized @for loop block \"${block.name}\"`));\n    }\n  }\n  if (params !== null) {\n    if (params.trackBy === null) {\n      errors.push(new ParseError(ast.startSourceSpan, '@for loop must have a \"track\" expression'));\n    } else {\n      const endSpan = empty?.endSourceSpan ?? ast.endSourceSpan;\n      const sourceSpan = new ParseSourceSpan(ast.sourceSpan.start, endSpan?.end ?? ast.sourceSpan.end);\n      validateTrackByExpression(params.trackBy.expression, params.trackBy.keywordSpan, errors);\n      node = new ForLoopBlock(params.itemName, params.expression, params.trackBy.expression, params.trackBy.keywordSpan, params.context, visitAll(visitor, ast.children, ast.children), empty, sourceSpan, ast.sourceSpan, ast.startSourceSpan, endSpan, ast.nameSpan, ast.i18n);\n    }\n  }\n  return {\n    node,\n    errors\n  };\n}\nfunction createSwitchBlock(ast, visitor, bindingParser) {\n  const errors = validateSwitchBlock(ast);\n  const primaryExpression = ast.parameters.length > 0 ? parseBlockParameterToBinding(ast.parameters[0], bindingParser) : bindingParser.parseBinding('', false, ast.sourceSpan, 0);\n  const cases = [];\n  const unknownBlocks = [];\n  let defaultCase = null;\n  for (const node of ast.children) {\n    if (!(node instanceof Block)) {\n      continue;\n    }\n    if ((node.name !== 'case' || node.parameters.length === 0) && node.name !== 'default') {\n      unknownBlocks.push(new UnknownBlock(node.name, node.sourceSpan, node.nameSpan));\n      continue;\n    }\n    const expression = node.name === 'case' ? parseBlockParameterToBinding(node.parameters[0], bindingParser) : null;\n    const ast = new SwitchBlockCase(expression, visitAll(visitor, node.children, node.children), node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.nameSpan, node.i18n);\n    if (expression === null) {\n      defaultCase = ast;\n    } else {\n      cases.push(ast);\n    }\n  }\n  if (defaultCase !== null) {\n    cases.push(defaultCase);\n  }\n  return {\n    node: new SwitchBlock(primaryExpression, cases, unknownBlocks, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.nameSpan),\n    errors\n  };\n}\nfunction parseForLoopParameters(block, errors, bindingParser) {\n  if (block.parameters.length === 0) {\n    errors.push(new ParseError(block.startSourceSpan, '@for loop does not have an expression'));\n    return null;\n  }\n  const [expressionParam, ...secondaryParams] = block.parameters;\n  const match = stripOptionalParentheses(expressionParam, errors)?.match(FOR_LOOP_EXPRESSION_PATTERN);\n  if (!match || match[2].trim().length === 0) {\n    errors.push(new ParseError(expressionParam.sourceSpan, 'Cannot parse expression. @for loop expression must match the pattern \"<identifier> of <expression>\"'));\n    return null;\n  }\n  const [, itemName, rawExpression] = match;\n  if (ALLOWED_FOR_LOOP_LET_VARIABLES.has(itemName)) {\n    errors.push(new ParseError(expressionParam.sourceSpan, `@for loop item name cannot be one of ${Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES).join(', ')}.`));\n  }\n  const variableName = expressionParam.expression.split(' ')[0];\n  const variableSpan = new ParseSourceSpan(expressionParam.sourceSpan.start, expressionParam.sourceSpan.start.moveBy(variableName.length));\n  const result = {\n    itemName: new Variable(itemName, '$implicit', variableSpan, variableSpan),\n    trackBy: null,\n    expression: parseBlockParameterToBinding(expressionParam, bindingParser, rawExpression),\n    context: Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES, variableName => {\n      const emptySpanAfterForBlockStart = new ParseSourceSpan(block.startSourceSpan.end, block.startSourceSpan.end);\n      return new Variable(variableName, variableName, emptySpanAfterForBlockStart, emptySpanAfterForBlockStart);\n    })\n  };\n  for (const param of secondaryParams) {\n    const letMatch = param.expression.match(FOR_LOOP_LET_PATTERN);\n    if (letMatch !== null) {\n      const variablesSpan = new ParseSourceSpan(param.sourceSpan.start.moveBy(letMatch[0].length - letMatch[1].length), param.sourceSpan.end);\n      parseLetParameter(param.sourceSpan, letMatch[1], variablesSpan, itemName, result.context, errors);\n      continue;\n    }\n    const trackMatch = param.expression.match(FOR_LOOP_TRACK_PATTERN);\n    if (trackMatch !== null) {\n      if (result.trackBy !== null) {\n        errors.push(new ParseError(param.sourceSpan, '@for loop can only have one \"track\" expression'));\n      } else {\n        const expression = parseBlockParameterToBinding(param, bindingParser, trackMatch[1]);\n        if (expression.ast instanceof EmptyExpr$1) {\n          errors.push(new ParseError(block.startSourceSpan, '@for loop must have a \"track\" expression'));\n        }\n        const keywordSpan = new ParseSourceSpan(param.sourceSpan.start, param.sourceSpan.start.moveBy('track'.length));\n        result.trackBy = {\n          expression,\n          keywordSpan\n        };\n      }\n      continue;\n    }\n    errors.push(new ParseError(param.sourceSpan, `Unrecognized @for loop parameter \"${param.expression}\"`));\n  }\n  return result;\n}\nfunction validateTrackByExpression(expression, parseSourceSpan, errors) {\n  const visitor = new PipeVisitor();\n  expression.ast.visit(visitor);\n  if (visitor.hasPipe) {\n    errors.push(new ParseError(parseSourceSpan, 'Cannot use pipes in track expressions'));\n  }\n}\nfunction parseLetParameter(sourceSpan, expression, span, loopItemName, context, errors) {\n  const parts = expression.split(',');\n  let startSpan = span.start;\n  for (const part of parts) {\n    const expressionParts = part.split('=');\n    const name = expressionParts.length === 2 ? expressionParts[0].trim() : '';\n    const variableName = expressionParts.length === 2 ? expressionParts[1].trim() : '';\n    if (name.length === 0 || variableName.length === 0) {\n      errors.push(new ParseError(sourceSpan, `Invalid @for loop \"let\" parameter. Parameter should match the pattern \"<name> = <variable name>\"`));\n    } else if (!ALLOWED_FOR_LOOP_LET_VARIABLES.has(variableName)) {\n      errors.push(new ParseError(sourceSpan, `Unknown \"let\" parameter variable \"${variableName}\". The allowed variables are: ${Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES).join(', ')}`));\n    } else if (name === loopItemName) {\n      errors.push(new ParseError(sourceSpan, `Invalid @for loop \"let\" parameter. Variable cannot be called \"${loopItemName}\"`));\n    } else if (context.some(v => v.name === name)) {\n      errors.push(new ParseError(sourceSpan, `Duplicate \"let\" parameter variable \"${variableName}\"`));\n    } else {\n      const [, keyLeadingWhitespace, keyName] = expressionParts[0].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n      const keySpan = keyLeadingWhitespace !== undefined && expressionParts.length === 2 ? new ParseSourceSpan(startSpan.moveBy(keyLeadingWhitespace.length), startSpan.moveBy(keyLeadingWhitespace.length + keyName.length)) : span;\n      let valueSpan = undefined;\n      if (expressionParts.length === 2) {\n        const [, valueLeadingWhitespace, implicit] = expressionParts[1].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n        valueSpan = valueLeadingWhitespace !== undefined ? new ParseSourceSpan(startSpan.moveBy(expressionParts[0].length + 1 + valueLeadingWhitespace.length), startSpan.moveBy(expressionParts[0].length + 1 + valueLeadingWhitespace.length + implicit.length)) : undefined;\n      }\n      const sourceSpan = new ParseSourceSpan(keySpan.start, valueSpan?.end ?? keySpan.end);\n      context.push(new Variable(name, variableName, sourceSpan, keySpan, valueSpan));\n    }\n    startSpan = startSpan.moveBy(part.length + 1);\n  }\n}\nfunction validateIfConnectedBlocks(connectedBlocks) {\n  const errors = [];\n  let hasElse = false;\n  for (let i = 0; i < connectedBlocks.length; i++) {\n    const block = connectedBlocks[i];\n    if (block.name === 'else') {\n      if (hasElse) {\n        errors.push(new ParseError(block.startSourceSpan, 'Conditional can only have one @else block'));\n      } else if (connectedBlocks.length > 1 && i < connectedBlocks.length - 1) {\n        errors.push(new ParseError(block.startSourceSpan, '@else block must be last inside the conditional'));\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.startSourceSpan, '@else block cannot have parameters'));\n      }\n      hasElse = true;\n    } else if (!ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(new ParseError(block.startSourceSpan, `Unrecognized conditional block @${block.name}`));\n    }\n  }\n  return errors;\n}\nfunction validateSwitchBlock(ast) {\n  const errors = [];\n  let hasDefault = false;\n  if (ast.parameters.length !== 1) {\n    errors.push(new ParseError(ast.startSourceSpan, '@switch block must have exactly one parameter'));\n    return errors;\n  }\n  for (const node of ast.children) {\n    if (node instanceof Comment || node instanceof Text && node.value.trim().length === 0) {\n      continue;\n    }\n    if (!(node instanceof Block) || node.name !== 'case' && node.name !== 'default') {\n      errors.push(new ParseError(node.sourceSpan, '@switch block can only contain @case and @default blocks'));\n      continue;\n    }\n    if (node.name === 'default') {\n      if (hasDefault) {\n        errors.push(new ParseError(node.startSourceSpan, '@switch block can only have one @default block'));\n      } else if (node.parameters.length > 0) {\n        errors.push(new ParseError(node.startSourceSpan, '@default block cannot have parameters'));\n      }\n      hasDefault = true;\n    } else if (node.name === 'case' && node.parameters.length !== 1) {\n      errors.push(new ParseError(node.startSourceSpan, '@case block must have exactly one parameter'));\n    }\n  }\n  return errors;\n}\nfunction parseBlockParameterToBinding(ast, bindingParser, part) {\n  let start;\n  let end;\n  if (typeof part === 'string') {\n    start = Math.max(0, ast.expression.lastIndexOf(part));\n    end = start + part.length;\n  } else {\n    start = 0;\n    end = ast.expression.length;\n  }\n  return bindingParser.parseBinding(ast.expression.slice(start, end), false, ast.sourceSpan, ast.sourceSpan.start.offset + start);\n}\nfunction parseConditionalBlockParameters(block, errors, bindingParser) {\n  if (block.parameters.length === 0) {\n    errors.push(new ParseError(block.startSourceSpan, 'Conditional block does not have an expression'));\n    return null;\n  }\n  const expression = parseBlockParameterToBinding(block.parameters[0], bindingParser);\n  let expressionAlias = null;\n  for (let i = 1; i < block.parameters.length; i++) {\n    const param = block.parameters[i];\n    const aliasMatch = param.expression.match(CONDITIONAL_ALIAS_PATTERN);\n    if (aliasMatch === null) {\n      errors.push(new ParseError(param.sourceSpan, `Unrecognized conditional parameter \"${param.expression}\"`));\n    } else if (block.name !== 'if' && !ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(new ParseError(param.sourceSpan, '\"as\" expression is only allowed on `@if` and `@else if` blocks'));\n    } else if (expressionAlias !== null) {\n      errors.push(new ParseError(param.sourceSpan, 'Conditional can only have one \"as\" expression'));\n    } else {\n      const name = aliasMatch[2].trim();\n      if (IDENTIFIER_PATTERN.test(name)) {\n        const variableStart = param.sourceSpan.start.moveBy(aliasMatch[1].length);\n        const variableSpan = new ParseSourceSpan(variableStart, variableStart.moveBy(name.length));\n        expressionAlias = new Variable(name, name, variableSpan, variableSpan);\n      } else {\n        errors.push(new ParseError(param.sourceSpan, '\"as\" expression must be a valid JavaScript identifier'));\n      }\n    }\n  }\n  return {\n    expression,\n    expressionAlias\n  };\n}\nfunction stripOptionalParentheses(param, errors) {\n  const expression = param.expression;\n  const spaceRegex = /^\\s$/;\n  let openParens = 0;\n  let start = 0;\n  let end = expression.length - 1;\n  for (let i = 0; i < expression.length; i++) {\n    const char = expression[i];\n    if (char === '(') {\n      start = i + 1;\n      openParens++;\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n  if (openParens === 0) {\n    return expression;\n  }\n  for (let i = expression.length - 1; i > -1; i--) {\n    const char = expression[i];\n    if (char === ')') {\n      end = i;\n      openParens--;\n      if (openParens === 0) {\n        break;\n      }\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n  if (openParens !== 0) {\n    errors.push(new ParseError(param.sourceSpan, 'Unclosed parentheses in expression'));\n    return null;\n  }\n  return expression.slice(start, end);\n}\nclass PipeVisitor extends RecursiveAstVisitor {\n  hasPipe = false;\n  visitPipe() {\n    this.hasPipe = true;\n  }\n}\nconst TIME_PATTERN = /^\\d+\\.?\\d*(ms|s)?$/;\nconst SEPARATOR_PATTERN = /^\\s$/;\nconst COMMA_DELIMITED_SYNTAX = new Map([[$LBRACE, $RBRACE], [$LBRACKET, $RBRACKET], [$LPAREN, $RPAREN]]);\nvar OnTriggerType = /*#__PURE__*/function (OnTriggerType) {\n  OnTriggerType[\"IDLE\"] = \"idle\";\n  OnTriggerType[\"TIMER\"] = \"timer\";\n  OnTriggerType[\"INTERACTION\"] = \"interaction\";\n  OnTriggerType[\"IMMEDIATE\"] = \"immediate\";\n  OnTriggerType[\"HOVER\"] = \"hover\";\n  OnTriggerType[\"VIEWPORT\"] = \"viewport\";\n  OnTriggerType[\"NEVER\"] = \"never\";\n  return OnTriggerType;\n}(OnTriggerType || {});\nfunction parseNeverTrigger({\n  expression,\n  sourceSpan\n}, triggers, errors) {\n  const neverIndex = expression.indexOf('never');\n  const neverSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(neverIndex), sourceSpan.start.moveBy(neverIndex + 'never'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (neverIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"never\" keyword in expression`));\n  } else {\n    trackTrigger('never', triggers, errors, new NeverDeferredTrigger(neverSourceSpan, sourceSpan, prefetchSpan, null, hydrateSpan));\n  }\n}\nfunction parseWhenTrigger({\n  expression,\n  sourceSpan\n}, bindingParser, triggers, errors) {\n  const whenIndex = expression.indexOf('when');\n  const whenSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(whenIndex), sourceSpan.start.moveBy(whenIndex + 'when'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (whenIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"when\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, whenIndex + 1);\n    const parsed = bindingParser.parseBinding(expression.slice(start), false, sourceSpan, sourceSpan.start.offset + start);\n    trackTrigger('when', triggers, errors, new BoundDeferredTrigger(parsed, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan));\n  }\n}\nfunction parseOnTrigger({\n  expression,\n  sourceSpan\n}, bindingParser, triggers, errors, placeholder) {\n  const onIndex = expression.indexOf('on');\n  const onSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(onIndex), sourceSpan.start.moveBy(onIndex + 'on'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (onIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"on\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, onIndex + 1);\n    const isHydrationTrigger = expression.startsWith('hydrate');\n    const parser = new OnTriggerParser(expression, bindingParser, start, sourceSpan, triggers, errors, isHydrationTrigger ? validateHydrateReferenceBasedTrigger : validatePlainReferenceBasedTrigger, isHydrationTrigger, prefetchSpan, onSourceSpan, hydrateSpan);\n    parser.parse();\n  }\n}\nfunction getPrefetchSpan(expression, sourceSpan) {\n  if (!expression.startsWith('prefetch')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('prefetch'.length));\n}\nfunction getHydrateSpan(expression, sourceSpan) {\n  if (!expression.startsWith('hydrate')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('hydrate'.length));\n}\nclass OnTriggerParser {\n  expression;\n  bindingParser;\n  start;\n  span;\n  triggers;\n  errors;\n  validator;\n  isHydrationTrigger;\n  prefetchSpan;\n  onSourceSpan;\n  hydrateSpan;\n  index = 0;\n  tokens;\n  constructor(expression, bindingParser, start, span, triggers, errors, validator, isHydrationTrigger, prefetchSpan, onSourceSpan, hydrateSpan) {\n    this.expression = expression;\n    this.bindingParser = bindingParser;\n    this.start = start;\n    this.span = span;\n    this.triggers = triggers;\n    this.errors = errors;\n    this.validator = validator;\n    this.isHydrationTrigger = isHydrationTrigger;\n    this.prefetchSpan = prefetchSpan;\n    this.onSourceSpan = onSourceSpan;\n    this.hydrateSpan = hydrateSpan;\n    this.tokens = new Lexer().tokenize(expression.slice(start));\n  }\n  parse() {\n    while (this.tokens.length > 0 && this.index < this.tokens.length) {\n      const token = this.token();\n      if (!token.isIdentifier()) {\n        this.unexpectedToken(token);\n        break;\n      }\n      if (this.isFollowedByOrLast($COMMA)) {\n        this.consumeTrigger(token, []);\n        this.advance();\n      } else if (this.isFollowedByOrLast($LPAREN)) {\n        this.advance();\n        const prevErrors = this.errors.length;\n        const parameters = this.consumeParameters();\n        if (this.errors.length !== prevErrors) {\n          break;\n        }\n        this.consumeTrigger(token, parameters);\n        this.advance();\n      } else if (this.index < this.tokens.length - 1) {\n        this.unexpectedToken(this.tokens[this.index + 1]);\n      }\n      this.advance();\n    }\n  }\n  advance() {\n    this.index++;\n  }\n  isFollowedByOrLast(char) {\n    if (this.index === this.tokens.length - 1) {\n      return true;\n    }\n    return this.tokens[this.index + 1].isCharacter(char);\n  }\n  token() {\n    return this.tokens[Math.min(this.index, this.tokens.length - 1)];\n  }\n  consumeTrigger(identifier, parameters) {\n    const triggerNameStartSpan = this.span.start.moveBy(this.start + identifier.index - this.tokens[0].index);\n    const nameSpan = new ParseSourceSpan(triggerNameStartSpan, triggerNameStartSpan.moveBy(identifier.strValue.length));\n    const endSpan = triggerNameStartSpan.moveBy(this.token().end - identifier.index);\n    const isFirstTrigger = identifier.index === 0;\n    const onSourceSpan = isFirstTrigger ? this.onSourceSpan : null;\n    const prefetchSourceSpan = isFirstTrigger ? this.prefetchSpan : null;\n    const hydrateSourceSpan = isFirstTrigger ? this.hydrateSpan : null;\n    const sourceSpan = new ParseSourceSpan(isFirstTrigger ? this.span.start : triggerNameStartSpan, endSpan);\n    try {\n      switch (identifier.toString()) {\n        case OnTriggerType.IDLE:\n          this.trackTrigger('idle', createIdleTrigger(parameters, nameSpan, sourceSpan, prefetchSourceSpan, onSourceSpan, hydrateSourceSpan));\n          break;\n        case OnTriggerType.TIMER:\n          this.trackTrigger('timer', createTimerTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan));\n          break;\n        case OnTriggerType.INTERACTION:\n          this.trackTrigger('interaction', createInteractionTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        case OnTriggerType.IMMEDIATE:\n          this.trackTrigger('immediate', createImmediateTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan));\n          break;\n        case OnTriggerType.HOVER:\n          this.trackTrigger('hover', createHoverTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        case OnTriggerType.VIEWPORT:\n          this.trackTrigger('viewport', createViewportTrigger(this.start, this.isHydrationTrigger, this.bindingParser, parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        default:\n          throw new Error(`Unrecognized trigger type \"${identifier}\"`);\n      }\n    } catch (e) {\n      this.error(identifier, e.message);\n    }\n  }\n  consumeParameters() {\n    const parameters = [];\n    if (!this.token().isCharacter($LPAREN)) {\n      this.unexpectedToken(this.token());\n      return parameters;\n    }\n    this.advance();\n    const commaDelimStack = [];\n    let tokens = [];\n    while (this.index < this.tokens.length) {\n      const token = this.token();\n      if (token.isCharacter($RPAREN) && commaDelimStack.length === 0) {\n        if (tokens.length) {\n          parameters.push({\n            expression: this.tokenRangeText(tokens),\n            start: tokens[0].index\n          });\n        }\n        break;\n      }\n      if (token.type === TokenType.Character && COMMA_DELIMITED_SYNTAX.has(token.numValue)) {\n        commaDelimStack.push(COMMA_DELIMITED_SYNTAX.get(token.numValue));\n      }\n      if (commaDelimStack.length > 0 && token.isCharacter(commaDelimStack[commaDelimStack.length - 1])) {\n        commaDelimStack.pop();\n      }\n      if (commaDelimStack.length === 0 && token.isCharacter($COMMA) && tokens.length > 0) {\n        parameters.push({\n          expression: this.tokenRangeText(tokens),\n          start: tokens[0].index\n        });\n        this.advance();\n        tokens = [];\n        continue;\n      }\n      tokens.push(token);\n      this.advance();\n    }\n    if (!this.token().isCharacter($RPAREN) || commaDelimStack.length > 0) {\n      this.error(this.token(), 'Unexpected end of expression');\n    }\n    if (this.index < this.tokens.length - 1 && !this.tokens[this.index + 1].isCharacter($COMMA)) {\n      this.unexpectedToken(this.tokens[this.index + 1]);\n    }\n    return parameters;\n  }\n  tokenRangeText(tokens) {\n    if (tokens.length === 0) {\n      return '';\n    }\n    return this.expression.slice(this.start + tokens[0].index, this.start + tokens[tokens.length - 1].end);\n  }\n  trackTrigger(name, trigger) {\n    trackTrigger(name, this.triggers, this.errors, trigger);\n  }\n  error(token, message) {\n    const newStart = this.span.start.moveBy(this.start + token.index);\n    const newEnd = newStart.moveBy(token.end - token.index);\n    this.errors.push(new ParseError(new ParseSourceSpan(newStart, newEnd), message));\n  }\n  unexpectedToken(token) {\n    this.error(token, `Unexpected token \"${token}\"`);\n  }\n}\nfunction trackTrigger(name, allTriggers, errors, trigger) {\n  if (allTriggers[name]) {\n    errors.push(new ParseError(trigger.sourceSpan, `Duplicate \"${name}\" trigger is not allowed`));\n  } else {\n    allTriggers[name] = trigger;\n  }\n}\nfunction createIdleTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IDLE}\" trigger cannot have parameters`);\n  }\n  return new IdleDeferredTrigger(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createTimerTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length !== 1) {\n    throw new Error(`\"${OnTriggerType.TIMER}\" trigger must have exactly one parameter`);\n  }\n  const delay = parseDeferredTime(parameters[0].expression);\n  if (delay === null) {\n    throw new Error(`Could not parse time value of trigger \"${OnTriggerType.TIMER}\"`);\n  }\n  return new TimerDeferredTrigger(delay, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createImmediateTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IMMEDIATE}\" trigger cannot have parameters`);\n  }\n  return new ImmediateDeferredTrigger(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createHoverTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.HOVER, parameters);\n  return new HoverDeferredTrigger(parameters[0]?.expression ?? null, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createInteractionTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.INTERACTION, parameters);\n  return new InteractionDeferredTrigger(parameters[0]?.expression ?? null, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createViewportTrigger(start, isHydrationTrigger, bindingParser, parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.VIEWPORT, parameters);\n  let reference;\n  let options;\n  if (parameters.length === 0) {\n    reference = options = null;\n  } else if (!parameters[0].expression.startsWith('{')) {\n    reference = parameters[0].expression;\n    options = null;\n  } else {\n    const parsed = bindingParser.parseBinding(parameters[0].expression, false, sourceSpan, sourceSpan.start.offset + start + parameters[0].start);\n    if (!(parsed.ast instanceof LiteralMap)) {\n      throw new Error('Options parameter of the \"viewport\" trigger must be an object literal');\n    } else if (parsed.ast.keys.some(key => key.key === 'root')) {\n      throw new Error('The \"root\" option is not supported in the options parameter of the \"viewport\" trigger');\n    }\n    const triggerIndex = parsed.ast.keys.findIndex(key => key.key === 'trigger');\n    if (triggerIndex === -1) {\n      reference = null;\n      options = parsed.ast;\n    } else {\n      const value = parsed.ast.values[triggerIndex];\n      const triggerFilter = (_, index) => index !== triggerIndex;\n      if (!(value instanceof PropertyRead) || !(value.receiver instanceof ImplicitReceiver) || value.receiver instanceof ThisReceiver) {\n        throw new Error(`\"trigger\" option of the \"viewport\" trigger must be an identifier`);\n      }\n      reference = value.name;\n      options = new LiteralMap(parsed.ast.span, parsed.ast.sourceSpan, parsed.ast.keys.filter(triggerFilter), parsed.ast.values.filter(triggerFilter));\n    }\n  }\n  if (isHydrationTrigger && reference !== null) {\n    throw new Error(`\"viewport\" hydration trigger cannot have a \"trigger\"`);\n  } else if (options) {\n    const dynamicNode = DynamicAstValidator.findDynamicNode(options);\n    if (dynamicNode !== null) {\n      throw new Error(`Options of the \"viewport\" trigger must be an object ` + `literal containing only literal values, but \"${dynamicNode.constructor.name}\" was found`);\n    }\n  }\n  return new ViewportDeferredTrigger(reference, options, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction validatePlainReferenceBasedTrigger(type, parameters) {\n  if (parameters.length > 1) {\n    throw new Error(`\"${type}\" trigger can only have zero or one parameters`);\n  }\n}\nfunction validateHydrateReferenceBasedTrigger(type, parameters) {\n  if (type === OnTriggerType.VIEWPORT) {\n    if (parameters.length > 1) {\n      throw new Error(`Hydration trigger \"${type}\" cannot have more than one parameter`);\n    }\n    return;\n  }\n  if (parameters.length > 0) {\n    throw new Error(`Hydration trigger \"${type}\" cannot have parameters`);\n  }\n}\nfunction getTriggerParametersStart(value, startPosition = 0) {\n  let hasFoundSeparator = false;\n  for (let i = startPosition; i < value.length; i++) {\n    if (SEPARATOR_PATTERN.test(value[i])) {\n      hasFoundSeparator = true;\n    } else if (hasFoundSeparator) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction parseDeferredTime(value) {\n  const match = value.match(TIME_PATTERN);\n  if (!match) {\n    return null;\n  }\n  const [time, units] = match;\n  return parseFloat(time) * (units === 's' ? 1000 : 1);\n}\nclass DynamicAstValidator extends RecursiveAstVisitor {\n  dynamicNode = null;\n  static findDynamicNode(ast) {\n    const visitor = new DynamicAstValidator();\n    visitor.visit(ast);\n    return visitor.dynamicNode;\n  }\n  visit(ast) {\n    if (!(ast instanceof ASTWithSource) && !(ast instanceof LiteralPrimitive) && !(ast instanceof LiteralArray) && !(ast instanceof LiteralMap)) {\n      this.dynamicNode = ast;\n    } else {\n      super.visit(ast);\n    }\n  }\n}\nconst PREFETCH_WHEN_PATTERN = /^prefetch\\s+when\\s/;\nconst PREFETCH_ON_PATTERN = /^prefetch\\s+on\\s/;\nconst HYDRATE_WHEN_PATTERN = /^hydrate\\s+when\\s/;\nconst HYDRATE_ON_PATTERN = /^hydrate\\s+on\\s/;\nconst HYDRATE_NEVER_PATTERN = /^hydrate\\s+never(\\s*)$/;\nconst MINIMUM_PARAMETER_PATTERN = /^minimum\\s/;\nconst AFTER_PARAMETER_PATTERN = /^after\\s/;\nconst WHEN_PARAMETER_PATTERN = /^when\\s/;\nconst ON_PARAMETER_PATTERN = /^on\\s/;\nfunction isConnectedDeferLoopBlock(name) {\n  return name === 'placeholder' || name === 'loading' || name === 'error';\n}\nfunction createDeferredBlock(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = [];\n  const {\n    placeholder,\n    loading,\n    error\n  } = parseConnectedBlocks(connectedBlocks, errors, visitor);\n  const {\n    triggers,\n    prefetchTriggers,\n    hydrateTriggers\n  } = parsePrimaryTriggers(ast, bindingParser, errors);\n  let lastEndSourceSpan = ast.endSourceSpan;\n  let endOfLastSourceSpan = ast.sourceSpan.end;\n  if (connectedBlocks.length > 0) {\n    const lastConnectedBlock = connectedBlocks[connectedBlocks.length - 1];\n    lastEndSourceSpan = lastConnectedBlock.endSourceSpan;\n    endOfLastSourceSpan = lastConnectedBlock.sourceSpan.end;\n  }\n  const sourceSpanWithConnectedBlocks = new ParseSourceSpan(ast.sourceSpan.start, endOfLastSourceSpan);\n  const node = new DeferredBlock(visitAll(visitor, ast.children, ast.children), triggers, prefetchTriggers, hydrateTriggers, placeholder, loading, error, ast.nameSpan, sourceSpanWithConnectedBlocks, ast.sourceSpan, ast.startSourceSpan, lastEndSourceSpan, ast.i18n);\n  return {\n    node,\n    errors\n  };\n}\nfunction parseConnectedBlocks(connectedBlocks, errors, visitor) {\n  let placeholder = null;\n  let loading = null;\n  let error = null;\n  for (const block of connectedBlocks) {\n    try {\n      if (!isConnectedDeferLoopBlock(block.name)) {\n        errors.push(new ParseError(block.startSourceSpan, `Unrecognized block \"@${block.name}\"`));\n        break;\n      }\n      switch (block.name) {\n        case 'placeholder':\n          if (placeholder !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @placeholder block`));\n          } else {\n            placeholder = parsePlaceholderBlock(block, visitor);\n          }\n          break;\n        case 'loading':\n          if (loading !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @loading block`));\n          } else {\n            loading = parseLoadingBlock(block, visitor);\n          }\n          break;\n        case 'error':\n          if (error !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @error block`));\n          } else {\n            error = parseErrorBlock(block, visitor);\n          }\n          break;\n      }\n    } catch (e) {\n      errors.push(new ParseError(block.startSourceSpan, e.message));\n    }\n  }\n  return {\n    placeholder,\n    loading,\n    error\n  };\n}\nfunction parsePlaceholderBlock(ast, visitor) {\n  let minimumTime = null;\n  for (const param of ast.parameters) {\n    if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@placeholder block can only have one \"minimum\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @placeholder block: \"${param.expression}\"`);\n    }\n  }\n  return new DeferredBlockPlaceholder(visitAll(visitor, ast.children, ast.children), minimumTime, ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parseLoadingBlock(ast, visitor) {\n  let afterTime = null;\n  let minimumTime = null;\n  for (const param of ast.parameters) {\n    if (AFTER_PARAMETER_PATTERN.test(param.expression)) {\n      if (afterTime != null) {\n        throw new Error(`@loading block can only have one \"after\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"after\"`);\n      }\n      afterTime = parsedTime;\n    } else if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@loading block can only have one \"minimum\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @loading block: \"${param.expression}\"`);\n    }\n  }\n  return new DeferredBlockLoading(visitAll(visitor, ast.children, ast.children), afterTime, minimumTime, ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parseErrorBlock(ast, visitor) {\n  if (ast.parameters.length > 0) {\n    throw new Error(`@error block cannot have parameters`);\n  }\n  return new DeferredBlockError(visitAll(visitor, ast.children, ast.children), ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parsePrimaryTriggers(ast, bindingParser, errors, placeholder) {\n  const triggers = {};\n  const prefetchTriggers = {};\n  const hydrateTriggers = {};\n  for (const param of ast.parameters) {\n    if (WHEN_PARAMETER_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, triggers, errors);\n    } else if (ON_PARAMETER_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, triggers, errors);\n    } else if (PREFETCH_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, prefetchTriggers, errors);\n    } else if (PREFETCH_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, prefetchTriggers, errors);\n    } else if (HYDRATE_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, hydrateTriggers, errors);\n    } else if (HYDRATE_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, hydrateTriggers, errors);\n    } else if (HYDRATE_NEVER_PATTERN.test(param.expression)) {\n      parseNeverTrigger(param, hydrateTriggers, errors);\n    } else {\n      errors.push(new ParseError(param.sourceSpan, 'Unrecognized trigger'));\n    }\n  }\n  if (hydrateTriggers.never && Object.keys(hydrateTriggers).length > 1) {\n    errors.push(new ParseError(ast.startSourceSpan, 'Cannot specify additional `hydrate` triggers if `hydrate never` is present'));\n  }\n  return {\n    triggers,\n    prefetchTriggers,\n    hydrateTriggers\n  };\n}\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\nconst KW_BIND_IDX = 1;\nconst KW_LET_IDX = 2;\nconst KW_REF_IDX = 3;\nconst KW_ON_IDX = 4;\nconst KW_BINDON_IDX = 5;\nconst KW_AT_IDX = 6;\nconst IDENT_KW_IDX = 7;\nconst BINDING_DELIMS = {\n  BANANA_BOX: {\n    start: '[(',\n    end: ')]'\n  },\n  PROPERTY: {\n    start: '[',\n    end: ']'\n  },\n  EVENT: {\n    start: '(',\n    end: ')'\n  }\n};\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst UNSUPPORTED_SELECTORLESS_TAGS = new Set(['link', 'style', 'script', 'ng-template', 'ng-container', 'ng-content']);\nconst UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS = new Set(['ngProjectAs', 'ngNonBindable']);\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\n  const transformer = new HtmlAstToIvyAst(bindingParser, options);\n  const ivyNodes = visitAll(transformer, htmlNodes, htmlNodes);\n  const allErrors = bindingParser.errors.concat(transformer.errors);\n  const result = {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    result.commentNodes = transformer.commentNodes;\n  }\n  return result;\n}\nclass HtmlAstToIvyAst {\n  bindingParser;\n  options;\n  errors = [];\n  styles = [];\n  styleUrls = [];\n  ngContentSelectors = [];\n  commentNodes = [];\n  inI18nBlock = false;\n  processedNodes = new Set();\n  constructor(bindingParser, options) {\n    this.bindingParser = bindingParser;\n    this.options = options;\n  }\n  visitElement(element) {\n    const isI18nRootElement = isI18nRootNode(element.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n      const contents = textContents(element);\n      if (contents !== null) {\n        this.styles.push(contents);\n      }\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      this.styleUrls.push(preparsedElement.hrefAttr);\n      return null;\n    }\n    const isTemplateElement = isNgTemplate(element.name);\n    const {\n      attributes,\n      boundEvents,\n      references,\n      variables,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    } = this.prepareAttributes(element.attrs, isTemplateElement);\n    const directives = this.extractDirectives(element);\n    let children;\n    if (preparsedElement.nonBindable) {\n      children = visitAll(NON_BINDABLE_VISITOR, element.children).flat(Infinity);\n    } else {\n      children = visitAll(this, element.children, element.children);\n    }\n    let parsedElement;\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      const selector = preparsedElement.selectAttr;\n      const attrs = element.attrs.map(attr => this.visitAttribute(attr));\n      parsedElement = new Content(selector, attrs, children, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      this.ngContentSelectors.push(selector);\n    } else if (isTemplateElement) {\n      const attrs = this.categorizePropertyAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, directives, [], children, references, variables, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    } else {\n      const attrs = this.categorizePropertyAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      if (element.name === 'ng-container') {\n        for (const bound of attrs.bound) {\n          if (bound.type === BindingType.Attribute) {\n            this.reportError(`Attribute bindings are not supported on ng-container. Use property bindings instead.`, bound.sourceSpan);\n          }\n        }\n      }\n      parsedElement = new Element$1(element.name, attributes, attrs.bound, boundEvents, directives, children, references, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n    }\n    if (elementHasInlineTemplate) {\n      parsedElement = this.wrapInTemplate(parsedElement, templateParsedProperties, templateVariables, i18nAttrsMeta, isTemplateElement, isI18nRootElement);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return parsedElement;\n  }\n  visitAttribute(attribute) {\n    return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n  }\n  visitText(text) {\n    return this.processedNodes.has(text) ? null : this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);\n  }\n  visitExpansion(expansion) {\n    if (!expansion.i18n) {\n      return null;\n    }\n    if (!isI18nRootNode(expansion.i18n)) {\n      throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n    }\n    const message = expansion.i18n;\n    const vars = {};\n    const placeholders = {};\n    Object.keys(message.placeholders).forEach(key => {\n      const value = message.placeholders[key];\n      if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n        const formattedKey = key.trim();\n        const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n        vars[formattedKey] = new BoundText(ast, value.sourceSpan);\n      } else {\n        placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);\n      }\n    });\n    return new Icu$1(vars, placeholders, expansion.sourceSpan, message);\n  }\n  visitExpansionCase(expansionCase) {\n    return null;\n  }\n  visitComment(comment) {\n    if (this.options.collectCommentNodes) {\n      this.commentNodes.push(new Comment$1(comment.value || '', comment.sourceSpan));\n    }\n    return null;\n  }\n  visitLetDeclaration(decl, context) {\n    const value = this.bindingParser.parseBinding(decl.value, false, decl.valueSpan, decl.valueSpan.start.offset);\n    if (value.errors.length === 0 && value.ast instanceof EmptyExpr$1) {\n      this.reportError('@let declaration value cannot be empty', decl.valueSpan);\n    }\n    return new LetDeclaration$1(decl.name, value, decl.sourceSpan, decl.nameSpan, decl.valueSpan);\n  }\n  visitComponent(component) {\n    const isI18nRootElement = isI18nRootNode(component.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError('Cannot mark a component as translatable inside of a translatable section. Please remove the nested i18n marker.', component.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    if (component.tagName !== null && UNSUPPORTED_SELECTORLESS_TAGS.has(component.tagName)) {\n      this.reportError(`Tag name \"${component.tagName}\" cannot be used as a component tag`, component.startSourceSpan);\n      return null;\n    }\n    const {\n      attributes,\n      boundEvents,\n      references,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    } = this.prepareAttributes(component.attrs, false);\n    this.validateSelectorlessReferences(references);\n    const directives = this.extractDirectives(component);\n    let children;\n    if (component.attrs.find(attr => attr.name === 'ngNonBindable')) {\n      children = visitAll(NON_BINDABLE_VISITOR, component.children).flat(Infinity);\n    } else {\n      children = visitAll(this, component.children, component.children);\n    }\n    const attrs = this.categorizePropertyAttributes(component.tagName, parsedProperties, i18nAttrsMeta);\n    let node = new Component$1(component.componentName, component.tagName, component.fullName, attributes, attrs.bound, boundEvents, directives, children, references, component.isSelfClosing, component.sourceSpan, component.startSourceSpan, component.endSourceSpan, component.i18n);\n    if (elementHasInlineTemplate) {\n      node = this.wrapInTemplate(node, templateParsedProperties, templateVariables, i18nAttrsMeta, false, isI18nRootElement);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return node;\n  }\n  visitDirective() {\n    return null;\n  }\n  visitBlockParameter() {\n    return null;\n  }\n  visitBlock(block, context) {\n    const index = Array.isArray(context) ? context.indexOf(block) : -1;\n    if (index === -1) {\n      throw new Error('Visitor invoked incorrectly. Expecting visitBlock to be invoked siblings array as its context');\n    }\n    if (this.processedNodes.has(block)) {\n      return null;\n    }\n    let result = null;\n    switch (block.name) {\n      case 'defer':\n        result = createDeferredBlock(block, this.findConnectedBlocks(index, context, isConnectedDeferLoopBlock), this, this.bindingParser);\n        break;\n      case 'switch':\n        result = createSwitchBlock(block, this, this.bindingParser);\n        break;\n      case 'for':\n        result = createForLoop(block, this.findConnectedBlocks(index, context, isConnectedForLoopBlock), this, this.bindingParser);\n        break;\n      case 'if':\n        result = createIfBlock(block, this.findConnectedBlocks(index, context, isConnectedIfLoopBlock), this, this.bindingParser);\n        break;\n      default:\n        let errorMessage;\n        if (isConnectedDeferLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @defer block.`;\n          this.processedNodes.add(block);\n        } else if (isConnectedForLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @for block.`;\n          this.processedNodes.add(block);\n        } else if (isConnectedIfLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @if or @else if block.`;\n          this.processedNodes.add(block);\n        } else {\n          errorMessage = `Unrecognized block @${block.name}.`;\n        }\n        result = {\n          node: new UnknownBlock(block.name, block.sourceSpan, block.nameSpan),\n          errors: [new ParseError(block.sourceSpan, errorMessage)]\n        };\n        break;\n    }\n    this.errors.push(...result.errors);\n    return result.node;\n  }\n  findConnectedBlocks(primaryBlockIndex, siblings, predicate) {\n    const relatedBlocks = [];\n    for (let i = primaryBlockIndex + 1; i < siblings.length; i++) {\n      const node = siblings[i];\n      if (node instanceof Comment) {\n        continue;\n      }\n      if (node instanceof Text && node.value.trim().length === 0) {\n        this.processedNodes.add(node);\n        continue;\n      }\n      if (!(node instanceof Block) || !predicate(node.name)) {\n        break;\n      }\n      relatedBlocks.push(node);\n      this.processedNodes.add(node);\n    }\n    return relatedBlocks;\n  }\n  categorizePropertyAttributes(elementName, properties, i18nPropsMeta) {\n    const bound = [];\n    const literal = [];\n    properties.forEach(prop => {\n      const i18n = i18nPropsMeta[prop.name];\n      if (prop.isLiteral) {\n        literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\n      } else {\n        const bep = this.bindingParser.createBoundElementProperty(elementName, prop, true, false);\n        bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n      }\n    });\n    return {\n      bound,\n      literal\n    };\n  }\n  prepareAttributes(attrs, isTemplateElement) {\n    const parsedProperties = [];\n    const boundEvents = [];\n    const variables = [];\n    const references = [];\n    const attributes = [];\n    const i18nAttrsMeta = {};\n    const templateParsedProperties = [];\n    const templateVariables = [];\n    let elementHasInlineTemplate = false;\n    for (const attribute of attrs) {\n      let hasBinding = false;\n      const normalizedName = normalizeAttributeName(attribute.name);\n      let isTemplateBinding = false;\n      if (attribute.i18n) {\n        i18nAttrsMeta[attribute.name] = attribute.i18n;\n      }\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        if (elementHasInlineTemplate) {\n          this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);\n        }\n        isTemplateBinding = true;\n        elementHasInlineTemplate = true;\n        const templateValue = attribute.value;\n        const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n        const parsedVariables = [];\n        const absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.fullStart.offset : attribute.sourceSpan.fullStart.offset + attribute.name.length;\n        this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true);\n        templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n      } else {\n        hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n      }\n      if (!hasBinding && !isTemplateBinding) {\n        attributes.push(this.visitAttribute(attribute));\n      }\n    }\n    return {\n      attributes,\n      boundEvents,\n      references,\n      variables,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    };\n  }\n  parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n    const name = normalizeAttributeName(attribute.name);\n    const value = attribute.value;\n    const srcSpan = attribute.sourceSpan;\n    const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.fullStart.offset : srcSpan.fullStart.offset;\n    function createKeySpan(srcSpan, prefix, identifier) {\n      const normalizationAdjustment = attribute.name.length - name.length;\n      const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n      const keySpanEnd = keySpanStart.moveBy(identifier.length);\n      return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n    }\n    const bindParts = name.match(BIND_NAME_REGEXP);\n    if (bindParts) {\n      if (bindParts[KW_BIND_IDX] != null) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(identifier, value, false, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n          this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n        } else {\n          this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n        this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n      } else if (bindParts[KW_ON_IDX]) {\n        const events = [];\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n        this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      } else if (bindParts[KW_BINDON_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(identifier, value, false, true, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan, absoluteOffset);\n      } else if (bindParts[KW_AT_IDX]) {\n        const keySpan = createKeySpan(srcSpan, '', name);\n        this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      }\n      return true;\n    }\n    let delims = null;\n    if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n      delims = BINDING_DELIMS.BANANA_BOX;\n    } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n      delims = BINDING_DELIMS.PROPERTY;\n    } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n      delims = BINDING_DELIMS.EVENT;\n    }\n    if (delims !== null && name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n      const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n      const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n      if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n        this.bindingParser.parsePropertyBinding(identifier, value, false, true, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan, absoluteOffset);\n      } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n        this.bindingParser.parsePropertyBinding(identifier, value, false, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      } else {\n        const events = [];\n        this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      }\n      return true;\n    }\n    const keySpan = createKeySpan(srcSpan, '', name);\n    const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, attribute.valueTokens ?? null);\n    return hasBinding;\n  }\n  extractDirectives(node) {\n    const elementName = node instanceof Component ? node.tagName : node.name;\n    const directives = [];\n    const seenDirectives = new Set();\n    for (const directive of node.directives) {\n      let invalid = false;\n      for (const attr of directive.attrs) {\n        if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\n          invalid = true;\n          this.reportError(`Shorthand template syntax \"${attr.name}\" is not supported inside a directive context`, attr.sourceSpan);\n        } else if (UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS.has(attr.name)) {\n          invalid = true;\n          this.reportError(`Attribute \"${attr.name}\" is not supported in a directive context`, attr.sourceSpan);\n        }\n      }\n      if (!invalid && seenDirectives.has(directive.name)) {\n        invalid = true;\n        this.reportError(`Cannot apply directive \"${directive.name}\" multiple times on the same element`, directive.sourceSpan);\n      }\n      if (invalid) {\n        continue;\n      }\n      const {\n        attributes,\n        parsedProperties,\n        boundEvents,\n        references,\n        i18nAttrsMeta\n      } = this.prepareAttributes(directive.attrs, false);\n      this.validateSelectorlessReferences(references);\n      const {\n        bound: inputs\n      } = this.categorizePropertyAttributes(elementName, parsedProperties, i18nAttrsMeta);\n      for (const input of inputs) {\n        if (input.type !== BindingType.Property && input.type !== BindingType.TwoWay) {\n          invalid = true;\n          this.reportError('Binding is not supported in a directive context', input.sourceSpan);\n        }\n      }\n      if (invalid) {\n        continue;\n      }\n      seenDirectives.add(directive.name);\n      directives.push(new Directive$1(directive.name, attributes, inputs, boundEvents, references, directive.sourceSpan, directive.startSourceSpan, directive.endSourceSpan, undefined));\n    }\n    return directives;\n  }\n  filterAnimationAttributes(attributes) {\n    return attributes.filter(a => !a.name.startsWith('animate.'));\n  }\n  filterAnimationInputs(attributes) {\n    return attributes.filter(a => a.type !== BindingType.Animation);\n  }\n  wrapInTemplate(node, templateProperties, templateVariables, i18nAttrsMeta, isTemplateElement, isI18nRootElement) {\n    const attrs = this.categorizePropertyAttributes('ng-template', templateProperties, i18nAttrsMeta);\n    const templateAttrs = [];\n    attrs.literal.forEach(attr => templateAttrs.push(attr));\n    attrs.bound.forEach(attr => templateAttrs.push(attr));\n    const hoistedAttrs = {\n      attributes: [],\n      inputs: [],\n      outputs: []\n    };\n    if (node instanceof Element$1 || node instanceof Component$1) {\n      hoistedAttrs.attributes.push(...this.filterAnimationAttributes(node.attributes));\n      hoistedAttrs.inputs.push(...this.filterAnimationInputs(node.inputs));\n      hoistedAttrs.outputs.push(...node.outputs);\n    }\n    const i18n = isTemplateElement && isI18nRootElement ? undefined : node.i18n;\n    let name;\n    if (node instanceof Component$1) {\n      name = node.tagName;\n    } else if (node instanceof Template) {\n      name = null;\n    } else {\n      name = node.name;\n    }\n    return new Template(name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, [], templateAttrs, [node], [], templateVariables, false, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, i18n);\n  }\n  _visitTextWithInterpolation(value, sourceSpan, interpolatedTokens, i18n) {\n    const valueNoNgsp = replaceNgsp(value);\n    const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);\n    return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);\n  }\n  parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Variable does not have a name`, sourceSpan);\n    }\n    variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n  parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Reference does not have a name`, sourceSpan);\n    } else if (references.some(reference => reference.name === identifier)) {\n      this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n    }\n    references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n  parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan, absoluteOffset) {\n    const events = [];\n    this.bindingParser.parseEvent(`${name}Change`, expression, true, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n    addEvents(events, boundEvents);\n  }\n  validateSelectorlessReferences(references) {\n    if (references.length === 0) {\n      return;\n    }\n    const seenNames = new Set();\n    for (const ref of references) {\n      if (ref.value.length > 0) {\n        this.reportError('Cannot specify a value for a local reference in this context', ref.valueSpan || ref.sourceSpan);\n      } else if (seenNames.has(ref.name)) {\n        this.reportError('Duplicate reference names are not allowed', ref.sourceSpan);\n      } else {\n        seenNames.add(ref.name);\n      }\n    }\n  }\n  reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n}\nclass NonBindableVisitor {\n  visitElement(ast) {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      return null;\n    }\n    const children = visitAll(this, ast.children, null);\n    return new Element$1(ast.name, visitAll(this, ast.attrs), [], [], [], children, [], ast.isSelfClosing, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.isVoid);\n  }\n  visitComment(comment) {\n    return null;\n  }\n  visitAttribute(attribute) {\n    return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n  }\n  visitText(text) {\n    return new Text$3(text.value, text.sourceSpan);\n  }\n  visitExpansion(expansion) {\n    return null;\n  }\n  visitExpansionCase(expansionCase) {\n    return null;\n  }\n  visitBlock(block, context) {\n    const nodes = [new Text$3(block.startSourceSpan.toString(), block.startSourceSpan), ...visitAll(this, block.children)];\n    if (block.endSourceSpan !== null) {\n      nodes.push(new Text$3(block.endSourceSpan.toString(), block.endSourceSpan));\n    }\n    return nodes;\n  }\n  visitBlockParameter(parameter, context) {\n    return null;\n  }\n  visitLetDeclaration(decl, context) {\n    return new Text$3(`@let ${decl.name} = ${decl.value};`, decl.sourceSpan);\n  }\n  visitComponent(ast, context) {\n    const children = visitAll(this, ast.children, null);\n    return new Element$1(ast.fullName, visitAll(this, ast.attrs), [], [], [], children, [], ast.isSelfClosing, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, false);\n  }\n  visitDirective(directive, context) {\n    return null;\n  }\n}\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\nfunction normalizeAttributeName(attrName) {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\nfunction addEvents(events, boundEvents) {\n  boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));\n}\nfunction textContents(node) {\n  if (node.children.length !== 1 || !(node.children[0] instanceof Text)) {\n    return null;\n  } else {\n    return node.children[0].value;\n  }\n}\nconst LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\nfunction parseTemplate(template, templateUrl, options = {}) {\n  const {\n    preserveWhitespaces,\n    enableI18nLegacyMessageIdFormat\n  } = options;\n  const selectorlessEnabled = options.enableSelectorless ?? false;\n  const bindingParser = makeBindingParser(selectorlessEnabled);\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(template, templateUrl, {\n    leadingTriviaChars: LEADING_TRIVIA_CHARS,\n    ...options,\n    tokenizeExpansionForms: true,\n    tokenizeBlocks: options.enableBlockSyntax ?? true,\n    tokenizeLet: options.enableLetSyntax ?? true,\n    selectorlessEnabled\n  });\n  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {\n    const parsedTemplate = {\n      preserveWhitespaces,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n  let rootNodes = parseResult.rootNodes;\n  const retainEmptyTokens = !(options.preserveSignificantWhitespace ?? true);\n  const i18nMetaVisitor = new I18nMetaVisitor(!preserveWhitespaces, enableI18nLegacyMessageIdFormat, options.preserveSignificantWhitespace, retainEmptyTokens);\n  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {\n    const parsedTemplate = {\n      preserveWhitespaces,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n  rootNodes = i18nMetaResult.rootNodes;\n  if (!preserveWhitespaces) {\n    rootNodes = visitAll(new WhitespaceVisitor(true, undefined, false), rootNodes);\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = visitAll(new I18nMetaVisitor(false, undefined, true, retainEmptyTokens), rootNodes);\n    }\n  }\n  const {\n    nodes,\n    errors,\n    styleUrls,\n    styles,\n    ngContentSelectors,\n    commentNodes\n  } = htmlAstToRender3Ast(rootNodes, bindingParser, {\n    collectCommentNodes: !!options.collectCommentNodes\n  });\n  errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n  const parsedTemplate = {\n    preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    nodes,\n    styleUrls,\n    styles,\n    ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n  return parsedTemplate;\n}\nconst elementRegistry = new DomElementSchemaRegistry();\nfunction makeBindingParser(selectorlessEnabled = false) {\n  return new BindingParser(new Parser(new Lexer(), selectorlessEnabled), elementRegistry, []);\n}\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n  const definitionMap = new DefinitionMap();\n  const selectors = parseSelectorToR3Selector(meta.selector);\n  definitionMap.set('type', meta.type.value);\n  if (selectors.length > 0) {\n    definitionMap.set('selectors', asLiteral(selectors));\n  }\n  if (meta.queries.length > 0) {\n    definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n  }\n  if (meta.viewQueries.length) {\n    definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n  }\n  definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));\n  definitionMap.set('inputs', conditionallyCreateDirectiveBindingLiteral(meta.inputs, true));\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));\n  }\n  if (meta.isStandalone === false) {\n    definitionMap.set('standalone', literal(false));\n  }\n  if (meta.isSignal) {\n    definitionMap.set('signals', literal(true));\n  }\n  return definitionMap;\n}\nfunction addFeatures(definitionMap, meta) {\n  const features = [];\n  const providers = meta.providers;\n  const viewProviders = meta.viewProviders;\n  if (providers || viewProviders) {\n    const args = [providers || new LiteralArrayExpr([])];\n    if (viewProviders) {\n      args.push(viewProviders);\n    }\n    features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));\n  }\n  if (meta.hostDirectives?.length) {\n    features.push(importExpr(Identifiers.HostDirectivesFeature).callFn([createHostDirectivesFeatureArg(meta.hostDirectives)]));\n  }\n  if (meta.usesInheritance) {\n    features.push(importExpr(Identifiers.InheritDefinitionFeature));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    features.push(importExpr(Identifiers.NgOnChangesFeature));\n  }\n  if ('externalStyles' in meta && meta.externalStyles?.length) {\n    const externalStyleNodes = meta.externalStyles.map(externalStyle => literal(externalStyle));\n    features.push(importExpr(Identifiers.ExternalStylesFeature).callFn([literalArr(externalStyleNodes)]));\n  }\n  if (features.length) {\n    definitionMap.set('features', literalArr(features));\n  }\n}\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createDirectiveType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const selector = meta.selector && CssSelector.parse(meta.selector);\n  const firstSelector = selector && selector[0];\n  if (firstSelector) {\n    const selectorAttributes = firstSelector.getAttrs();\n    if (selectorAttributes.length) {\n      definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), true));\n    }\n  }\n  const templateTypeName = meta.name;\n  let allDeferrableDepsFn = null;\n  if (meta.defer.mode === 1 && meta.defer.dependenciesFn !== null) {\n    const fnName = `${templateTypeName}_DeferFn`;\n    constantPool.statements.push(new DeclareVarStmt(fnName, meta.defer.dependenciesFn, undefined, StmtModifier.Final));\n    allDeferrableDepsFn = variable(fnName);\n  }\n  const compilationMode = meta.isStandalone && !meta.hasDirectiveDependencies ? TemplateCompilationMode.DomOnly : TemplateCompilationMode.Full;\n  const tpl = ingestComponent(meta.name, meta.template.nodes, constantPool, compilationMode, meta.relativeContextFilePath, meta.i18nUseExternalIds, meta.defer, allDeferrableDepsFn, meta.relativeTemplatePath, getTemplateSourceLocationsEnabled());\n  transform(tpl, CompilationJobKind.Tmpl);\n  const templateFn = emitTemplateFn(tpl, constantPool);\n  if (tpl.contentSelectors !== null) {\n    definitionMap.set('ngContentSelectors', tpl.contentSelectors);\n  }\n  definitionMap.set('decls', literal(tpl.root.decls));\n  definitionMap.set('vars', literal(tpl.root.vars));\n  if (tpl.consts.length > 0) {\n    if (tpl.constsInitializers.length > 0) {\n      definitionMap.set('consts', arrowFn([], [...tpl.constsInitializers, new ReturnStatement(literalArr(tpl.consts))]));\n    } else {\n      definitionMap.set('consts', literalArr(tpl.consts));\n    }\n  }\n  definitionMap.set('template', templateFn);\n  if (meta.declarationListEmitMode !== 3 && meta.declarations.length > 0) {\n    definitionMap.set('dependencies', compileDeclarationList(literalArr(meta.declarations.map(decl => decl.type)), meta.declarationListEmitMode));\n  } else if (meta.declarationListEmitMode === 3) {\n    const args = [meta.type.value];\n    if (meta.rawImports) {\n      args.push(meta.rawImports);\n    }\n    definitionMap.set('dependencies', importExpr(Identifiers.getComponentDepsFactory).callFn(args));\n  }\n  if (meta.encapsulation === null) {\n    meta.encapsulation = ViewEncapsulation$1.Emulated;\n  }\n  let hasStyles = !!meta.externalStyles?.length;\n  if (meta.styles && meta.styles.length) {\n    const styleValues = meta.encapsulation == ViewEncapsulation$1.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;\n    const styleNodes = styleValues.reduce((result, style) => {\n      if (style.trim().length > 0) {\n        result.push(constantPool.getConstLiteral(literal(style)));\n      }\n      return result;\n    }, []);\n    if (styleNodes.length > 0) {\n      hasStyles = true;\n      definitionMap.set('styles', literalArr(styleNodes));\n    }\n  }\n  if (!hasStyles && meta.encapsulation === ViewEncapsulation$1.Emulated) {\n    meta.encapsulation = ViewEncapsulation$1.None;\n  }\n  if (meta.encapsulation !== ViewEncapsulation$1.Emulated) {\n    definitionMap.set('encapsulation', literal(meta.encapsulation));\n  }\n  if (meta.animations !== null) {\n    definitionMap.set('data', literalMap([{\n      key: 'animation',\n      value: meta.animations,\n      quoted: false\n    }]));\n  }\n  if (meta.changeDetection !== null) {\n    if (typeof meta.changeDetection === 'number' && meta.changeDetection !== ChangeDetectionStrategy.Default) {\n      definitionMap.set('changeDetection', literal(meta.changeDetection));\n    } else if (typeof meta.changeDetection === 'object') {\n      definitionMap.set('changeDetection', meta.changeDetection);\n    }\n  }\n  const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createComponentType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createComponentType(meta) {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n  typeParams.push(expressionType(literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  if (meta.isSignal) {\n    typeParams.push(expressionType(literal(meta.isSignal)));\n  }\n  return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));\n}\nfunction compileDeclarationList(list, mode) {\n  switch (mode) {\n    case 0:\n      return list;\n    case 1:\n      return arrowFn([], list);\n    case 2:\n      const resolvedList = list.prop('map').callFn([importExpr(Identifiers.resolveForwardRef)]);\n      return arrowFn([], resolvedList);\n    case 3:\n      throw new Error(`Unsupported with an array of pre-resolved dependencies`);\n  }\n}\nfunction stringAsType(str) {\n  return expressionType(literal(str));\n}\nfunction stringMapAsLiteralExpression(map) {\n  const mapValues = Object.keys(map).map(key => {\n    const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n    return {\n      key,\n      value: literal(value),\n      quoted: true\n    };\n  });\n  return literalMap(mapValues);\n}\nfunction stringArrayAsType(arr) {\n  return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) : NONE_TYPE;\n}\nfunction createBaseDirectiveTypeParams(meta) {\n  const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n  return [typeWithParameters(meta.type.type, meta.typeArgumentCount), selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE, meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE, expressionType(getInputsTypeExpression(meta)), expressionType(stringMapAsLiteralExpression(meta.outputs)), stringArrayAsType(meta.queries.map(q => q.propertyName))];\n}\nfunction getInputsTypeExpression(meta) {\n  return literalMap(Object.keys(meta.inputs).map(key => {\n    const value = meta.inputs[key];\n    const values = [{\n      key: 'alias',\n      value: literal(value.bindingPropertyName),\n      quoted: true\n    }, {\n      key: 'required',\n      value: literal(value.required),\n      quoted: true\n    }];\n    if (value.isSignal) {\n      values.push({\n        key: 'isSignal',\n        value: literal(value.isSignal),\n        quoted: true\n      });\n    }\n    return {\n      key,\n      value: literalMap(values),\n      quoted: true\n    };\n  }));\n}\nfunction createDirectiveType(meta) {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(NONE_TYPE);\n  typeParams.push(expressionType(literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  if (meta.isSignal) {\n    typeParams.push(expressionType(literal(meta.isSignal)));\n  }\n  return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));\n}\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n  const bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, typeSourceSpan);\n  const eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, typeSourceSpan);\n  if (hostBindingsMetadata.specialAttributes.styleAttr) {\n    hostBindingsMetadata.attributes['style'] = literal(hostBindingsMetadata.specialAttributes.styleAttr);\n  }\n  if (hostBindingsMetadata.specialAttributes.classAttr) {\n    hostBindingsMetadata.attributes['class'] = literal(hostBindingsMetadata.specialAttributes.classAttr);\n  }\n  const hostJob = ingestHostBinding({\n    componentName: name,\n    componentSelector: selector,\n    properties: bindings,\n    events: eventBindings,\n    attributes: hostBindingsMetadata.attributes\n  }, bindingParser, constantPool);\n  transform(hostJob, CompilationJobKind.Host);\n  definitionMap.set('hostAttrs', hostJob.root.attributes);\n  const varCount = hostJob.root.vars;\n  if (varCount !== null && varCount > 0) {\n    definitionMap.set('hostVars', literal(varCount));\n  }\n  return emitHostBindingFunction(hostJob);\n}\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\nfunction parseHostBindings(host) {\n  const attributes = {};\n  const listeners = {};\n  const properties = {};\n  const specialAttributes = {};\n  for (const key of Object.keys(host)) {\n    const value = host[key];\n    const matches = key.match(HOST_REG_EXP);\n    if (matches === null) {\n      switch (key) {\n        case 'class':\n          if (typeof value !== 'string') {\n            throw new Error(`Class binding must be string`);\n          }\n          specialAttributes.classAttr = value;\n          break;\n        case 'style':\n          if (typeof value !== 'string') {\n            throw new Error(`Style binding must be string`);\n          }\n          specialAttributes.styleAttr = value;\n          break;\n        default:\n          if (typeof value === 'string') {\n            attributes[key] = literal(value);\n          } else {\n            attributes[key] = value;\n          }\n      }\n    } else if (matches[1] != null) {\n      if (typeof value !== 'string') {\n        throw new Error(`Property binding must be string`);\n      }\n      properties[matches[1]] = value;\n    } else if (matches[2] != null) {\n      if (typeof value !== 'string') {\n        throw new Error(`Event binding must be string`);\n      }\n      listeners[matches[2]] = value;\n    }\n  }\n  return {\n    attributes,\n    listeners,\n    properties,\n    specialAttributes\n  };\n}\nfunction verifyHostBindings(bindings, sourceSpan) {\n  const bindingParser = makeBindingParser();\n  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n  return bindingParser.errors;\n}\nfunction compileStyles(styles, selector, hostSelector) {\n  const shadowCss = new ShadowCss();\n  return styles.map(style => {\n    return shadowCss.shimCssText(style, selector, hostSelector);\n  });\n}\nfunction encapsulateStyle(style, componentIdentifier) {\n  const shadowCss = new ShadowCss();\n  const selector = componentIdentifier ? CONTENT_ATTR.replace(COMPONENT_VARIABLE, componentIdentifier) : CONTENT_ATTR;\n  const hostSelector = componentIdentifier ? HOST_ATTR.replace(COMPONENT_VARIABLE, componentIdentifier) : HOST_ATTR;\n  return shadowCss.shimCssText(style, selector, hostSelector);\n}\nfunction createHostDirectivesType(meta) {\n  if (!meta.hostDirectives?.length) {\n    return NONE_TYPE;\n  }\n  return expressionType(literalArr(meta.hostDirectives.map(hostMeta => literalMap([{\n    key: 'directive',\n    value: typeofExpr(hostMeta.directive.type),\n    quoted: false\n  }, {\n    key: 'inputs',\n    value: stringMapAsLiteralExpression(hostMeta.inputs || {}),\n    quoted: false\n  }, {\n    key: 'outputs',\n    value: stringMapAsLiteralExpression(hostMeta.outputs || {}),\n    quoted: false\n  }]))));\n}\nfunction createHostDirectivesFeatureArg(hostDirectives) {\n  const expressions = [];\n  let hasForwardRef = false;\n  for (const current of hostDirectives) {\n    if (!current.inputs && !current.outputs) {\n      expressions.push(current.directive.type);\n    } else {\n      const keys = [{\n        key: 'directive',\n        value: current.directive.type,\n        quoted: false\n      }];\n      if (current.inputs) {\n        const inputsLiteral = createHostDirectivesMappingArray(current.inputs);\n        if (inputsLiteral) {\n          keys.push({\n            key: 'inputs',\n            value: inputsLiteral,\n            quoted: false\n          });\n        }\n      }\n      if (current.outputs) {\n        const outputsLiteral = createHostDirectivesMappingArray(current.outputs);\n        if (outputsLiteral) {\n          keys.push({\n            key: 'outputs',\n            value: outputsLiteral,\n            quoted: false\n          });\n        }\n      }\n      expressions.push(literalMap(keys));\n    }\n    if (current.isForwardReference) {\n      hasForwardRef = true;\n    }\n  }\n  return hasForwardRef ? new FunctionExpr([], [new ReturnStatement(literalArr(expressions))]) : literalArr(expressions);\n}\nfunction createHostDirectivesMappingArray(mapping) {\n  const elements = [];\n  for (const publicName in mapping) {\n    if (mapping.hasOwnProperty(publicName)) {\n      elements.push(literal(publicName), literal(mapping[publicName]));\n    }\n  }\n  return elements.length > 0 ? literalArr(elements) : null;\n}\nfunction compileDeferResolverFunction(meta) {\n  const depExpressions = [];\n  if (meta.mode === 0) {\n    for (const dep of meta.dependencies) {\n      if (dep.isDeferrable) {\n        const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(dep.isDefaultImport ? 'default' : dep.symbolName));\n        const importExpr = new DynamicImportExpr(dep.importPath).prop('then').callFn([innerFn]);\n        depExpressions.push(importExpr);\n      } else {\n        depExpressions.push(dep.typeReference);\n      }\n    }\n  } else {\n    for (const {\n      symbolName,\n      importPath,\n      isDefaultImport\n    } of meta.dependencies) {\n      const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(isDefaultImport ? 'default' : symbolName));\n      const importExpr = new DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n      depExpressions.push(importExpr);\n    }\n  }\n  return arrowFn([], literalArr(depExpressions));\n}\nclass CombinedRecursiveAstVisitor extends RecursiveAstVisitor {\n  visit(node) {\n    if (node instanceof ASTWithSource) {\n      this.visit(node.ast);\n    } else {\n      node.visit(this);\n    }\n  }\n  visitElement(element) {\n    this.visitAllTemplateNodes(element.attributes);\n    this.visitAllTemplateNodes(element.inputs);\n    this.visitAllTemplateNodes(element.outputs);\n    this.visitAllTemplateNodes(element.directives);\n    this.visitAllTemplateNodes(element.references);\n    this.visitAllTemplateNodes(element.children);\n  }\n  visitTemplate(template) {\n    this.visitAllTemplateNodes(template.attributes);\n    this.visitAllTemplateNodes(template.inputs);\n    this.visitAllTemplateNodes(template.outputs);\n    this.visitAllTemplateNodes(template.directives);\n    this.visitAllTemplateNodes(template.templateAttrs);\n    this.visitAllTemplateNodes(template.variables);\n    this.visitAllTemplateNodes(template.references);\n    this.visitAllTemplateNodes(template.children);\n  }\n  visitContent(content) {\n    this.visitAllTemplateNodes(content.children);\n  }\n  visitBoundAttribute(attribute) {\n    this.visit(attribute.value);\n  }\n  visitBoundEvent(attribute) {\n    this.visit(attribute.handler);\n  }\n  visitBoundText(text) {\n    this.visit(text.value);\n  }\n  visitIcu(icu) {\n    Object.keys(icu.vars).forEach(key => this.visit(icu.vars[key]));\n    Object.keys(icu.placeholders).forEach(key => this.visit(icu.placeholders[key]));\n  }\n  visitDeferredBlock(deferred) {\n    deferred.visitAll(this);\n  }\n  visitDeferredTrigger(trigger) {\n    if (trigger instanceof BoundDeferredTrigger) {\n      this.visit(trigger.value);\n    } else if (trigger instanceof ViewportDeferredTrigger && trigger.options !== null) {\n      this.visit(trigger.options);\n    }\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitDeferredBlockError(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitDeferredBlockLoading(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitSwitchBlock(block) {\n    this.visit(block.expression);\n    this.visitAllTemplateNodes(block.cases);\n  }\n  visitSwitchBlockCase(block) {\n    block.expression && this.visit(block.expression);\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitForLoopBlock(block) {\n    block.item.visit(this);\n    this.visitAllTemplateNodes(block.contextVariables);\n    this.visit(block.expression);\n    this.visitAllTemplateNodes(block.children);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitIfBlock(block) {\n    this.visitAllTemplateNodes(block.branches);\n  }\n  visitIfBlockBranch(block) {\n    block.expression && this.visit(block.expression);\n    block.expressionAlias?.visit(this);\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitLetDeclaration(decl) {\n    this.visit(decl.value);\n  }\n  visitComponent(component) {\n    this.visitAllTemplateNodes(component.attributes);\n    this.visitAllTemplateNodes(component.inputs);\n    this.visitAllTemplateNodes(component.outputs);\n    this.visitAllTemplateNodes(component.directives);\n    this.visitAllTemplateNodes(component.references);\n    this.visitAllTemplateNodes(component.children);\n  }\n  visitDirective(directive) {\n    this.visitAllTemplateNodes(directive.attributes);\n    this.visitAllTemplateNodes(directive.inputs);\n    this.visitAllTemplateNodes(directive.outputs);\n    this.visitAllTemplateNodes(directive.references);\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitText(text) {}\n  visitUnknownBlock(block) {}\n  visitAllTemplateNodes(nodes) {\n    for (const node of nodes) {\n      this.visit(node);\n    }\n  }\n}\nfunction diff(fullList, itemsToExclude) {\n  const exclude = new Set(itemsToExclude);\n  return fullList.filter(item => !exclude.has(item));\n}\nfunction findMatchingDirectivesAndPipes(template, directiveSelectors) {\n  const matcher = new SelectorMatcher();\n  for (const selector of directiveSelectors) {\n    const fakeDirective = {\n      selector,\n      exportAs: null,\n      inputs: {\n        hasBindingPropertyName() {\n          return false;\n        }\n      },\n      outputs: {\n        hasBindingPropertyName() {\n          return false;\n        }\n      }\n    };\n    matcher.addSelectables(CssSelector.parse(selector), [fakeDirective]);\n  }\n  const parsedTemplate = parseTemplate(template, '');\n  const binder = new R3TargetBinder(matcher);\n  const bound = binder.bind({\n    template: parsedTemplate.nodes\n  });\n  const eagerDirectiveSelectors = bound.getEagerlyUsedDirectives().map(dir => dir.selector);\n  const allMatchedDirectiveSelectors = bound.getUsedDirectives().map(dir => dir.selector);\n  const eagerPipes = bound.getEagerlyUsedPipes();\n  return {\n    directives: {\n      regular: eagerDirectiveSelectors,\n      deferCandidates: diff(allMatchedDirectiveSelectors, eagerDirectiveSelectors)\n    },\n    pipes: {\n      regular: eagerPipes,\n      deferCandidates: diff(bound.getUsedPipes(), eagerPipes)\n    }\n  };\n}\nclass R3TargetBinder {\n  directiveMatcher;\n  constructor(directiveMatcher) {\n    this.directiveMatcher = directiveMatcher;\n  }\n  bind(target) {\n    if (!target.template && !target.host) {\n      throw new Error('Empty bound targets are not supported');\n    }\n    const directives = new Map();\n    const eagerDirectives = [];\n    const missingDirectives = new Set();\n    const bindings = new Map();\n    const references = new Map();\n    const scopedNodeEntities = new Map();\n    const expressions = new Map();\n    const symbols = new Map();\n    const nestingLevel = new Map();\n    const usedPipes = new Set();\n    const eagerPipes = new Set();\n    const deferBlocks = [];\n    if (target.template) {\n      const scope = Scope.apply(target.template);\n      extractScopedNodeEntities(scope, scopedNodeEntities);\n      DirectiveBinder.apply(target.template, this.directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references);\n      TemplateBinder.applyWithScope(target.template, scope, expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks);\n    }\n    if (target.host) {\n      directives.set(target.host.node, target.host.directives);\n      TemplateBinder.applyWithScope(target.host.node, Scope.apply(target.host.node), expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks);\n    }\n    return new R3BoundTarget(target, directives, eagerDirectives, missingDirectives, bindings, references, expressions, symbols, nestingLevel, scopedNodeEntities, usedPipes, eagerPipes, deferBlocks);\n  }\n}\nclass Scope {\n  parentScope;\n  rootNode;\n  namedEntities = new Map();\n  elementLikeInScope = new Set();\n  childScopes = new Map();\n  isDeferred;\n  constructor(parentScope, rootNode) {\n    this.parentScope = parentScope;\n    this.rootNode = rootNode;\n    this.isDeferred = parentScope !== null && parentScope.isDeferred ? true : rootNode instanceof DeferredBlock;\n  }\n  static newRootScope() {\n    return new Scope(null, null);\n  }\n  static apply(template) {\n    const scope = Scope.newRootScope();\n    scope.ingest(template);\n    return scope;\n  }\n  ingest(nodeOrNodes) {\n    if (nodeOrNodes instanceof Template) {\n      nodeOrNodes.variables.forEach(node => this.visitVariable(node));\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitVariable(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitVariable(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach(v => this.visitVariable(v));\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof SwitchBlockCase || nodeOrNodes instanceof ForLoopBlockEmpty || nodeOrNodes instanceof DeferredBlock || nodeOrNodes instanceof DeferredBlockError || nodeOrNodes instanceof DeferredBlockPlaceholder || nodeOrNodes instanceof DeferredBlockLoading || nodeOrNodes instanceof Content) {\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (!(nodeOrNodes instanceof HostElement)) {\n      nodeOrNodes.forEach(node => node.visit(this));\n    }\n  }\n  visitElement(element) {\n    this.visitElementLike(element);\n  }\n  visitTemplate(template) {\n    template.directives.forEach(node => node.visit(this));\n    template.references.forEach(node => this.visitReference(node));\n    this.ingestScopedNode(template);\n  }\n  visitVariable(variable) {\n    this.maybeDeclare(variable);\n  }\n  visitReference(reference) {\n    this.maybeDeclare(reference);\n  }\n  visitDeferredBlock(deferred) {\n    this.ingestScopedNode(deferred);\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockError(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockLoading(block) {\n    this.ingestScopedNode(block);\n  }\n  visitSwitchBlock(block) {\n    block.cases.forEach(node => node.visit(this));\n  }\n  visitSwitchBlockCase(block) {\n    this.ingestScopedNode(block);\n  }\n  visitForLoopBlock(block) {\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.ingestScopedNode(block);\n  }\n  visitIfBlock(block) {\n    block.branches.forEach(node => node.visit(this));\n  }\n  visitIfBlockBranch(block) {\n    this.ingestScopedNode(block);\n  }\n  visitContent(content) {\n    this.ingestScopedNode(content);\n  }\n  visitLetDeclaration(decl) {\n    this.maybeDeclare(decl);\n  }\n  visitComponent(component) {\n    this.visitElementLike(component);\n  }\n  visitDirective(directive) {\n    directive.references.forEach(current => this.visitReference(current));\n  }\n  visitBoundAttribute(attr) {}\n  visitBoundEvent(event) {}\n  visitBoundText(text) {}\n  visitText(text) {}\n  visitTextAttribute(attr) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitElementLike(node) {\n    node.directives.forEach(current => current.visit(this));\n    node.references.forEach(current => this.visitReference(current));\n    node.children.forEach(current => current.visit(this));\n    this.elementLikeInScope.add(node);\n  }\n  maybeDeclare(thing) {\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n  lookup(name) {\n    if (this.namedEntities.has(name)) {\n      return this.namedEntities.get(name);\n    } else if (this.parentScope !== null) {\n      return this.parentScope.lookup(name);\n    } else {\n      return null;\n    }\n  }\n  getChildScope(node) {\n    const res = this.childScopes.get(node);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${node} not found`);\n    }\n    return res;\n  }\n  ingestScopedNode(node) {\n    const scope = new Scope(this, node);\n    scope.ingest(node);\n    this.childScopes.set(node, scope);\n  }\n}\nclass DirectiveBinder {\n  directiveMatcher;\n  directives;\n  eagerDirectives;\n  missingDirectives;\n  bindings;\n  references;\n  isInDeferBlock = false;\n  constructor(directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references) {\n    this.directiveMatcher = directiveMatcher;\n    this.directives = directives;\n    this.eagerDirectives = eagerDirectives;\n    this.missingDirectives = missingDirectives;\n    this.bindings = bindings;\n    this.references = references;\n  }\n  static apply(template, directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references) {\n    const matcher = new DirectiveBinder(directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references);\n    matcher.ingest(template);\n  }\n  ingest(template) {\n    template.forEach(node => node.visit(this));\n  }\n  visitElement(element) {\n    this.visitElementOrTemplate(element);\n  }\n  visitTemplate(template) {\n    this.visitElementOrTemplate(template);\n  }\n  visitDeferredBlock(deferred) {\n    const wasInDeferBlock = this.isInDeferBlock;\n    this.isInDeferBlock = true;\n    deferred.children.forEach(child => child.visit(this));\n    this.isInDeferBlock = wasInDeferBlock;\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitDeferredBlockError(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitDeferredBlockLoading(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitSwitchBlock(block) {\n    block.cases.forEach(node => node.visit(this));\n  }\n  visitSwitchBlockCase(block) {\n    block.children.forEach(node => node.visit(this));\n  }\n  visitForLoopBlock(block) {\n    block.item.visit(this);\n    block.contextVariables.forEach(v => v.visit(this));\n    block.children.forEach(node => node.visit(this));\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    block.children.forEach(node => node.visit(this));\n  }\n  visitIfBlock(block) {\n    block.branches.forEach(node => node.visit(this));\n  }\n  visitIfBlockBranch(block) {\n    block.expressionAlias?.visit(this);\n    block.children.forEach(node => node.visit(this));\n  }\n  visitContent(content) {\n    content.children.forEach(child => child.visit(this));\n  }\n  visitComponent(node) {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const componentMatches = this.directiveMatcher.match(node.componentName);\n      if (componentMatches.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, componentMatches);\n      } else {\n        this.missingDirectives.add(node.componentName);\n      }\n    }\n    node.directives.forEach(directive => directive.visit(this));\n    node.children.forEach(child => child.visit(this));\n  }\n  visitDirective(node) {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const directives = this.directiveMatcher.match(node.name);\n      if (directives.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, directives);\n      } else {\n        this.missingDirectives.add(node.name);\n      }\n    }\n  }\n  visitElementOrTemplate(node) {\n    if (this.directiveMatcher instanceof SelectorMatcher) {\n      const directives = [];\n      const cssSelector = createCssSelectorFromNode(node);\n      this.directiveMatcher.match(cssSelector, (_, results) => directives.push(...results));\n      this.trackSelectorBasedBindingsAndDirectives(node, directives);\n    } else {\n      node.references.forEach(ref => {\n        if (ref.value.trim() === '') {\n          this.references.set(ref, node);\n        }\n      });\n    }\n    node.directives.forEach(directive => directive.visit(this));\n    node.children.forEach(child => child.visit(this));\n  }\n  trackMatchedDirectives(node, directives) {\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n      if (!this.isInDeferBlock) {\n        this.eagerDirectives.push(...directives);\n      }\n    }\n  }\n  trackSelectorlessMatchesAndDirectives(node, directives) {\n    if (directives.length === 0) {\n      return;\n    }\n    this.trackMatchedDirectives(node, directives);\n    const setBinding = (meta, attribute, ioType) => {\n      if (meta[ioType].hasBindingPropertyName(attribute.name)) {\n        this.bindings.set(attribute, meta);\n      }\n    };\n    for (const directive of directives) {\n      node.inputs.forEach(input => setBinding(directive, input, 'inputs'));\n      node.attributes.forEach(attr => setBinding(directive, attr, 'inputs'));\n      node.outputs.forEach(output => setBinding(directive, output, 'outputs'));\n    }\n    node.references.forEach(ref => this.references.set(ref, {\n      directive: directives[0],\n      node: node\n    }));\n  }\n  trackSelectorBasedBindingsAndDirectives(node, directives) {\n    this.trackMatchedDirectives(node, directives);\n    node.references.forEach(ref => {\n      let dirTarget = null;\n      if (ref.value.trim() === '') {\n        dirTarget = directives.find(dir => dir.isComponent) || null;\n      } else {\n        dirTarget = directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) || null;\n        if (dirTarget === null) {\n          return;\n        }\n      }\n      if (dirTarget !== null) {\n        this.references.set(ref, {\n          directive: dirTarget,\n          node\n        });\n      } else {\n        this.references.set(ref, node);\n      }\n    });\n    const setAttributeBinding = (attribute, ioType) => {\n      const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n      const binding = dir !== undefined ? dir : node;\n      this.bindings.set(attribute, binding);\n    };\n    node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n    node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    if (node instanceof Template) {\n      node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    }\n    node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitBoundAttribute(attribute) {}\n  visitBoundEvent(attribute) {}\n  visitBoundAttributeOrEvent(node) {}\n  visitText(text) {}\n  visitBoundText(text) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitLetDeclaration(decl) {}\n}\nclass TemplateBinder extends CombinedRecursiveAstVisitor {\n  bindings;\n  symbols;\n  usedPipes;\n  eagerPipes;\n  deferBlocks;\n  nestingLevel;\n  scope;\n  rootNode;\n  level;\n  visitNode = node => node.visit(this);\n  constructor(bindings, symbols, usedPipes, eagerPipes, deferBlocks, nestingLevel, scope, rootNode, level) {\n    super();\n    this.bindings = bindings;\n    this.symbols = symbols;\n    this.usedPipes = usedPipes;\n    this.eagerPipes = eagerPipes;\n    this.deferBlocks = deferBlocks;\n    this.nestingLevel = nestingLevel;\n    this.scope = scope;\n    this.rootNode = rootNode;\n    this.level = level;\n  }\n  static applyWithScope(nodeOrNodes, scope, expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks) {\n    const template = nodeOrNodes instanceof Template ? nodeOrNodes : null;\n    const binder = new TemplateBinder(expressions, symbols, usedPipes, eagerPipes, deferBlocks, nestingLevel, scope, template, 0);\n    binder.ingest(nodeOrNodes);\n  }\n  ingest(nodeOrNodes) {\n    if (nodeOrNodes instanceof Template) {\n      nodeOrNodes.variables.forEach(this.visitNode);\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitNode(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitNode(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach(v => this.visitNode(v));\n      nodeOrNodes.trackBy.visit(this);\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof DeferredBlock) {\n      if (this.scope.rootNode !== nodeOrNodes) {\n        throw new Error(`Assertion error: resolved incorrect scope for deferred block ${nodeOrNodes}`);\n      }\n      this.deferBlocks.push([nodeOrNodes, this.scope]);\n      nodeOrNodes.children.forEach(node => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof SwitchBlockCase || nodeOrNodes instanceof ForLoopBlockEmpty || nodeOrNodes instanceof DeferredBlockError || nodeOrNodes instanceof DeferredBlockPlaceholder || nodeOrNodes instanceof DeferredBlockLoading || nodeOrNodes instanceof Content) {\n      nodeOrNodes.children.forEach(node => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof HostElement) {\n      this.nestingLevel.set(nodeOrNodes, 0);\n    } else {\n      nodeOrNodes.forEach(this.visitNode);\n    }\n  }\n  visitTemplate(template) {\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n    template.directives.forEach(this.visitNode);\n    template.templateAttrs.forEach(this.visitNode);\n    template.references.forEach(this.visitNode);\n    this.ingestScopedNode(template);\n  }\n  visitVariable(variable) {\n    if (this.rootNode !== null) {\n      this.symbols.set(variable, this.rootNode);\n    }\n  }\n  visitReference(reference) {\n    if (this.rootNode !== null) {\n      this.symbols.set(reference, this.rootNode);\n    }\n  }\n  visitDeferredBlock(deferred) {\n    this.ingestScopedNode(deferred);\n    deferred.triggers.when?.value.visit(this);\n    deferred.prefetchTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.never?.visit(this);\n    deferred.placeholder && this.visitNode(deferred.placeholder);\n    deferred.loading && this.visitNode(deferred.loading);\n    deferred.error && this.visitNode(deferred.error);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockError(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockLoading(block) {\n    this.ingestScopedNode(block);\n  }\n  visitSwitchBlockCase(block) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n  visitForLoopBlock(block) {\n    block.expression.visit(this);\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.ingestScopedNode(block);\n  }\n  visitIfBlockBranch(block) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n  visitContent(content) {\n    this.ingestScopedNode(content);\n  }\n  visitLetDeclaration(decl) {\n    super.visitLetDeclaration(decl);\n    if (this.rootNode !== null) {\n      this.symbols.set(decl, this.rootNode);\n    }\n  }\n  visitPipe(ast, context) {\n    this.usedPipes.add(ast.name);\n    if (!this.scope.isDeferred) {\n      this.eagerPipes.add(ast.name);\n    }\n    return super.visitPipe(ast, context);\n  }\n  visitPropertyRead(ast, context) {\n    this.maybeMap(ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n  visitSafePropertyRead(ast, context) {\n    this.maybeMap(ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n  ingestScopedNode(node) {\n    const childScope = this.scope.getChildScope(node);\n    const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.eagerPipes, this.deferBlocks, this.nestingLevel, childScope, node, this.level + 1);\n    binder.ingest(node);\n  }\n  maybeMap(ast, name) {\n    if (!(ast.receiver instanceof ImplicitReceiver) || ast.receiver instanceof ThisReceiver) {\n      return;\n    }\n    const target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\nclass R3BoundTarget {\n  target;\n  directives;\n  eagerDirectives;\n  missingDirectives;\n  bindings;\n  references;\n  exprTargets;\n  symbols;\n  nestingLevel;\n  scopedNodeEntities;\n  usedPipes;\n  eagerPipes;\n  deferredBlocks;\n  deferredScopes;\n  constructor(target, directives, eagerDirectives, missingDirectives, bindings, references, exprTargets, symbols, nestingLevel, scopedNodeEntities, usedPipes, eagerPipes, rawDeferred) {\n    this.target = target;\n    this.directives = directives;\n    this.eagerDirectives = eagerDirectives;\n    this.missingDirectives = missingDirectives;\n    this.bindings = bindings;\n    this.references = references;\n    this.exprTargets = exprTargets;\n    this.symbols = symbols;\n    this.nestingLevel = nestingLevel;\n    this.scopedNodeEntities = scopedNodeEntities;\n    this.usedPipes = usedPipes;\n    this.eagerPipes = eagerPipes;\n    this.deferredBlocks = rawDeferred.map(current => current[0]);\n    this.deferredScopes = new Map(rawDeferred);\n  }\n  getEntitiesInScope(node) {\n    return this.scopedNodeEntities.get(node) ?? new Set();\n  }\n  getDirectivesOfNode(node) {\n    return this.directives.get(node) || null;\n  }\n  getReferenceTarget(ref) {\n    return this.references.get(ref) || null;\n  }\n  getConsumerOfBinding(binding) {\n    return this.bindings.get(binding) || null;\n  }\n  getExpressionTarget(expr) {\n    return this.exprTargets.get(expr) || null;\n  }\n  getDefinitionNodeOfSymbol(symbol) {\n    return this.symbols.get(symbol) || null;\n  }\n  getNestingLevel(node) {\n    return this.nestingLevel.get(node) || 0;\n  }\n  getUsedDirectives() {\n    const set = new Set();\n    this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n    return Array.from(set.values());\n  }\n  getEagerlyUsedDirectives() {\n    const set = new Set(this.eagerDirectives);\n    return Array.from(set.values());\n  }\n  getUsedPipes() {\n    return Array.from(this.usedPipes);\n  }\n  getEagerlyUsedPipes() {\n    return Array.from(this.eagerPipes);\n  }\n  getDeferBlocks() {\n    return this.deferredBlocks;\n  }\n  getDeferredTriggerTarget(block, trigger) {\n    if (!(trigger instanceof InteractionDeferredTrigger) && !(trigger instanceof ViewportDeferredTrigger) && !(trigger instanceof HoverDeferredTrigger)) {\n      return null;\n    }\n    const name = trigger.reference;\n    if (name === null) {\n      let target = null;\n      if (block.placeholder !== null) {\n        for (const child of block.placeholder.children) {\n          if (child instanceof Comment$1) {\n            continue;\n          }\n          if (target !== null) {\n            return null;\n          }\n          if (child instanceof Element$1) {\n            target = child;\n          }\n        }\n      }\n      return target;\n    }\n    const outsideRef = this.findEntityInScope(block, name);\n    if (outsideRef instanceof Reference && this.getDefinitionNodeOfSymbol(outsideRef) !== block) {\n      const target = this.getReferenceTarget(outsideRef);\n      if (target !== null) {\n        return this.referenceTargetToElement(target);\n      }\n    }\n    if (block.placeholder !== null) {\n      const refInPlaceholder = this.findEntityInScope(block.placeholder, name);\n      const targetInPlaceholder = refInPlaceholder instanceof Reference ? this.getReferenceTarget(refInPlaceholder) : null;\n      if (targetInPlaceholder !== null) {\n        return this.referenceTargetToElement(targetInPlaceholder);\n      }\n    }\n    return null;\n  }\n  isDeferred(element) {\n    for (const block of this.deferredBlocks) {\n      if (!this.deferredScopes.has(block)) {\n        continue;\n      }\n      const stack = [this.deferredScopes.get(block)];\n      while (stack.length > 0) {\n        const current = stack.pop();\n        if (current.elementLikeInScope.has(element)) {\n          return true;\n        }\n        stack.push(...current.childScopes.values());\n      }\n    }\n    return false;\n  }\n  referencedDirectiveExists(name) {\n    return !this.missingDirectives.has(name);\n  }\n  findEntityInScope(rootNode, name) {\n    const entities = this.getEntitiesInScope(rootNode);\n    for (const entity of entities) {\n      if (entity.name === name) {\n        return entity;\n      }\n    }\n    return null;\n  }\n  referenceTargetToElement(target) {\n    if (target instanceof Element$1) {\n      return target;\n    }\n    if (target instanceof Template || target.node instanceof Component$1 || target.node instanceof Directive$1 || target.node instanceof HostElement) {\n      return null;\n    }\n    return this.referenceTargetToElement(target.node);\n  }\n}\nfunction extractScopedNodeEntities(rootScope, templateEntities) {\n  const entityMap = new Map();\n  function extractScopeEntities(scope) {\n    if (entityMap.has(scope.rootNode)) {\n      return entityMap.get(scope.rootNode);\n    }\n    const currentEntities = scope.namedEntities;\n    let entities;\n    if (scope.parentScope !== null) {\n      entities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n    } else {\n      entities = new Map(currentEntities);\n    }\n    entityMap.set(scope.rootNode, entities);\n    return entities;\n  }\n  const scopesToProcess = [rootScope];\n  while (scopesToProcess.length > 0) {\n    const scope = scopesToProcess.pop();\n    for (const childScope of scope.childScopes.values()) {\n      scopesToProcess.push(childScope);\n    }\n    extractScopeEntities(scope);\n  }\n  for (const [template, entities] of entityMap) {\n    templateEntities.set(template, new Set(entities.values()));\n  }\n}\nclass ResourceLoader {}\nclass CompilerFacadeImpl {\n  jitEvaluator;\n  FactoryTarget = FactoryTarget;\n  ResourceLoader = ResourceLoader;\n  elementSchemaRegistry = new DomElementSchemaRegistry();\n  constructor(jitEvaluator = new JitEvaluator()) {\n    this.jitEvaluator = jitEvaluator;\n  }\n  compilePipe(angularCoreEnv, sourceMapUrl, facade) {\n    const metadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: 0,\n      deps: null,\n      pipeName: facade.pipeName,\n      pure: facade.pure,\n      isStandalone: facade.isStandalone\n    };\n    const res = compilePipeFromMetadata(metadata);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const meta = convertDeclarePipeFacadeToMetadata(declaration);\n    const res = compilePipeFromMetadata(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileInjectable(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      expression,\n      statements\n    } = compileInjectable({\n      name: facade.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: facade.typeArgumentCount,\n      providedIn: computeProvidedIn(facade.providedIn),\n      useClass: convertToProviderExpression(facade, 'useClass'),\n      useFactory: wrapExpression(facade, 'useFactory'),\n      useValue: convertToProviderExpression(facade, 'useValue'),\n      useExisting: convertToProviderExpression(facade, 'useExisting'),\n      deps: facade.deps?.map(convertR3DependencyMetadata)\n    }, true);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n  compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      expression,\n      statements\n    } = compileInjectable({\n      name: facade.type.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: 0,\n      providedIn: computeProvidedIn(facade.providedIn),\n      useClass: convertToProviderExpression(facade, 'useClass'),\n      useFactory: wrapExpression(facade, 'useFactory'),\n      useValue: convertToProviderExpression(facade, 'useValue'),\n      useExisting: convertToProviderExpression(facade, 'useExisting'),\n      deps: facade.deps?.map(convertR3DeclareDependencyMetadata)\n    }, true);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n  compileInjector(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      providers: facade.providers && facade.providers.length > 0 ? new WrappedNodeExpr(facade.providers) : null,\n      imports: facade.imports.map(i => new WrappedNodeExpr(i))\n    };\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileNgModule(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = {\n      kind: R3NgModuleMetadataKind.Global,\n      type: wrapReference(facade.type),\n      bootstrap: facade.bootstrap.map(wrapReference),\n      declarations: facade.declarations.map(wrapReference),\n      publicDeclarationTypes: null,\n      imports: facade.imports.map(wrapReference),\n      includeImportTypes: true,\n      exports: facade.exports.map(wrapReference),\n      selectorScopeMode: R3SelectorScopeMode.Inline,\n      containsForwardDecls: false,\n      schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n      id: facade.id ? new WrappedNodeExpr(facade.id) : null\n    };\n    const res = compileNgModule(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const expression = compileNgModuleDeclarationExpression(declaration);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileDirective(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = convertDirectiveFacadeToMetadata(facade);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n  compileComponent(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      template,\n      defer\n    } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, undefined);\n    const meta = {\n      ...facade,\n      ...convertDirectiveFacadeToMetadata(facade),\n      selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n      template,\n      declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),\n      declarationListEmitMode: 0,\n      defer,\n      styles: [...facade.styles, ...template.styles],\n      encapsulation: facade.encapsulation,\n      changeDetection: facade.changeDetection ?? null,\n      animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n      viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,\n      relativeContextFilePath: '',\n      i18nUseExternalIds: true,\n      relativeTemplatePath: null\n    };\n    const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n    return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n  }\n  compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n    return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n  compileFactory(angularCoreEnv, sourceMapUrl, meta) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: meta.typeArgumentCount,\n      deps: convertR3DependencyMetadataArray(meta.deps),\n      target: meta.target\n    });\n    return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n  compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.type.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: 0,\n      deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) : meta.deps,\n      target: meta.target\n    });\n    return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n  createParseSourceSpan(kind, typeName, sourceUrl) {\n    return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n  }\n  jitExpression(def, context, sourceUrl, preStatements) {\n    const statements = [...preStatements, new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported)];\n    const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), true);\n    return res['$def'];\n  }\n}\nfunction convertToR3QueryMetadata(facade) {\n  return {\n    ...facade,\n    isSignal: facade.isSignal,\n    predicate: convertQueryPredicate(facade.predicate),\n    read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n    static: facade.static,\n    emitDistinctChangesOnly: facade.emitDistinctChangesOnly\n  };\n}\nfunction convertQueryDeclarationToMetadata(declaration) {\n  return {\n    propertyName: declaration.propertyName,\n    first: declaration.first ?? false,\n    predicate: convertQueryPredicate(declaration.predicate),\n    descendants: declaration.descendants ?? false,\n    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n    static: declaration.static ?? false,\n    emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true,\n    isSignal: !!declaration.isSignal\n  };\n}\nfunction convertQueryPredicate(predicate) {\n  return Array.isArray(predicate) ? predicate : createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1);\n}\nfunction convertDirectiveFacadeToMetadata(facade) {\n  const inputsFromMetadata = parseInputsArray(facade.inputs || []);\n  const outputsFromMetadata = parseMappingStringArray(facade.outputs || []);\n  const propMetadata = facade.propMetadata;\n  const inputsFromType = {};\n  const outputsFromType = {};\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isInput(ann)) {\n          inputsFromType[field] = {\n            bindingPropertyName: ann.alias || field,\n            classPropertyName: field,\n            required: ann.required || false,\n            isSignal: !!ann.isSignal,\n            transformFunction: ann.transform != null ? new WrappedNodeExpr(ann.transform) : null\n          };\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.alias || field;\n        }\n      });\n    }\n  }\n  const hostDirectives = facade.hostDirectives?.length ? facade.hostDirectives.map(hostDirective => {\n    return typeof hostDirective === 'function' ? {\n      directive: wrapReference(hostDirective),\n      inputs: null,\n      outputs: null,\n      isForwardReference: false\n    } : {\n      directive: wrapReference(hostDirective.directive),\n      isForwardReference: false,\n      inputs: hostDirective.inputs ? parseMappingStringArray(hostDirective.inputs) : null,\n      outputs: hostDirective.outputs ? parseMappingStringArray(hostDirective.outputs) : null\n    };\n  }) : null;\n  return {\n    ...facade,\n    typeArgumentCount: 0,\n    typeSourceSpan: facade.typeSourceSpan,\n    type: wrapReference(facade.type),\n    deps: null,\n    host: {\n      ...extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host)\n    },\n    inputs: {\n      ...inputsFromMetadata,\n      ...inputsFromType\n    },\n    outputs: {\n      ...outputsFromMetadata,\n      ...outputsFromType\n    },\n    queries: facade.queries.map(convertToR3QueryMetadata),\n    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n    hostDirectives\n  };\n}\nfunction convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\n  const hostDirectives = declaration.hostDirectives?.length ? declaration.hostDirectives.map(dir => ({\n    directive: wrapReference(dir.directive),\n    isForwardReference: false,\n    inputs: dir.inputs ? getHostDirectiveBindingMapping(dir.inputs) : null,\n    outputs: dir.outputs ? getHostDirectiveBindingMapping(dir.outputs) : null\n  })) : null;\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeSourceSpan,\n    selector: declaration.selector ?? null,\n    inputs: declaration.inputs ? inputsPartialMetadataToInputMetadata(declaration.inputs) : {},\n    outputs: declaration.outputs ?? {},\n    host: convertHostDeclarationToMetadata(declaration.host),\n    queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),\n    viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),\n    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) : null,\n    exportAs: declaration.exportAs ?? null,\n    usesInheritance: declaration.usesInheritance ?? false,\n    lifecycle: {\n      usesOnChanges: declaration.usesOnChanges ?? false\n    },\n    deps: null,\n    typeArgumentCount: 0,\n    isStandalone: declaration.isStandalone ?? getJitStandaloneDefaultForVersion(declaration.version),\n    isSignal: declaration.isSignal ?? false,\n    hostDirectives\n  };\n}\nfunction convertHostDeclarationToMetadata(host = {}) {\n  return {\n    attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),\n    listeners: host.listeners ?? {},\n    properties: host.properties ?? {},\n    specialAttributes: {\n      classAttr: host.classAttribute,\n      styleAttr: host.styleAttribute\n    }\n  };\n}\nfunction getHostDirectiveBindingMapping(array) {\n  let result = null;\n  for (let i = 1; i < array.length; i += 2) {\n    result = result || {};\n    result[array[i - 1]] = array[i];\n  }\n  return result;\n}\nfunction convertOpaqueValuesToExpressions(obj) {\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = new WrappedNodeExpr(obj[key]);\n  }\n  return result;\n}\nfunction convertDeclareComponentFacadeToMetadata(decl, typeSourceSpan, sourceMapUrl) {\n  const {\n    template,\n    defer\n  } = parseJitTemplate(decl.template, decl.type.name, sourceMapUrl, decl.preserveWhitespaces ?? false, decl.deferBlockDependencies);\n  const declarations = [];\n  if (decl.dependencies) {\n    for (const innerDep of decl.dependencies) {\n      switch (innerDep.kind) {\n        case 'directive':\n        case 'component':\n          declarations.push(convertDirectiveDeclarationToMetadata(innerDep));\n          break;\n        case 'pipe':\n          declarations.push(convertPipeDeclarationToMetadata(innerDep));\n          break;\n      }\n    }\n  } else if (decl.components || decl.directives || decl.pipes) {\n    decl.components && declarations.push(...decl.components.map(dir => convertDirectiveDeclarationToMetadata(dir, true)));\n    decl.directives && declarations.push(...decl.directives.map(dir => convertDirectiveDeclarationToMetadata(dir)));\n    decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));\n  }\n  const hasDirectiveDependencies = declarations.some(({\n    kind\n  }) => kind === R3TemplateDependencyKind.Directive || kind === R3TemplateDependencyKind.NgModule);\n  return {\n    ...convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan),\n    template,\n    styles: decl.styles ?? [],\n    declarations,\n    viewProviders: decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) : null,\n    animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null,\n    defer,\n    changeDetection: decl.changeDetection ?? ChangeDetectionStrategy.Default,\n    encapsulation: decl.encapsulation ?? ViewEncapsulation$1.Emulated,\n    declarationListEmitMode: 2,\n    relativeContextFilePath: '',\n    i18nUseExternalIds: true,\n    relativeTemplatePath: null,\n    hasDirectiveDependencies\n  };\n}\nfunction convertDeclarationFacadeToMetadata(declaration) {\n  return {\n    ...declaration,\n    type: new WrappedNodeExpr(declaration.type)\n  };\n}\nfunction convertDirectiveDeclarationToMetadata(declaration, isComponent = null) {\n  return {\n    kind: R3TemplateDependencyKind.Directive,\n    isComponent: isComponent || declaration.kind === 'component',\n    selector: declaration.selector,\n    type: new WrappedNodeExpr(declaration.type),\n    inputs: declaration.inputs ?? [],\n    outputs: declaration.outputs ?? [],\n    exportAs: declaration.exportAs ?? null\n  };\n}\nfunction convertPipeMapToMetadata(pipes) {\n  if (!pipes) {\n    return [];\n  }\n  return Object.keys(pipes).map(name => {\n    return {\n      kind: R3TemplateDependencyKind.Pipe,\n      name,\n      type: new WrappedNodeExpr(pipes[name])\n    };\n  });\n}\nfunction convertPipeDeclarationToMetadata(pipe) {\n  return {\n    kind: R3TemplateDependencyKind.Pipe,\n    name: pipe.name,\n    type: new WrappedNodeExpr(pipe.type)\n  };\n}\nfunction parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, deferBlockDependencies) {\n  const parsed = parseTemplate(template, sourceMapUrl, {\n    preserveWhitespaces\n  });\n  if (parsed.errors !== null) {\n    const errors = parsed.errors.map(err => err.toString()).join(', ');\n    throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n  }\n  const binder = new R3TargetBinder(null);\n  const boundTarget = binder.bind({\n    template: parsed.nodes\n  });\n  return {\n    template: parsed,\n    defer: createR3ComponentDeferMetadata(boundTarget, deferBlockDependencies)\n  };\n}\nfunction convertToProviderExpression(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0);\n  } else {\n    return undefined;\n  }\n}\nfunction wrapExpression(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return new WrappedNodeExpr(obj[property]);\n  } else {\n    return undefined;\n  }\n}\nfunction computeProvidedIn(providedIn) {\n  const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) : new LiteralExpr(providedIn ?? null);\n  return createMayBeForwardRefExpression(expression, 0);\n}\nfunction convertR3DependencyMetadataArray(facades) {\n  return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\nfunction convertR3DependencyMetadata(facade) {\n  const isAttributeDep = facade.attribute != null;\n  const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n  return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\nfunction convertR3DeclareDependencyMetadata(facade) {\n  const isAttributeDep = facade.attribute ?? false;\n  const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  return createR3DependencyMetadata(token, isAttributeDep, facade.host ?? false, facade.optional ?? false, facade.self ?? false, facade.skipSelf ?? false);\n}\nfunction createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {\n  const attributeNameType = isAttributeDep ? literal('unknown') : null;\n  return {\n    token,\n    attributeNameType,\n    host,\n    optional,\n    self,\n    skipSelf\n  };\n}\nfunction createR3ComponentDeferMetadata(boundTarget, deferBlockDependencies) {\n  const deferredBlocks = boundTarget.getDeferBlocks();\n  const blocks = new Map();\n  for (let i = 0; i < deferredBlocks.length; i++) {\n    const dependencyFn = deferBlockDependencies?.[i];\n    blocks.set(deferredBlocks[i], dependencyFn ? new WrappedNodeExpr(dependencyFn) : null);\n  }\n  return {\n    mode: 0,\n    blocks\n  };\n}\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n  const bindings = parseHostBindings(host || {});\n  const errors = verifyHostBindings(bindings, sourceSpan);\n  if (errors.length) {\n    throw new Error(errors.map(error => error.msg).join('\\n'));\n  }\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isHostBinding(ann)) {\n          bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString('this', field);\n        } else if (isHostListener(ann)) {\n          bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n        }\n      });\n    }\n  }\n  return bindings;\n}\nfunction isHostBinding(value) {\n  return value.ngMetadataName === 'HostBinding';\n}\nfunction isHostListener(value) {\n  return value.ngMetadataName === 'HostListener';\n}\nfunction isInput(value) {\n  return value.ngMetadataName === 'Input';\n}\nfunction isOutput(value) {\n  return value.ngMetadataName === 'Output';\n}\nfunction inputsPartialMetadataToInputMetadata(inputs) {\n  return Object.keys(inputs).reduce((result, minifiedClassName) => {\n    const value = inputs[minifiedClassName];\n    if (typeof value === 'string' || Array.isArray(value)) {\n      result[minifiedClassName] = parseLegacyInputPartialOutput(value);\n    } else {\n      result[minifiedClassName] = {\n        bindingPropertyName: value.publicName,\n        classPropertyName: minifiedClassName,\n        transformFunction: value.transformFunction !== null ? new WrappedNodeExpr(value.transformFunction) : null,\n        required: value.isRequired,\n        isSignal: value.isSignal\n      };\n    }\n    return result;\n  }, {});\n}\nfunction parseLegacyInputPartialOutput(value) {\n  if (typeof value === 'string') {\n    return {\n      bindingPropertyName: value,\n      classPropertyName: value,\n      transformFunction: null,\n      required: false,\n      isSignal: false\n    };\n  }\n  return {\n    bindingPropertyName: value[0],\n    classPropertyName: value[1],\n    transformFunction: value[2] ? new WrappedNodeExpr(value[2]) : null,\n    required: false,\n    isSignal: false\n  };\n}\nfunction parseInputsArray(values) {\n  return values.reduce((results, value) => {\n    if (typeof value === 'string') {\n      const [bindingPropertyName, classPropertyName] = parseMappingString(value);\n      results[classPropertyName] = {\n        bindingPropertyName,\n        classPropertyName,\n        required: false,\n        isSignal: false,\n        transformFunction: null\n      };\n    } else {\n      results[value.name] = {\n        bindingPropertyName: value.alias || value.name,\n        classPropertyName: value.name,\n        required: value.required || false,\n        isSignal: false,\n        transformFunction: value.transform != null ? new WrappedNodeExpr(value.transform) : null\n      };\n    }\n    return results;\n  }, {});\n}\nfunction parseMappingStringArray(values) {\n  return values.reduce((results, value) => {\n    const [alias, fieldName] = parseMappingString(value);\n    results[fieldName] = alias;\n    return results;\n  }, {});\n}\nfunction parseMappingString(value) {\n  const [fieldName, bindingPropertyName] = value.split(':', 2).map(str => str.trim());\n  return [bindingPropertyName ?? fieldName, fieldName];\n}\nfunction convertDeclarePipeFacadeToMetadata(declaration) {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeArgumentCount: 0,\n    pipeName: declaration.name,\n    deps: null,\n    pure: declaration.pure ?? true,\n    isStandalone: declaration.isStandalone ?? getJitStandaloneDefaultForVersion(declaration.version)\n  };\n}\nfunction convertDeclareInjectorFacadeToMetadata(declaration) {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    providers: declaration.providers !== undefined && declaration.providers.length > 0 ? new WrappedNodeExpr(declaration.providers) : null,\n    imports: declaration.imports !== undefined ? declaration.imports.map(i => new WrappedNodeExpr(i)) : []\n  };\n}\nfunction publishFacade(global) {\n  const ng = global.ng || (global.ng = {});\n  ng.ÉµcompilerFacade = new CompilerFacadeImpl();\n}\nclass CompilerConfig {\n  defaultEncapsulation;\n  preserveWhitespaces;\n  strictInjectionParameters;\n  constructor({\n    defaultEncapsulation = ViewEncapsulation$1.Emulated,\n    preserveWhitespaces,\n    strictInjectionParameters\n  } = {}) {\n    this.defaultEncapsulation = defaultEncapsulation;\n    this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n    this.strictInjectionParameters = strictInjectionParameters === true;\n  }\n}\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {\n  return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\nfunction extractMessages(nodes, implicitTags, implicitAttrs, preserveSignificantWhitespace) {\n  const visitor = new _Visitor(implicitTags, implicitAttrs, preserveSignificantWhitespace);\n  return visitor.extract(nodes);\n}\nfunction mergeTranslations(nodes, translations, implicitTags, implicitAttrs) {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.merge(nodes, translations);\n}\nclass ExtractionResult {\n  messages;\n  errors;\n  constructor(messages, errors) {\n    this.messages = messages;\n    this.errors = errors;\n  }\n}\nvar _VisitorMode = /*#__PURE__*/function (_VisitorMode) {\n  _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n  _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n  return _VisitorMode;\n}(_VisitorMode || {});\nclass _Visitor {\n  _implicitTags;\n  _implicitAttrs;\n  _preserveSignificantWhitespace;\n  _depth;\n  _inI18nNode;\n  _inImplicitNode;\n  _inI18nBlock;\n  _blockMeaningAndDesc;\n  _blockChildren;\n  _blockStartDepth;\n  _inIcu;\n  _msgCountAtSectionStart;\n  _errors;\n  _mode;\n  _messages;\n  _translations;\n  _createI18nMessage;\n  constructor(_implicitTags, _implicitAttrs, _preserveSignificantWhitespace = true) {\n    this._implicitTags = _implicitTags;\n    this._implicitAttrs = _implicitAttrs;\n    this._preserveSignificantWhitespace = _preserveSignificantWhitespace;\n  }\n  extract(nodes) {\n    this._init(_VisitorMode.Extract);\n    nodes.forEach(node => node.visit(this, null));\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n    return new ExtractionResult(this._messages, this._errors);\n  }\n  merge(nodes, translations) {\n    this._init(_VisitorMode.Merge);\n    this._translations = translations;\n    const wrapper = new Element('wrapper', [], [], nodes, false, undefined, undefined, undefined, false);\n    const translatedNode = wrapper.visit(this, null);\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n    return new ParseTreeResult(translatedNode.children, this._errors);\n  }\n  visitExpansionCase(icuCase, context) {\n    const expression = visitAll(this, icuCase.expression, context);\n    if (this._mode === _VisitorMode.Merge) {\n      return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n    }\n  }\n  visitExpansion(icu, context) {\n    this._mayBeAddBlockChildren(icu);\n    const wasInIcu = this._inIcu;\n    if (!this._inIcu) {\n      if (this._isInTranslatableSection) {\n        this._addMessage([icu]);\n      }\n      this._inIcu = true;\n    }\n    const cases = visitAll(this, icu.cases, context);\n    if (this._mode === _VisitorMode.Merge) {\n      icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n    this._inIcu = wasInIcu;\n    return icu;\n  }\n  visitComment(comment, context) {\n    const isOpening = _isOpeningComment(comment);\n    if (isOpening && this._isInTranslatableSection) {\n      this._reportError(comment, 'Could not start a block inside a translatable section');\n      return;\n    }\n    const isClosing = _isClosingComment(comment);\n    if (isClosing && !this._inI18nBlock) {\n      this._reportError(comment, 'Trying to close an unopened block');\n      return;\n    }\n    if (!this._inI18nNode && !this._inIcu) {\n      if (!this._inI18nBlock) {\n        if (isOpening) {\n          if (!i18nCommentsWarned && console && console.warn) {\n            i18nCommentsWarned = true;\n            const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n            console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);\n          }\n          this._inI18nBlock = true;\n          this._blockStartDepth = this._depth;\n          this._blockChildren = [];\n          this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n          this._openTranslatableSection(comment);\n        }\n      } else {\n        if (isClosing) {\n          if (this._depth == this._blockStartDepth) {\n            this._closeTranslatableSection(comment, this._blockChildren);\n            this._inI18nBlock = false;\n            const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n            const nodes = this._translateMessage(comment, message);\n            return visitAll(this, nodes);\n          } else {\n            this._reportError(comment, 'I18N blocks should not cross element boundaries');\n            return;\n          }\n        }\n      }\n    }\n  }\n  visitText(text, context) {\n    if (this._isInTranslatableSection) {\n      this._mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n  visitElement(el, context) {\n    return this._visitElementLike(el, context);\n  }\n  visitAttribute(attribute, context) {\n    throw new Error('unreachable code');\n  }\n  visitBlock(block, context) {\n    visitAll(this, block.children, context);\n  }\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    return this._visitElementLike(component, context);\n  }\n  visitDirective(directive, context) {\n    throw new Error('unreachable code');\n  }\n  _init(mode) {\n    this._mode = mode;\n    this._inI18nBlock = false;\n    this._inI18nNode = false;\n    this._depth = 0;\n    this._inIcu = false;\n    this._msgCountAtSectionStart = undefined;\n    this._errors = [];\n    this._messages = [];\n    this._inImplicitNode = false;\n    this._createI18nMessage = createI18nMessageFactory(!this._preserveSignificantWhitespace, this._preserveSignificantWhitespace);\n  }\n  _visitElementLike(node, context) {\n    this._mayBeAddBlockChildren(node);\n    this._depth++;\n    const wasInI18nNode = this._inI18nNode;\n    const wasInImplicitNode = this._inImplicitNode;\n    let childNodes = [];\n    let translatedChildNodes = undefined;\n    const nodeName = node instanceof Component ? node.tagName : node.name;\n    const i18nAttr = _getI18nAttr(node);\n    const i18nMeta = i18nAttr ? i18nAttr.value : '';\n    const isImplicit = this._implicitTags.some(tag => nodeName === tag) && !this._inIcu && !this._isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this._inImplicitNode = wasInImplicitNode || isImplicit;\n    if (!this._isInTranslatableSection && !this._inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._inI18nNode = true;\n        const message = this._addMessage(node.children, i18nMeta);\n        translatedChildNodes = this._translateMessage(node, message);\n      }\n      if (this._mode == _VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) this._openTranslatableSection(node);\n        visitAll(this, node.children);\n        if (isTranslatable) this._closeTranslatableSection(node, node.children);\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(node, 'Could not mark an element as translatable inside a translatable section');\n      }\n      if (this._mode == _VisitorMode.Extract) {\n        visitAll(this, node.children);\n      }\n    }\n    if (this._mode === _VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || node.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this._isInTranslatableSection) {\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n    this._visitAttributesOf(node);\n    this._depth--;\n    this._inI18nNode = wasInI18nNode;\n    this._inImplicitNode = wasInImplicitNode;\n    if (this._mode === _VisitorMode.Merge) {\n      if (node instanceof Element) {\n        return new Element(node.name, this._translateAttributes(node), this._translateDirectives(node), childNodes, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.isVoid);\n      } else {\n        return new Component(node.componentName, node.tagName, node.fullName, this._translateAttributes(node), this._translateDirectives(node), childNodes, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan);\n      }\n    }\n    return null;\n  }\n  _visitAttributesOf(el) {\n    const explicitAttrNameToValue = {};\n    const implicitAttrNames = this._implicitAttrs[el instanceof Component ? el.tagName || '' : el.name] || [];\n    el.attrs.filter(attr => attr instanceof Attribute && attr.name.startsWith(_I18N_ATTR_PREFIX)).forEach(attr => {\n      explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;\n    });\n    el.attrs.forEach(attr => {\n      if (attr.name in explicitAttrNameToValue) {\n        this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n      } else if (implicitAttrNames.some(name => attr.name === name)) {\n        this._addMessage([attr]);\n      }\n    });\n  }\n  _addMessage(ast, msgMeta) {\n    if (ast.length == 0 || this._isEmptyAttributeValue(ast) || this._isPlaceholderOnlyAttributeValue(ast) || this._isPlaceholderOnlyMessage(ast)) {\n      return null;\n    }\n    const {\n      meaning,\n      description,\n      id\n    } = _parseMessageMeta(msgMeta);\n    const message = this._createI18nMessage(ast, meaning, description, id);\n    this._messages.push(message);\n    return message;\n  }\n  _isEmptyAttributeValue(ast) {\n    if (!isAttrNode(ast)) return false;\n    const node = ast[0];\n    return node.value.trim() === '';\n  }\n  _isPlaceholderOnlyAttributeValue(ast) {\n    if (!isAttrNode(ast)) return false;\n    const tokens = ast[0].valueTokens ?? [];\n    const interpolations = tokens.filter(token => token.type === 17);\n    const plainText = tokens.filter(token => token.type === 16).map(token => token.parts[0].trim()).join('');\n    return interpolations.length === 1 && plainText === '';\n  }\n  _isPlaceholderOnlyMessage(ast) {\n    if (!isTextNode(ast)) return false;\n    const tokens = ast[0].tokens;\n    const interpolations = tokens.filter(token => token.type === 8);\n    const plainText = tokens.filter(token => token.type === 5).map(token => token.parts[0].trim()).join('');\n    return interpolations.length === 1 && plainText === '';\n  }\n  _translateMessage(el, message) {\n    if (message && this._mode === _VisitorMode.Merge) {\n      const nodes = this._translations.get(message);\n      if (nodes) {\n        return nodes;\n      }\n      this._reportError(el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n    }\n    return [];\n  }\n  _translateAttributes(node) {\n    const i18nParsedMessageMeta = {};\n    const translatedAttributes = [];\n    node.attrs.forEach(attr => {\n      if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(attr.value);\n      }\n    });\n    node.attrs.forEach(attr => {\n      if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        return;\n      }\n      if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n        const {\n          meaning,\n          description,\n          id\n        } = i18nParsedMessageMeta[attr.name];\n        const message = this._createI18nMessage([attr], meaning, description, id);\n        const nodes = this._translations.get(message);\n        if (nodes) {\n          if (nodes.length == 0) {\n            translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined, undefined, undefined, undefined));\n          } else if (nodes[0] instanceof Text) {\n            const value = nodes[0].value;\n            translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined, undefined, undefined, undefined));\n          } else {\n            this._reportError(node, `Unexpected translation for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n          }\n        } else {\n          this._reportError(node, `Translation unavailable for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n        }\n      } else {\n        translatedAttributes.push(attr);\n      }\n    });\n    return translatedAttributes;\n  }\n  _translateDirectives(node) {\n    return node.directives.map(dir => new Directive(dir.name, this._translateAttributes(dir), dir.sourceSpan, dir.startSourceSpan, dir.endSourceSpan));\n  }\n  _mayBeAddBlockChildren(node) {\n    if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n      this._blockChildren.push(node);\n    }\n  }\n  _openTranslatableSection(node) {\n    if (this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section start');\n    } else {\n      this._msgCountAtSectionStart = this._messages.length;\n    }\n  }\n  get _isInTranslatableSection() {\n    return this._msgCountAtSectionStart !== void 0;\n  }\n  _closeTranslatableSection(node, directChildren) {\n    if (!this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section end');\n      return;\n    }\n    const startIndex = this._msgCountAtSectionStart;\n    const significantChildren = directChildren.reduce((count, node) => count + (node instanceof Comment ? 0 : 1), 0);\n    if (significantChildren == 1) {\n      for (let i = this._messages.length - 1; i >= startIndex; i--) {\n        const ast = this._messages[i].nodes;\n        if (!(ast.length == 1 && ast[0] instanceof Text$2)) {\n          this._messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n    this._msgCountAtSectionStart = undefined;\n  }\n  _reportError(node, msg) {\n    this._errors.push(new ParseError(node.sourceSpan, msg));\n  }\n}\nfunction _isOpeningComment(n) {\n  return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\nfunction _isClosingComment(n) {\n  return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\nfunction _getI18nAttr(p) {\n  return p.attrs.find(attr => attr instanceof Attribute && attr.name === _I18N_ATTR) || null;\n}\nfunction _parseMessageMeta(i18n) {\n  if (!i18n) return {\n    meaning: '',\n    description: '',\n    id: ''\n  };\n  const idIndex = i18n.indexOf(ID_SEPARATOR);\n  const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n  const [meaningAndDesc, id] = idIndex > -1 ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n  const [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];\n  return {\n    meaning,\n    description,\n    id: id.trim()\n  };\n}\nfunction isTextNode(ast) {\n  return ast.length === 1 && ast[0] instanceof Text;\n}\nfunction isAttrNode(ast) {\n  return ast.length === 1 && ast[0] instanceof Attribute;\n}\nclass XmlTagDefinition {\n  closedByParent = false;\n  implicitNamespacePrefix = null;\n  isVoid = false;\n  ignoreFirstLf = false;\n  canSelfClose = true;\n  preventNamespaceInheritance = false;\n  requireExtraParent(currentParent) {\n    return false;\n  }\n  isClosedByChild(name) {\n    return false;\n  }\n  getContentType() {\n    return TagContentType.PARSABLE_DATA;\n  }\n}\nconst _TAG_DEFINITION = new XmlTagDefinition();\nfunction getXmlTagDefinition(tagName) {\n  return _TAG_DEFINITION;\n}\nclass XmlParser extends Parser$1 {\n  constructor() {\n    super(getXmlTagDefinition);\n  }\n  parse(source, url, options = {}) {\n    return super.parse(source, url, {\n      ...options,\n      tokenizeBlocks: false,\n      tokenizeLet: false,\n      selectorlessEnabled: false\n    });\n  }\n}\nconst _VERSION$1 = '1.2';\nconst _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:1.2';\nconst _DEFAULT_SOURCE_LANG$1 = 'en';\nconst _PLACEHOLDER_TAG$2 = 'x';\nconst _MARKER_TAG$1 = 'mrk';\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG$1 = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG$1 = 'target';\nconst _UNIT_TAG$1 = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\nclass Xliff extends Serializer {\n  write(messages, locale) {\n    const visitor = new _WriteVisitor$1();\n    const transUnits = [];\n    messages.forEach(message => {\n      let contextTags = [];\n      message.sources.forEach(source => {\n        let contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, {\n          purpose: 'location'\n        });\n        contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, {\n          'context-type': 'sourcefile'\n        }, [new Text$1(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, {\n          'context-type': 'linenumber'\n        }, [new Text$1(`${source.startLine}`)]), new CR(8));\n        contextTags.push(new CR(8), contextGroupTag);\n      });\n      const transUnit = new Tag(_UNIT_TAG$1, {\n        id: message.id,\n        datatype: 'html'\n      });\n      transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), ...contextTags);\n      if (message.description) {\n        transUnit.children.push(new CR(8), new Tag('note', {\n          priority: '1',\n          from: 'description'\n        }, [new Text$1(message.description)]));\n      }\n      if (message.meaning) {\n        transUnit.children.push(new CR(8), new Tag('note', {\n          priority: '1',\n          from: 'meaning'\n        }, [new Text$1(message.meaning)]));\n      }\n      transUnit.children.push(new CR(6));\n      transUnits.push(new CR(6), transUnit);\n    });\n    const body = new Tag('body', {}, [...transUnits, new CR(4)]);\n    const file = new Tag('file', {\n      'source-language': locale || _DEFAULT_SOURCE_LANG$1,\n      datatype: 'plaintext',\n      original: 'ng2.template'\n    }, [new CR(4), body, new CR(2)]);\n    const xliff = new Tag('xliff', {\n      version: _VERSION$1,\n      xmlns: _XMLNS$1\n    }, [new CR(2), file, new CR()]);\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), xliff, new CR()]);\n  }\n  load(content, url) {\n    const xliffParser = new XliffParser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xliffParser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n$2();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {\n        i18nNodes,\n        errors: e\n      } = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n    if (errors.length) {\n      throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return digest$1(message);\n  }\n}\nlet _WriteVisitor$1 = class _WriteVisitor {\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const ctype = getCtypeForTag(ph.tag);\n    if (ph.isVoid) {\n      return [new Tag(_PLACEHOLDER_TAG$2, {\n        id: ph.startName,\n        ctype,\n        'equiv-text': `<${ph.tag}/>`\n      })];\n    }\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.startName,\n      ctype,\n      'equiv-text': `<${ph.tag}>`\n    });\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.closeName,\n      ctype,\n      'equiv-text': `</${ph.tag}>`\n    });\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitPlaceholder(ph, context) {\n    return [new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.name,\n      'equiv-text': `{{${ph.value}}}`\n    })];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const ctype = `x-${ph.name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.startName,\n      ctype,\n      'equiv-text': `@${ph.name}`\n    });\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.closeName,\n      ctype,\n      'equiv-text': `}`\n    });\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ')}}`;\n    return [new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.name,\n      'equiv-text': equivText\n    })];\n  }\n  serialize(nodes) {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n};\nclass XliffParser {\n  _unitMlString;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xliff, url) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xliff, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes, null);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _UNIT_TAG$1:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG$1}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n      case _SOURCE_TAG$1:\n      case _SEGMENT_SOURCE_TAG:\n      case _ALT_TRANS_TAG:\n        break;\n      case _TARGET_TAG$1:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n      case _FILE_TAG:\n        const localeAttr = element.attrs.find(attr => attr.name === 'target-language');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        visitAll(this, element.children, null);\n        break;\n      default:\n        visitAll(this, element.children, null);\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {}\n  visitDirective(directive, context) {}\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nlet XmlToI18n$2 = class XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : [].concat(...visitAll(this, xmlIcu.rootNodes));\n    return {\n      i18nNodes: i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitElement(el, context) {\n    if (el.name === _PLACEHOLDER_TAG$2) {\n      const nameAttr = el.attrs.find(attr => attr.name === 'id');\n      if (nameAttr) {\n        return new Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n      this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"id\" attribute`);\n      return null;\n    }\n    if (el.name === _MARKER_TAG$1) {\n      return [].concat(...visitAll(this, el.children));\n    }\n    this._addError(el, `Unexpected tag`);\n    return null;\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: visitAll(this, icuCase.expression)\n    };\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n};\nfunction getCtypeForTag(tag) {\n  switch (tag.toLowerCase()) {\n    case 'br':\n      return 'lb';\n    case 'img':\n      return 'image';\n    default:\n      return `x-${tag}`;\n  }\n}\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG$1 = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\nclass Xliff2 extends Serializer {\n  write(messages, locale) {\n    const visitor = new _WriteVisitor();\n    const units = [];\n    messages.forEach(message => {\n      const unit = new Tag(_UNIT_TAG, {\n        id: message.id\n      });\n      const notes = new Tag('notes');\n      if (message.description || message.meaning) {\n        if (message.description) {\n          notes.children.push(new CR(8), new Tag('note', {\n            category: 'description'\n          }, [new Text$1(message.description)]));\n        }\n        if (message.meaning) {\n          notes.children.push(new CR(8), new Tag('note', {\n            category: 'meaning'\n          }, [new Text$1(message.meaning)]));\n        }\n      }\n      message.sources.forEach(source => {\n        notes.children.push(new CR(8), new Tag('note', {\n          category: 'location'\n        }, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n      notes.children.push(new CR(6));\n      unit.children.push(new CR(6), notes);\n      const segment = new Tag('segment');\n      segment.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(6));\n      unit.children.push(new CR(6), segment, new CR(4));\n      units.push(new CR(4), unit);\n    });\n    const file = new Tag('file', {\n      'original': 'ng.template',\n      id: 'ngi18n'\n    }, [...units, new CR(2)]);\n    const xliff = new Tag(_XLIFF_TAG, {\n      version: _VERSION,\n      xmlns: _XMLNS,\n      srcLang: locale || _DEFAULT_SOURCE_LANG\n    }, [new CR(2), file, new CR()]);\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), xliff, new CR()]);\n  }\n  load(content, url) {\n    const xliff2Parser = new Xliff2Parser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xliff2Parser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n$1();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {\n        i18nNodes,\n        errors: e\n      } = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n    if (errors.length) {\n      throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return decimalDigest(message);\n  }\n}\nclass _WriteVisitor {\n  _nextPlaceholderId = 0;\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const type = getTypeForTag(ph.tag);\n    if (ph.isVoid) {\n      const tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type: type,\n        disp: `<${ph.tag}/>`\n      });\n      return [tagPh];\n    }\n    const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`\n    });\n    const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach(node => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new Text$1(''));\n    }\n    return [tagPc];\n  }\n  visitPlaceholder(ph, context) {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new Tag(_PLACEHOLDER_TAG$1, {\n      id: idStr,\n      equiv: ph.name,\n      disp: `{{${ph.value}}}`\n    })];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: 'other',\n      dispStart: `@${ph.name}`,\n      dispEnd: `}`\n    });\n    const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach(node => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new Text$1(''));\n    }\n    return [tagPc];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const cases = Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ');\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new Tag(_PLACEHOLDER_TAG$1, {\n      id: idStr,\n      equiv: ph.name,\n      disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`\n    })];\n  }\n  serialize(nodes) {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\nclass Xliff2Parser {\n  _unitMlString;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xliff, url) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xliff, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes, null);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n      case _SOURCE_TAG:\n        break;\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n      case _XLIFF_TAG:\n        const localeAttr = element.attrs.find(attr => attr.name === 'trgLang');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        const versionAttr = element.attrs.find(attr => attr.name === 'version');\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== '2.0') {\n            this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n          } else {\n            visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        visitAll(this, element.children, null);\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {}\n  visitDirective(directive, context) {}\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nlet XmlToI18n$1 = class XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : [].concat(...visitAll(this, xmlIcu.rootNodes));\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitElement(el, context) {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG$1:\n        const nameAttr = el.attrs.find(attr => attr.name === 'equiv');\n        if (nameAttr) {\n          return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n        }\n        this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find(attr => attr.name === 'equivStart');\n        const endAttr = el.attrs.find(attr => attr.name === 'equivEnd');\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n          const nodes = [];\n          return nodes.concat(new Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new Placeholder('', endId, el.sourceSpan));\n        }\n        break;\n      case _MARKER_TAG:\n        return [].concat(...visitAll(this, el.children));\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...visitAll(this, icuCase.expression))\n    };\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n};\nfunction getTypeForTag(tag) {\n  switch (tag.toLowerCase()) {\n    case 'br':\n    case 'b':\n    case 'i':\n    case 'u':\n      return 'fmt';\n    case 'img':\n      return 'image';\n    case 'a':\n      return 'link';\n    default:\n      return 'other';\n  }\n}\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\nclass Xtb extends Serializer {\n  write(messages, locale) {\n    throw new Error('Unsupported');\n  }\n  load(content, url) {\n    const xtbParser = new XtbParser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xtbParser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const valueFn = function () {\n        const {\n          i18nNodes,\n          errors\n        } = converter.convert(msgIdToHtml[msgId], url);\n        if (errors.length) {\n          throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return i18nNodes;\n      };\n      createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n    });\n    if (errors.length) {\n      throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return digest(message);\n  }\n  createNameMapper(message) {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\nfunction createLazyProperty(messages, id, valueFn) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {\n        enumerable: true,\n        value\n      });\n      return value;\n    },\n    set: _ => {\n      throw new Error('Could not overwrite an XTB translation');\n    }\n  });\n}\nclass XtbParser {\n  _bundleDepth;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xtb, url) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xtb, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        const langAttr = element.attrs.find(attr => attr.name === 'lang');\n        if (langAttr) {\n          this._locale = langAttr.value;\n        }\n        visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan.end.offset;\n            const innerTextEnd = element.endSourceSpan.start.offset;\n            const content = element.startSourceSpan.start.file.content;\n            const innerText = content.slice(innerTextStart, innerTextEnd);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n      default:\n        this._addError(element, 'Unexpected tag');\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(block, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nclass XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : visitAll(this, xmlIcu.rootNodes);\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: visitAll(this, icuCase.expression)\n    };\n  }\n  visitElement(el, context) {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === 'name');\n      if (nameAttr) {\n        return new Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(block, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nclass TranslationBundle {\n  _i18nNodesByMsgId;\n  digest;\n  mapperFactory;\n  _i18nToHtml;\n  constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {\n    this._i18nNodesByMsgId = _i18nNodesByMsgId;\n    this.digest = digest;\n    this.mapperFactory = mapperFactory;\n    this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n  }\n  static load(content, url, serializer, missingTranslationStrategy, console) {\n    const {\n      locale,\n      i18nNodesByMsgId\n    } = serializer.load(content, url);\n    const digestFn = m => serializer.digest(m);\n    const mapperFactory = m => serializer.createNameMapper(m);\n    return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n  }\n  get(srcMsg) {\n    const html = this._i18nToHtml.convert(srcMsg);\n    if (html.errors.length) {\n      throw new Error(html.errors.join('\\n'));\n    }\n    return html.nodes;\n  }\n  has(srcMsg) {\n    return this.digest(srcMsg) in this._i18nNodesByMsgId;\n  }\n}\nclass I18nToHtmlVisitor {\n  _i18nNodesByMsgId;\n  _locale;\n  _digest;\n  _mapperFactory;\n  _missingTranslationStrategy;\n  _console;\n  _srcMsg;\n  _errors = [];\n  _contextStack = [];\n  _mapper;\n  constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n    this._i18nNodesByMsgId = _i18nNodesByMsgId;\n    this._locale = _locale;\n    this._digest = _digest;\n    this._mapperFactory = _mapperFactory;\n    this._missingTranslationStrategy = _missingTranslationStrategy;\n    this._console = _console;\n  }\n  convert(srcMsg) {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n    const text = this._convertToText(srcMsg);\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const html = new HtmlParser().parse(text, url, {\n      tokenizeExpansionForms: true\n    });\n    return {\n      nodes: html.rootNodes,\n      errors: [...this._errors, ...html.errors]\n    };\n  }\n  visitText(text, context) {\n    return escapeXml(text.value);\n  }\n  visitContainer(container, context) {\n    return container.children.map(n => n.visit(this)).join('');\n  }\n  visitIcu(icu, context) {\n    const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ? this._srcMsg.placeholders[icu.expression].text : icu.expression;\n    return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n  }\n  visitPlaceholder(ph, context) {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this._srcMsg.placeholders[phName].text;\n    }\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return '';\n  }\n  visitTagPlaceholder(ph, context) {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map(c => c.visit(this)).join('');\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n  visitBlockPlaceholder(ph, context) {\n    const params = ph.parameters.length === 0 ? '' : ` (${ph.parameters.join('; ')})`;\n    const children = ph.children.map(c => c.visit(this)).join('');\n    return `@${ph.name}${params} {${children}}`;\n  }\n  _convertToText(srcMsg) {\n    const id = this._digest(srcMsg);\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes;\n    this._contextStack.push({\n      msg: this._srcMsg,\n      mapper: this._mapper\n    });\n    this._srcMsg = srcMsg;\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = name => mapper ? mapper.toInternalName(name) : name;\n    } else {\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n      } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = name => name;\n    }\n    const text = nodes.map(node => node.visit(this)).join('');\n    const context = this._contextStack.pop();\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n  _addError(el, msg) {\n    this._errors.push(new ParseError(el.sourceSpan, msg));\n  }\n}\nclass I18NHtmlParser {\n  _htmlParser;\n  getTagDefinition;\n  _translationBundle;\n  constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {\n    this._htmlParser = _htmlParser;\n    if (translations) {\n      const serializer = createSerializer(translationsFormat);\n      this._translationBundle = TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n    } else {\n      this._translationBundle = new TranslationBundle({}, null, digest$1, undefined, missingTranslation, console);\n    }\n  }\n  parse(source, url, options = {}) {\n    const parseResult = this._htmlParser.parse(source, url, {\n      ...options\n    });\n    if (parseResult.errors.length) {\n      return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n    }\n    return mergeTranslations(parseResult.rootNodes, this._translationBundle, [], {});\n  }\n}\nfunction createSerializer(format) {\n  format = (format || 'xlf').toLowerCase();\n  switch (format) {\n    case 'xmb':\n      return new Xmb();\n    case 'xtb':\n      return new Xtb();\n    case 'xliff2':\n    case 'xlf2':\n      return new Xliff2();\n    case 'xliff':\n    case 'xlf':\n    default:\n      return new Xliff();\n  }\n}\nclass MessageBundle {\n  _htmlParser;\n  _implicitTags;\n  _implicitAttrs;\n  _locale;\n  _preserveWhitespace;\n  _messages = [];\n  constructor(_htmlParser, _implicitTags, _implicitAttrs, _locale = null, _preserveWhitespace = true) {\n    this._htmlParser = _htmlParser;\n    this._implicitTags = _implicitTags;\n    this._implicitAttrs = _implicitAttrs;\n    this._locale = _locale;\n    this._preserveWhitespace = _preserveWhitespace;\n  }\n  updateFromTemplate(source, url) {\n    const htmlParserResult = this._htmlParser.parse(source, url, {\n      tokenizeExpansionForms: true\n    });\n    if (htmlParserResult.errors.length) {\n      return htmlParserResult.errors;\n    }\n    const rootNodes = this._preserveWhitespace ? htmlParserResult.rootNodes : visitAllWithSiblings(new WhitespaceVisitor(false), htmlParserResult.rootNodes);\n    const i18nParserResult = extractMessages(rootNodes, this._implicitTags, this._implicitAttrs, this._preserveWhitespace);\n    if (i18nParserResult.errors.length) {\n      return i18nParserResult.errors;\n    }\n    this._messages.push(...i18nParserResult.messages);\n    return [];\n  }\n  getMessages() {\n    return this._messages;\n  }\n  write(serializer, filterSources) {\n    const messages = {};\n    const mapperVisitor = new MapPlaceholderNames();\n    this._messages.forEach(message => {\n      const id = serializer.digest(message);\n      if (!messages.hasOwnProperty(id)) {\n        messages[id] = message;\n      } else {\n        messages[id].sources.push(...message.sources);\n      }\n    });\n    const msgList = Object.keys(messages).map(id => {\n      const mapper = serializer.createNameMapper(messages[id]);\n      const src = messages[id];\n      const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n      let transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n      transformedMessage.sources = src.sources;\n      if (filterSources) {\n        transformedMessage.sources.forEach(source => source.filePath = filterSources(source.filePath));\n      }\n      return transformedMessage;\n    });\n    return serializer.write(msgList, this._locale);\n  }\n}\nclass MapPlaceholderNames extends CloneVisitor {\n  convert(nodes, mapper) {\n    return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n  }\n  visitTagPlaceholder(ph, mapper) {\n    const startName = mapper.toPublicName(ph.startName);\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n    const children = ph.children.map(n => n.visit(this, mapper));\n    return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitBlockPlaceholder(ph, mapper) {\n    const startName = mapper.toPublicName(ph.startName);\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n    const children = ph.children.map(n => n.visit(this, mapper));\n    return new BlockPlaceholder(ph.name, ph.parameters, startName, closeName, children, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitPlaceholder(ph, mapper) {\n    return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n  }\n  visitIcuPlaceholder(ph, mapper) {\n    return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n  }\n}\nfunction compileClassMetadata(metadata) {\n  const fnCall = internalCompileClassMetadata(metadata);\n  return arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]).callFn([]);\n}\nfunction internalCompileClassMetadata(metadata) {\n  return importExpr(Identifiers.setClassMetadata).callFn([metadata.type, metadata.decorators, metadata.ctorParameters ?? literal(null), metadata.propDecorators ?? literal(null)]);\n}\nfunction compileComponentClassMetadata(metadata, dependencies) {\n  if (dependencies === null || dependencies.length === 0) {\n    return compileClassMetadata(metadata);\n  }\n  return internalCompileSetClassMetadataAsync(metadata, dependencies.map(dep => new FnParam(dep.symbolName, DYNAMIC_TYPE)), compileComponentMetadataAsyncResolver(dependencies));\n}\nfunction compileOpaqueAsyncClassMetadata(metadata, deferResolver, deferredDependencyNames) {\n  return internalCompileSetClassMetadataAsync(metadata, deferredDependencyNames.map(name => new FnParam(name, DYNAMIC_TYPE)), deferResolver);\n}\nfunction internalCompileSetClassMetadataAsync(metadata, wrapperParams, dependencyResolverFn) {\n  const setClassMetadataCall = internalCompileClassMetadata(metadata);\n  const setClassMetaWrapper = arrowFn(wrapperParams, [setClassMetadataCall.toStmt()]);\n  const setClassMetaAsync = importExpr(Identifiers.setClassMetadataAsync).callFn([metadata.type, dependencyResolverFn, setClassMetaWrapper]);\n  return arrowFn([], [devOnlyGuardedExpression(setClassMetaAsync).toStmt()]).callFn([]);\n}\nfunction compileComponentMetadataAsyncResolver(dependencies) {\n  const dynamicImports = dependencies.map(({\n    symbolName,\n    importPath,\n    isDefaultImport\n  }) => {\n    const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(isDefaultImport ? 'default' : symbolName));\n    return new DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n  });\n  return arrowFn([], literalArr(dynamicImports));\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$5 = '12.0.0';\nconst MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION = '18.0.0';\nfunction compileDeclareClassMetadata(metadata) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));\n  definitionMap.set('version', literal('21.0.6'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('decorators', metadata.decorators);\n  definitionMap.set('ctorParameters', metadata.ctorParameters);\n  definitionMap.set('propDecorators', metadata.propDecorators);\n  return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\nfunction compileComponentDeclareClassMetadata(metadata, dependencies) {\n  if (dependencies === null || dependencies.length === 0) {\n    return compileDeclareClassMetadata(metadata);\n  }\n  const definitionMap = new DefinitionMap();\n  const callbackReturnDefinitionMap = new DefinitionMap();\n  callbackReturnDefinitionMap.set('decorators', metadata.decorators);\n  callbackReturnDefinitionMap.set('ctorParameters', metadata.ctorParameters ?? literal(null));\n  callbackReturnDefinitionMap.set('propDecorators', metadata.propDecorators ?? literal(null));\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION));\n  definitionMap.set('version', literal('21.0.6'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('resolveDeferredDeps', compileComponentMetadataAsyncResolver(dependencies));\n  definitionMap.set('resolveMetadata', arrowFn(dependencies.map(dep => new FnParam(dep.symbolName, DYNAMIC_TYPE)), callbackReturnDefinitionMap.toLiteralMap()));\n  return importExpr(Identifiers.declareClassMetadataAsync).callFn([definitionMap.toLiteralMap()]);\n}\nfunction toOptionalLiteralArray(values, mapper) {\n  if (values === null || values.length === 0) {\n    return null;\n  }\n  return literalArr(values.map(value => mapper(value)));\n}\nfunction toOptionalLiteralMap(object, mapper) {\n  const entries = Object.keys(object).map(key => {\n    const value = object[key];\n    return {\n      key,\n      value: mapper(value),\n      quoted: true\n    };\n  });\n  if (entries.length > 0) {\n    return literalMap(entries);\n  } else {\n    return null;\n  }\n}\nfunction compileDependencies(deps) {\n  if (deps === 'invalid') {\n    return literal('invalid');\n  } else if (deps === null) {\n    return literal(null);\n  } else {\n    return literalArr(deps.map(compileDependency));\n  }\n}\nfunction compileDependency(dep) {\n  const depMeta = new DefinitionMap();\n  depMeta.set('token', dep.token);\n  if (dep.attributeNameType !== null) {\n    depMeta.set('attribute', literal(true));\n  }\n  if (dep.host) {\n    depMeta.set('host', literal(true));\n  }\n  if (dep.optional) {\n    depMeta.set('optional', literal(true));\n  }\n  if (dep.self) {\n    depMeta.set('self', literal(true));\n  }\n  if (dep.skipSelf) {\n    depMeta.set('skipSelf', literal(true));\n  }\n  return depMeta.toLiteralMap();\n}\nfunction compileDeclareDirectiveFromMetadata(meta) {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);\n  const type = createDirectiveType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createDirectiveDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  const minVersion = getMinimumVersionForPartialOutput(meta);\n  definitionMap.set('minVersion', literal(minVersion));\n  definitionMap.set('version', literal('21.0.6'));\n  definitionMap.set('type', meta.type.value);\n  if (meta.isStandalone !== undefined) {\n    definitionMap.set('isStandalone', literal(meta.isStandalone));\n  }\n  if (meta.isSignal) {\n    definitionMap.set('isSignal', literal(meta.isSignal));\n  }\n  if (meta.selector !== null) {\n    definitionMap.set('selector', literal(meta.selector));\n  }\n  definitionMap.set('inputs', needsNewInputPartialOutput(meta) ? createInputsPartialMetadata(meta.inputs) : legacyInputsPartialMetadata(meta.inputs));\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n  definitionMap.set('host', compileHostMetadata(meta.host));\n  definitionMap.set('providers', meta.providers);\n  if (meta.queries.length > 0) {\n    definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));\n  }\n  if (meta.viewQueries.length > 0) {\n    definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));\n  }\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', asLiteral(meta.exportAs));\n  }\n  if (meta.usesInheritance) {\n    definitionMap.set('usesInheritance', literal(true));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    definitionMap.set('usesOnChanges', literal(true));\n  }\n  if (meta.hostDirectives?.length) {\n    definitionMap.set('hostDirectives', createHostDirectives(meta.hostDirectives));\n  }\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  return definitionMap;\n}\nfunction getMinimumVersionForPartialOutput(meta) {\n  let minVersion = '14.0.0';\n  const hasDecoratorTransformFunctions = Object.values(meta.inputs).some(input => input.transformFunction !== null);\n  if (hasDecoratorTransformFunctions) {\n    minVersion = '16.1.0';\n  }\n  if (needsNewInputPartialOutput(meta)) {\n    minVersion = '17.1.0';\n  }\n  if (meta.queries.some(q => q.isSignal) || meta.viewQueries.some(q => q.isSignal)) {\n    minVersion = '17.2.0';\n  }\n  return minVersion;\n}\nfunction needsNewInputPartialOutput(meta) {\n  return Object.values(meta.inputs).some(input => input.isSignal);\n}\nfunction compileQuery(query) {\n  const meta = new DefinitionMap();\n  meta.set('propertyName', literal(query.propertyName));\n  if (query.first) {\n    meta.set('first', literal(true));\n  }\n  meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) : convertFromMaybeForwardRefExpression(query.predicate));\n  if (!query.emitDistinctChangesOnly) {\n    meta.set('emitDistinctChangesOnly', literal(false));\n  }\n  if (query.descendants) {\n    meta.set('descendants', literal(true));\n  }\n  meta.set('read', query.read);\n  if (query.static) {\n    meta.set('static', literal(true));\n  }\n  if (query.isSignal) {\n    meta.set('isSignal', literal(true));\n  }\n  return meta.toLiteralMap();\n}\nfunction compileHostMetadata(meta) {\n  const hostMetadata = new DefinitionMap();\n  hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));\n  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));\n  if (meta.specialAttributes.styleAttr) {\n    hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));\n  }\n  if (meta.specialAttributes.classAttr) {\n    hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));\n  }\n  if (hostMetadata.values.length > 0) {\n    return hostMetadata.toLiteralMap();\n  } else {\n    return null;\n  }\n}\nfunction createHostDirectives(hostDirectives) {\n  const expressions = hostDirectives.map(current => {\n    const keys = [{\n      key: 'directive',\n      value: current.isForwardReference ? generateForwardRef(current.directive.type) : current.directive.type,\n      quoted: false\n    }];\n    const inputsLiteral = current.inputs ? createHostDirectivesMappingArray(current.inputs) : null;\n    const outputsLiteral = current.outputs ? createHostDirectivesMappingArray(current.outputs) : null;\n    if (inputsLiteral) {\n      keys.push({\n        key: 'inputs',\n        value: inputsLiteral,\n        quoted: false\n      });\n    }\n    if (outputsLiteral) {\n      keys.push({\n        key: 'outputs',\n        value: outputsLiteral,\n        quoted: false\n      });\n    }\n    return literalMap(keys);\n  });\n  return literalArr(expressions);\n}\nfunction createInputsPartialMetadata(inputs) {\n  const keys = Object.getOwnPropertyNames(inputs);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(declaredName => {\n    const value = inputs[declaredName];\n    return {\n      key: declaredName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(declaredName),\n      value: literalMap([{\n        key: 'classPropertyName',\n        quoted: false,\n        value: asLiteral(value.classPropertyName)\n      }, {\n        key: 'publicName',\n        quoted: false,\n        value: asLiteral(value.bindingPropertyName)\n      }, {\n        key: 'isSignal',\n        quoted: false,\n        value: asLiteral(value.isSignal)\n      }, {\n        key: 'isRequired',\n        quoted: false,\n        value: asLiteral(value.required)\n      }, {\n        key: 'transformFunction',\n        quoted: false,\n        value: value.transformFunction ?? NULL_EXPR\n      }])\n    };\n  }));\n}\nfunction legacyInputsPartialMetadata(inputs) {\n  const keys = Object.getOwnPropertyNames(inputs);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(declaredName => {\n    const value = inputs[declaredName];\n    const publicName = value.bindingPropertyName;\n    const differentDeclaringName = publicName !== declaredName;\n    let result;\n    if (differentDeclaringName || value.transformFunction !== null) {\n      const values = [asLiteral(publicName), asLiteral(declaredName)];\n      if (value.transformFunction !== null) {\n        values.push(value.transformFunction);\n      }\n      result = literalArr(values);\n    } else {\n      result = asLiteral(publicName);\n    }\n    return {\n      key: declaredName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(declaredName),\n      value: result\n    };\n  }));\n}\nfunction compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {\n  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n  const expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createComponentDefinitionMap(meta, template, templateInfo) {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n  const blockVisitor = new BlockPresenceVisitor();\n  visitAll$1(blockVisitor, template.nodes);\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', literal(true));\n  }\n  if (blockVisitor.hasBlocks) {\n    definitionMap.set('minVersion', literal('17.0.0'));\n  }\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));\n  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n  if (meta.changeDetection !== null) {\n    if (typeof meta.changeDetection === 'object') {\n      throw new Error('Impossible state! Change detection flag is not resolved!');\n    }\n    definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy).prop(ChangeDetectionStrategy[meta.changeDetection]));\n  }\n  if (meta.encapsulation !== ViewEncapsulation$1.Emulated) {\n    definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(ViewEncapsulation$1[meta.encapsulation]));\n  }\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', literal(true));\n  }\n  if (meta.defer.mode === 0) {\n    const resolvers = [];\n    let hasResolvers = false;\n    for (const deps of meta.defer.blocks.values()) {\n      if (deps === null) {\n        resolvers.push(literal(null));\n      } else {\n        resolvers.push(deps);\n        hasResolvers = true;\n      }\n    }\n    if (hasResolvers) {\n      definitionMap.set('deferBlockDependencies', literalArr(resolvers));\n    }\n  } else {\n    throw new Error('Unsupported defer function emit mode in partial compilation');\n  }\n  return definitionMap;\n}\nfunction getTemplateExpression(template, templateInfo) {\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  }\n  if (templateInfo.isInline) {\n    return literal(templateInfo.content, null, null);\n  }\n  const contents = templateInfo.content;\n  const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = computeEndLocation(file, contents);\n  const span = new ParseSourceSpan(start, end);\n  return literal(contents, null, span);\n}\nfunction computeEndLocation(file, contents) {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\nfunction compileUsedDependenciesMetadata(meta) {\n  const wrapType = meta.declarationListEmitMode !== 0 ? generateForwardRef : expr => expr;\n  if (meta.declarationListEmitMode === 3) {\n    throw new Error(`Unsupported emit mode`);\n  }\n  return toOptionalLiteralArray(meta.declarations, decl => {\n    switch (decl.kind) {\n      case R3TemplateDependencyKind.Directive:\n        const dirMeta = new DefinitionMap();\n        dirMeta.set('kind', literal(decl.isComponent ? 'component' : 'directive'));\n        dirMeta.set('type', wrapType(decl.type));\n        dirMeta.set('selector', literal(decl.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, literal));\n        return dirMeta.toLiteralMap();\n      case R3TemplateDependencyKind.Pipe:\n        const pipeMeta = new DefinitionMap();\n        pipeMeta.set('kind', literal('pipe'));\n        pipeMeta.set('type', wrapType(decl.type));\n        pipeMeta.set('name', literal(decl.name));\n        return pipeMeta.toLiteralMap();\n      case R3TemplateDependencyKind.NgModule:\n        const ngModuleMeta = new DefinitionMap();\n        ngModuleMeta.set('kind', literal('ngmodule'));\n        ngModuleMeta.set('type', wrapType(decl.type));\n        return ngModuleMeta.toLiteralMap();\n    }\n  });\n}\nclass BlockPresenceVisitor extends RecursiveVisitor$1 {\n  hasBlocks = false;\n  visitDeferredBlock() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockPlaceholder() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockLoading() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockError() {\n    this.hasBlocks = true;\n  }\n  visitIfBlock() {\n    this.hasBlocks = true;\n  }\n  visitIfBlockBranch() {\n    this.hasBlocks = true;\n  }\n  visitForLoopBlock() {\n    this.hasBlocks = true;\n  }\n  visitForLoopBlockEmpty() {\n    this.hasBlocks = true;\n  }\n  visitSwitchBlock() {\n    this.hasBlocks = true;\n  }\n  visitSwitchBlockCase() {\n    this.hasBlocks = true;\n  }\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';\nfunction compileDeclareFactoryFunction(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));\n  definitionMap.set('version', literal('21.0.6'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('deps', compileDependencies(meta.deps));\n  definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(FactoryTarget[meta.target]));\n  return {\n    expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),\n    statements: [],\n    type: createFactoryType(meta)\n  };\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';\nfunction compileDeclareInjectableFromMetadata(meta) {\n  const definitionMap = createInjectableDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectableType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectableDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));\n  definitionMap.set('version', literal('21.0.6'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.providedIn !== undefined) {\n    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n    if (providedIn.value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n  }\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n  }\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n  }\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));\n  }\n  return definitionMap;\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';\nfunction compileDeclareInjectorFromMetadata(meta) {\n  const definitionMap = createInjectorDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectorType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectorDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));\n  definitionMap.set('version', literal('21.0.6'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('providers', meta.providers);\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', literalArr(meta.imports));\n  }\n  return definitionMap;\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$1 = '14.0.0';\nfunction compileDeclareNgModuleFromMetadata(meta) {\n  const definitionMap = createNgModuleDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n  const type = createNgModuleType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createNgModuleDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    throw new Error('Invalid path! Local compilation mode should not get into the partial compilation path');\n  }\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));\n  definitionMap.set('version', literal('21.0.6'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n  if (meta.declarations.length > 0) {\n    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n  }\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n  }\n  if (meta.exports.length > 0) {\n    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n  }\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n  }\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n  }\n  return definitionMap;\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\nfunction compileDeclarePipeFromMetadata(meta) {\n  const definitionMap = createPipeDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  const type = createPipeType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createPipeDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', literal('21.0.6'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.isStandalone !== undefined) {\n    definitionMap.set('isStandalone', literal(meta.isStandalone));\n  }\n  definitionMap.set('name', literal(meta.pipeName ?? meta.name));\n  if (meta.pure === false) {\n    definitionMap.set('pure', literal(meta.pure));\n  }\n  return definitionMap;\n}\nfunction compileClassDebugInfo(debugInfo) {\n  const debugInfoObject = {\n    className: debugInfo.className\n  };\n  if (debugInfo.filePath) {\n    debugInfoObject.filePath = debugInfo.filePath;\n    debugInfoObject.lineNumber = debugInfo.lineNumber;\n  }\n  if (debugInfo.forbidOrphanRendering) {\n    debugInfoObject.forbidOrphanRendering = literal(true);\n  }\n  const fnCall = importExpr(Identifiers.setClassDebugInfo).callFn([debugInfo.type, mapLiteral(debugInfoObject)]);\n  const iife = arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]);\n}\nfunction compileHmrInitializer(meta) {\n  const moduleName = 'm';\n  const dataName = 'd';\n  const timestampName = 't';\n  const idName = 'id';\n  const importCallbackName = `${meta.className}_HmrLoad`;\n  const namespaces = meta.namespaceDependencies.map(dep => {\n    return new ExternalExpr({\n      moduleName: dep.moduleName,\n      name: null\n    });\n  });\n  const defaultRead = variable(moduleName).prop('default');\n  const replaceCall = importExpr(Identifiers.replaceMetadata).callFn([meta.type, defaultRead, literalArr(namespaces), literalArr(meta.localDependencies.map(l => l.runtimeRepresentation)), variable('import').prop('meta'), variable(idName)]);\n  const replaceCallback = arrowFn([new FnParam(moduleName)], defaultRead.and(replaceCall));\n  const url = importExpr(Identifiers.getReplaceMetadataURL).callFn([variable(idName), variable(timestampName), variable('import').prop('meta').prop('url')]);\n  const importCallback = new DeclareFunctionStmt(importCallbackName, [new FnParam(timestampName)], [new DynamicImportExpr(url, null, '@vite-ignore').prop('then').callFn([replaceCallback]).toStmt()], null, StmtModifier.Final);\n  const updateCallback = arrowFn([new FnParam(dataName)], variable(dataName).prop('id').identical(variable(idName)).and(variable(importCallbackName).callFn([variable(dataName).prop('timestamp')])));\n  const initialCall = variable(importCallbackName).callFn([variable('Date').prop('now').callFn([])]);\n  const hotRead = variable('import').prop('meta').prop('hot');\n  const hotListener = hotRead.clone().prop('on').callFn([literal('angular:component-update'), updateCallback]);\n  return arrowFn([], [new DeclareVarStmt(idName, literal(encodeURIComponent(`${meta.filePath}@${meta.className}`)), null, StmtModifier.Final), importCallback, devOnlyGuardedExpression(initialCall).toStmt(), devOnlyGuardedExpression(hotRead.and(hotListener)).toStmt()]).callFn([]);\n}\nfunction compileHmrUpdateCallback(definitions, constantStatements, meta) {\n  const namespaces = 'ÉµÉµnamespaces';\n  const params = [meta.className, namespaces].map(name => new FnParam(name, DYNAMIC_TYPE));\n  const body = [];\n  for (const local of meta.localDependencies) {\n    params.push(new FnParam(local.name));\n  }\n  for (let i = 0; i < meta.namespaceDependencies.length; i++) {\n    body.push(new DeclareVarStmt(meta.namespaceDependencies[i].assignedName, variable(namespaces).key(literal(i)), DYNAMIC_TYPE, StmtModifier.Final));\n  }\n  body.push(...constantStatements);\n  for (const field of definitions) {\n    if (field.initializer !== null) {\n      body.push(variable(meta.className).prop(field.name).set(field.initializer).toStmt());\n      for (const stmt of field.statements) {\n        body.push(stmt);\n      }\n    }\n  }\n  return new DeclareFunctionStmt(`${meta.className}_UpdateMetadata`, params, body, null, StmtModifier.Final);\n}\nconst VERSION = new Version('21.0.6');\npublishFacade(_global);\nexport { AST, ASTWithName, ASTWithSource, AbsoluteSourceSpan, ArrayType, ArrowFunctionExpr, Attribute, Binary, BinaryOperator, BinaryOperatorExpr, BindingPipe, BindingPipeType, BindingType, Block, BlockParameter, BoundElementProperty, BuiltinType, BuiltinTypeName, CUSTOM_ELEMENTS_SCHEMA, Call, Chain, ChangeDetectionStrategy, CombinedRecursiveAstVisitor, CommaExpr, Comment, CompilerConfig, CompilerFacadeImpl, Component, Conditional, ConditionalExpr, ConstantPool, CssSelector, DYNAMIC_TYPE, DeclareFunctionStmt, DeclareVarStmt, Directive, DomElementSchemaRegistry, DynamicImportExpr, EOF, Element, ElementSchemaRegistry, EmitterVisitorContext, EmptyExpr$1 as EmptyExpr, Expansion, ExpansionCase, Expression, ExpressionBinding, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, FactoryTarget, FunctionExpr, HtmlParser, HtmlTagDefinition, I18NHtmlParser, IfStmt, ImplicitReceiver, InstantiateExpr, Interpolation$1 as Interpolation, InvokeFunctionExpr, JSDocComment, JitEvaluator, KeyedRead, LeadingComment, LetDeclaration, Lexer, LiteralArray, LiteralArrayExpr, LiteralExpr, LiteralMap, LiteralMapExpr, LiteralPrimitive, LocalizedString, MapType, MessageBundle, NONE_TYPE, NO_ERRORS_SCHEMA, NodeWithI18n, NonNullAssert, NotExpr, ParenthesizedExpr, ParenthesizedExpression, ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseSpan, ParseTreeResult, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, Parser, PrefixNot, PropertyRead, Identifiers as R3Identifiers, R3NgModuleMetadataKind, R3SelectorScopeMode, R3TargetBinder, R3TemplateDependencyKind, ReadKeyExpr, ReadPropExpr, ReadVarExpr, RecursiveAstVisitor, RecursiveVisitor, RegularExpressionLiteral, RegularExpressionLiteralExpr, ResourceLoader, ReturnStatement, SCHEMA, SECURITY_SCHEMA, STRING_TYPE, SafeCall, SafeKeyedRead, SafePropertyRead, SelectorContext, SelectorListContext, SelectorMatcher, SelectorlessMatcher, Serializer, SplitInterpolation, Statement, StmtModifier, StringToken, StringTokenKind, TagContentType, TaggedTemplateLiteral, TaggedTemplateLiteralExpr, TemplateBindingParseResult, TemplateLiteral, TemplateLiteralElement, TemplateLiteralElementExpr, TemplateLiteralExpr, Text, ThisReceiver, BlockNode as TmplAstBlockNode, BoundAttribute as TmplAstBoundAttribute, BoundDeferredTrigger as TmplAstBoundDeferredTrigger, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Component$1 as TmplAstComponent, Content as TmplAstContent, DeferredBlock as TmplAstDeferredBlock, DeferredBlockError as TmplAstDeferredBlockError, DeferredBlockLoading as TmplAstDeferredBlockLoading, DeferredBlockPlaceholder as TmplAstDeferredBlockPlaceholder, DeferredTrigger as TmplAstDeferredTrigger, Directive$1 as TmplAstDirective, Element$1 as TmplAstElement, ForLoopBlock as TmplAstForLoopBlock, ForLoopBlockEmpty as TmplAstForLoopBlockEmpty, HostElement as TmplAstHostElement, HoverDeferredTrigger as TmplAstHoverDeferredTrigger, Icu$1 as TmplAstIcu, IdleDeferredTrigger as TmplAstIdleDeferredTrigger, IfBlock as TmplAstIfBlock, IfBlockBranch as TmplAstIfBlockBranch, ImmediateDeferredTrigger as TmplAstImmediateDeferredTrigger, InteractionDeferredTrigger as TmplAstInteractionDeferredTrigger, LetDeclaration$1 as TmplAstLetDeclaration, NeverDeferredTrigger as TmplAstNeverDeferredTrigger, RecursiveVisitor$1 as TmplAstRecursiveVisitor, Reference as TmplAstReference, SwitchBlock as TmplAstSwitchBlock, SwitchBlockCase as TmplAstSwitchBlockCase, Template as TmplAstTemplate, Text$3 as TmplAstText, TextAttribute as TmplAstTextAttribute, TimerDeferredTrigger as TmplAstTimerDeferredTrigger, UnknownBlock as TmplAstUnknownBlock, Variable as TmplAstVariable, ViewportDeferredTrigger as TmplAstViewportDeferredTrigger, Token, TokenType, TransplantedType, TreeError, Type, TypeModifier, TypeofExpr, TypeofExpression, Unary, UnaryOperator, UnaryOperatorExpr, VERSION, VariableBinding, Version, ViewEncapsulation$1 as ViewEncapsulation, VoidExpr, VoidExpression, WrappedNodeExpr, Xliff, Xliff2, Xmb, XmlParser, Xtb, _ATTR_TO_PROP, compileClassDebugInfo, compileClassMetadata, compileComponentClassMetadata, compileComponentDeclareClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, compileDeclareDirectiveFromMetadata, compileDeclareFactoryFunction, compileDeclareInjectableFromMetadata, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileDeclarePipeFromMetadata, compileDeferResolverFunction, compileDirectiveFromMetadata, compileFactoryFunction, compileHmrInitializer, compileHmrUpdateCallback, compileInjectable, compileInjector, compileNgModule, compileOpaqueAsyncClassMetadata, compilePipeFromMetadata, computeMsgId, core, createCssSelectorFromNode, createInjectableType, createMayBeForwardRefExpression, devOnlyGuardedExpression, emitDistinctChangesOnlyDefaultValue, encapsulateStyle, escapeRegExp, findMatchingDirectivesAndPipes, getHtmlTagDefinition, getNsPrefix, getSafePropertyAccessString, identifierName, isNgContainer, isNgContent, isNgTemplate, jsDocComment, leadingComment, literal, literalMap, makeBindingParser, mergeNsAndName, output_ast as outputAst, parseHostBindings, parseTemplate, preserveWhitespacesDefault, publishFacade, r3JitTypeSourceSpan, sanitizeIdentifier, setEnableTemplateSourceLocations, splitNsName, visitAll$1 as tmplAstVisitAll, verifyHostBindings, visitAll };\n//# sourceMappingURL=compiler.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}